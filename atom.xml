<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackeyzhe&#39;s Blog</title>
  
  <subtitle>靠脸吃饭</subtitle>
  <link href="https://jackeyzhe.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackeyzhe.github.io/"/>
  <updated>2025-08-24T16:45:33.281Z</updated>
  <id>https://jackeyzhe.github.io/</id>
  
  <author>
    <name>Jackey Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink学习笔记：状态后端</title>
    <link href="https://jackeyzhe.github.io/2025/08/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/"/>
    <id>https://jackeyzhe.github.io/2025/08/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/</id>
    <published>2025-08-23T16:16:42.000Z</published>
    <updated>2025-08-24T16:45:33.281Z</updated>
    
    <content type="html"><![CDATA[<p>我们继续来聊 Flink 容错相关的内容。前面在介绍 Checkpoint 和 Savepoint 时提到了 State 的稳定存储，那究竟如何存储以及存储在什么地方呢？相信通过读完本文之后，你会有答案。<span id="more"></span></p><h3 id="State-Backend-分类"><a href="#State-Backend-分类" class="headerlink" title="State Backend 分类"></a>State Backend 分类</h3><p>在 Flink 中状态后端（State Backend）是用来管理状态如何存储的。当前内置了两种 State Backend，分别是 HashMapStateBackend 和 EmbeddedRocksDBStateBackend。Flink 默认使用的是 HashMapStateBackend。</p><h4 id="HashMapStateBackend"><a href="#HashMapStateBackend" class="headerlink" title="HashMapStateBackend"></a>HashMapStateBackend</h4><p>在 HashMapBackend 中，数据是以 Java 对象的形式存储的，它适用于有较大 State，较长 window 和 较大 key/value 状态的场景。同时适用于高可用场景。在使用 HashMapStateBackend 时，建议把 managed memory 设置为 0，以此来增加用户代码可使用的内存。</p><h4 id="EmbeddedRocksDBStateBackend"><a href="#EmbeddedRocksDBStateBackend" class="headerlink" title="EmbeddedRocksDBStateBackend"></a>EmbeddedRocksDBStateBackend</h4><p>对于 EmbeddedRocksDBStateBackend 而言，数据是存储在 RocksDB 中的，在存储之前，要对数据进行序列化。EmbeddedRocksDBStateBackend 也存在一定局限性，那就是最大只能支持每个 key/value 存储 2^31 字节大小的数据，这是当前 RocksDB JNI 的限制。</p><p>EmbeddedRocksDBStateBackend 也有一定的优势，其一是它是目前唯一支持增量 Checkpoint 的 State Backend。其二是因为它是外部存储，因此它可以支持非常大的 State，非常长的窗口。</p><p>增量快照只包含自上一次快照完成后被修改的记录，所以增量快照的一大优点就是可以显著减少快照的耗时。在恢复时间上，要分情况讨论，如果瓶颈在网络带宽，那么增量快照的恢复时间要比全量快照更长，因为增量快照包含的多个 sst 文件之间可能存在重复数据。如果瓶颈在 CPU 或 IO，那增量快照恢复时间更短，因为增量快照不需要恢复不需要解析 Flink 统一的存储格式来重建本地的 RocksDB 表，而是直接基于 sst 文件加载。</p><h3 id="Checkpoint-存储类型"><a href="#Checkpoint-存储类型" class="headerlink" title="Checkpoint 存储类型"></a>Checkpoint 存储类型</h3><p>了解了 State Backend 分类之后，我们再来看 Checkpoint 的存储类型。它也分为两类：JobManagerCheckpointStorage 和 FileSystemCheckpointStorage。</p><h4 id="JobManagerCheckpointStorage"><a href="#JobManagerCheckpointStorage" class="headerlink" title="JobManagerCheckpointStorage"></a>JobManagerCheckpointStorage</h4><p>JobManagerCheckpointStorage 是将快照存储在 JobManager 的堆内存中。JobManagerCheckpointStorage 在使用时有一定限制：</p><ul><li><p>默认每个 State 大小最大为 5MB</p></li><li><p>总的状态大小不能超过 JobManager 内存</p></li></ul><p>基于这些限制，JobManagerCheckpointStorage 只适用于本地的开发和调试。</p><h4 id="FileSystemCheckpointStorage"><a href="#FileSystemCheckpointStorage" class="headerlink" title="FileSystemCheckpointStorage"></a>FileSystemCheckpointStorage</h4><p>FileSystemCheckpointStorage 是将状态数据保存在外部存储中，要适用 FileSystemCheckpointStorage，需要配置文件系统的 URL。例如：“hdfs://namenode:40010/flink/checkpoints”。而元数据</p><h3 id="Checkpoint-存储设置"><a href="#Checkpoint-存储设置" class="headerlink" title="Checkpoint 存储设置"></a>Checkpoint 存储设置</h3><p>有了前面 State Backend 和 存储类型的分类之后，我们就可以将其进行组合，得到最终 Checkpoint 的存储了。</p><p>目前共有三种组合，也对应了旧版本的三种 State Backend。</p><h3 id="MemoryStateBackend"><a href="#MemoryStateBackend" class="headerlink" title="MemoryStateBackend"></a>MemoryStateBackend</h3><p>MemoryStateBackend 对应了 HashMapStateBackend 和 JobManagerCheckpointStorage 的组合。</p><p>设置方法为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state.backend:</span> <span class="string">hashmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional, Flink will automatically default to JobManagerCheckpointStorage</span></span><br><span class="line"><span class="comment"># when no checkpoint directory is specified.</span></span><br><span class="line"><span class="attr">execution.checkpointing.storage:</span> <span class="string">jobmanager</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">config.set(StateBackendOptions.STATE_BACKEND, <span class="string">&quot;hashmap&quot;</span>);</span><br><span class="line">config.set(CheckpointingOptions.CHECKPOINT_STORAGE, <span class="string">&quot;jobmanager&quot;</span>);</span><br><span class="line">env.configure(config);</span><br></pre></td></tr></table></figure><h4 id="FsStateBackend"><a href="#FsStateBackend" class="headerlink" title="FsStateBackend"></a>FsStateBackend</h4><p>FsStateBackend 对应了 HashMapStateBackend 和 FileSystemCheckpointStorage 的组合。</p><p>它的设置方法为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state.backend:</span> <span class="string">hashmap</span></span><br><span class="line"><span class="attr">execution.checkpointing.dir:</span> <span class="string">file:///checkpoint-dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional, Flink will automatically default to FileSystemCheckpointStorage</span></span><br><span class="line"><span class="comment"># when a checkpoint directory is specified.</span></span><br><span class="line"><span class="attr">execution.checkpointing.storage:</span> <span class="string">filesystem</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">config.set(StateBackendOptions.STATE_BACKEND, <span class="string">&quot;hashmap&quot;</span>);</span><br><span class="line">config.set(CheckpointingOptions.CHECKPOINT_STORAGE, <span class="string">&quot;filesystem&quot;</span>);</span><br><span class="line">config.set(CheckpointingOptions.CHECKPOINTS_DIRECTORY, <span class="string">&quot;file:///checkpoint-dir&quot;</span>);</span><br><span class="line">env.configure(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Advanced FsStateBackend configurations, such as write buffer size</span></span><br><span class="line"><span class="comment">// can be set manually by using CheckpointingOptions.</span></span><br><span class="line">config.set(CheckpointingOptions.FS_WRITE_BUFFER_SIZE, <span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">env.configure(config);</span><br></pre></td></tr></table></figure><h4 id="RocksDBStateBackend"><a href="#RocksDBStateBackend" class="headerlink" title="RocksDBStateBackend"></a>RocksDBStateBackend</h4><p>RocksDBStateBackend 对应了 EmbeddedRocksDBStateBackend 和 FileSystemCheckpointStorage 的组合。</p><p>它的设置方法为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state.backend:</span> <span class="string">rocksdb</span></span><br><span class="line"><span class="attr">execution.checkpointing.dir:</span> <span class="string">file:///checkpoint-dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional, Flink will automatically default to FileSystemCheckpointStorage</span></span><br><span class="line"><span class="comment"># when a checkpoint directory is specified.</span></span><br><span class="line"><span class="attr">execution.checkpointing.storage:</span> <span class="string">filesystem</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">config.set(StateBackendOptions.STATE_BACKEND, <span class="string">&quot;rocksdb&quot;</span>);</span><br><span class="line">config.set(CheckpointingOptions.CHECKPOINT_STORAGE, <span class="string">&quot;filesystem&quot;</span>);</span><br><span class="line">config.set(CheckpointingOptions.CHECKPOINTS_DIRECTORY, <span class="string">&quot;file:///checkpoint-dir&quot;</span>);</span><br><span class="line">env.configure(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If you manually passed FsStateBackend into the RocksDBStateBackend constructor</span></span><br><span class="line"><span class="comment">// to specify advanced checkpointing configurations such as write buffer size,</span></span><br><span class="line"><span class="comment">// you can achieve the same results by using CheckpointingOptions.</span></span><br><span class="line">config.set(CheckpointingOptions.FS_WRITE_BUFFER_SIZE, <span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">env.configure(config);</span><br></pre></td></tr></table></figure><h3 id="State-序列化与反序列化"><a href="#State-序列化与反序列化" class="headerlink" title="State 序列化与反序列化"></a>State 序列化与反序列化</h3><p>我们前面在创建 State 的描述符时，指定了 State 的类型，这其实就是告诉 Flink 应该如何去序列化我们的 State。当然，也可以自定义 State 序列化器，自定义序列化器需要 TypeSerializer，然后在创建描述符时指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomTypeSerializer</span> <span class="keyword">extends</span> <span class="title class_">TypeSerializer</span>&lt;Tuple2&lt;String, Integer&gt;&gt; &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(</span><br><span class="line">        <span class="string">&quot;state-name&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CustomTypeSerializer</span>());</span><br><span class="line"></span><br><span class="line">checkpointedState = getRuntimeContext().getListState(descriptor);</span><br></pre></td></tr></table></figure><p>Flink 中状态分为两种类型，一种是基于 Heap，一种是不基于 Heap。</p><h4 id="Heap-state-backends"><a href="#Heap-state-backends" class="headerlink" title="Heap state backends"></a>Heap state backends</h4><p>首先看基于 Heap 的，HashMapStateBackend 是基于 Heap 的。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1756052394/Blog/flink/6/HeapStateBackend.png" alt="HeapStateBackend"></p><p>Heap state backend 存在本地的状态后端中的是非序列化的数据，当触发 Checkpoint / Savepoint 时，会用指定的序列化器将数据序列化，然后存储到指定的稳定存储中。</p><p>如果我们对程序进行了升级，这时要从 State 恢复的话，需要先将稳定存储中的数据进行反序列化，然后将结果加载到 TM 的内存中，供 user code 使用。</p><h4 id="Off-heap-state-backends"><a href="#Off-heap-state-backends" class="headerlink" title="Off-heap state backends"></a>Off-heap state backends</h4><p>EmbeddedRocksDBStateBackend 就是一种不基于 Heap 的状态。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1756053324/Blog/flink/6/OffHeapStateBackend.png" alt="Off-heap State Backend"></p><p>不基于 Heap 的状态在写入本地 State 时就会进行序列化，序列化后的数据会写入到堆外内存。在触发 Checkpoint 时，就只是把数据文件转存到稳定存储中。</p><p>当我们的任务完成升级后，会先将二进制文件恢复到 TM 的内存中，这里是一个文件加载的过程。当我们要使用 State 时，才会进行反序列化，注意这里只会对使用到的 State 进行反序列化读取以及后续的更新，没有使用到的还是保持旧版本的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们重点介绍了状态后端的存储。State Backend 分为 HashMapStateBackend 和 EmbeddedRocksDBStateBackend，其存储类型又分为 JobManagerCheckpointStorage 和 FileSystemCheckpointStorage。最终我们会有三种不同的状态后端：MemoryStateBackend、FsStateBackend 和 RocksDBStateBackend。最后我们还介绍了 State 的两种不同的序列化。</p><p>相信通过本文的介绍，你已经可以回答开篇的问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们继续来聊 Flink 容错相关的内容。前面在介绍 Checkpoint 和 Savepoint 时提到了 State 的稳定存储，那究竟如何存储以及存储在什么地方呢？相信通过读完本文之后，你会有答案。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：如何做容错</title>
    <link href="https://jackeyzhe.github.io/2025/08/17/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%AE%B9%E9%94%99/"/>
    <id>https://jackeyzhe.github.io/2025/08/17/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%AE%B9%E9%94%99/</id>
    <published>2025-08-17T03:29:28.000Z</published>
    <updated>2025-08-21T16:38:11.661Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们已经了解了 Flink 的状态如何定义和使用，那 Flink 是如何做容错的呢？今天我们一起来了解一下。<span id="more"></span></p><p>先来回答问题， Flink 是通过状态快照来做容错的，在 Flink 中状态快照分为 Checkpoint 和 Savepoint 两种。</p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>Checkpoint 是一种自动执行的快照，其目的是让 Flink 任务可以从故障中恢复。它可以是增量的，并且为快速恢复进行了优化。</p><h4 id="如何开启-Checkpoint"><a href="#如何开启-Checkpoint" class="headerlink" title="如何开启 Checkpoint"></a>如何开启 Checkpoint</h4><p>Checkpoint 默认是关闭的，开启的方法很简单，只需要调用 enableCheckpointing() 方法即可。除了这个方法之外，Checkpoint 还有一些高级特性。我们来看几个比较常用的，更多的选项可以查看<a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/fault-tolerance/checkpointing/#%e7%9b%b8%e5%85%b3%e7%9a%84%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9">官方文档</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每 1000ms 开始一次 checkpoint</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高级选项：</span></span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setTolerableCheckpointFailureNumber(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().setExternalizedCheckpointRetention(</span><br><span class="line">        ExternalizedCheckpointRetention.RETAIN_ON_CANCELLATION);</span><br><span class="line"></span><br><span class="line">env.getCheckpointConfig().enableUnalignedCheckpoints();</span><br></pre></td></tr></table></figure><ul><li><p>CheckpointingMode：支持 EXACTLY_ONCE 和 AT_LEAST_ONCE 两种，精确一次有更好的数据一致性，而至少一次可以提供更低的延迟。</p></li><li><p>MinPauseBetweenCheckpoints：Checkpoint 之间最小间隔时间，单位是毫秒，即前一次 Checkpoint 执行完成之后必须间隔 n 毫秒之后才会开启下一次 Checkpoint。</p></li><li><p>CheckpointTimeout：Checkpoint 超时时间，单位为毫秒，表示 Checkpoint 必须在 n 毫秒内完成，否则就会因超时失败。</p></li><li><p>TolerableCheckpointFailureNumber：可容忍连续失败次数，默认是0。超过这个阈值之后，整个 Flink 作业会触发 fail over。</p></li><li><p>MaxConcurrentCheckpoints：Checkpoint 并发数，默认情况下是1，在同一时间只允许一个 Checkpoint 执行。这个参数不能和最小间隔时间一起使用。</p></li><li><p>ExternalizedCheckpointRetention：周期存储 Checkpoint 到外部存储，这样在任务失败时 Checkpoint 也不会被删除。</p></li><li><p>enableUnalignedCheckpoints：使用非对齐的 Checkpoint，可以减少在产生背压时 Checkpoint 的创建时间。</p></li></ul><h4 id="Checkpoint-存储"><a href="#Checkpoint-存储" class="headerlink" title="Checkpoint 存储"></a>Checkpoint 存储</h4><p>Flink 提供了两种存储类型：JobManagerCheckpointStorage 和 FileSystemCheckpointStorage。默认是 JobManagerCheckpointStorage，即将 Checkpoint 快照存储在 JobManager 的堆内存中，也可以设置 Checkpoint 目录，将快照存储在外部存储系统中。</p><p>Checkpoint 目录通过 execution.checkpointing.dir 设置项设置。其目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/user-defined-checkpoint-dir</span><br><span class="line">    /&#123;job-id&#125;</span><br><span class="line">        |</span><br><span class="line">        + --shared/</span><br><span class="line">        + --taskowned/</span><br><span class="line">        + --chk-1/</span><br><span class="line">        + --chk-2/</span><br><span class="line">        + --chk-3/</span><br><span class="line">        ...   </span><br></pre></td></tr></table></figure><h4 id="Checkpoint-工作原理"><a href="#Checkpoint-工作原理" class="headerlink" title="Checkpoint 工作原理"></a>Checkpoint 工作原理</h4><p>在前文中，我们曾经提到过 Checkpoint Coordinator，它是 JobManager 的其中一个模块。它在 Checkpoint 过程中担任着重要的角色。</p><p>现在来看下 Checkpoint 的完整流程</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1755702080/Blog/flink/5/Checkpoint.png" alt="Checkpoint"></p><p>1、Checkpoint Coordinator 触发所有 Source 节点开始 Checkpoint，Source 收到触发命令后，会将自己的 State 进行持久化（图中三角形），并且向下游发送 barrier 事件（图中的小矩形）。当 Source 节点的 State 持久化完成之后，会数据存储的地址发送给 Checkpoint Coordinator。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1755706201/Blog/flink/5/CheckpointHandle.png" alt="CheckpointHandle"></p><p>2、barrier 事件随着事件流传输到下游节点，当下游节点收到所有的上游 barrier 事件后，也会将自己的 State 持久化，并继续向下传播 barrier 事件。持久化完成后，也同样将数据存储地址发送给 Checkpoint Coordinator。</p><p>3、当所有的算子都完成持久化过程后，Checkpoint Coordinator 会将一些元数据进行持久化。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1755706201/Blog/flink/5/CompleteCheckpoint.png" alt="CompleteCheckpoint"></p><p>至此，一次完整的 Checkpoint 流程就结束了。</p><h3 id="Savepoint"><a href="#Savepoint" class="headerlink" title="Savepoint"></a>Savepoint</h3><p>学习完 Checkpoint 之后，我们再来了解下另一种快照——Savepoint。</p><p>Savepoint 是依据 checkpoint 机制创建的一致性镜像。通常用来做 Flink 作业的重启或更新等运维操作。Savepoint 包含稳定存储上的二进制文件（作业状态的镜像）和元数据文件两部分。</p><h4 id="使用-Savepoint"><a href="#使用-Savepoint" class="headerlink" title="使用 Savepoint"></a>使用 Savepoint</h4><p>根据官方文档的提示，在我们的程序中，最好显式调用 uid() 方法来为算子指定一个 ID，这些 ID 被用来恢复每个算子的状态。如果不指定的话，Flink 任务会自动生成算子 ID，但是生成的 ID 与程序结构有关，也就是说，如果程序的结构改变了的话，就没有办法从 Savepoint 恢复对应算子的状态了。</p><p>有了这个前提条件之后，我们就可以使用命令来操作 Savepoint 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 触发 savepoint</span><br><span class="line">$ bin/flink savepoint :jobId [:targetDirectory]</span><br><span class="line"></span><br><span class="line">// 触发 savepoint, 指定 <span class="built_in">type</span>，默认是 canonical</span><br><span class="line">$ bin/flink savepoint --<span class="built_in">type</span> [native/canonical] :jobId [:targetDirectory]</span><br><span class="line"></span><br><span class="line">// 触发 savepoint，客户端拿到 trigger <span class="built_in">id</span> 后立即返回</span><br><span class="line">$ bin/flink savepoint :jobId [:targetDirectory] -detached</span><br><span class="line"></span><br><span class="line">// 使用 savepoint 停止作业</span><br><span class="line">$ bin/flink stop --<span class="built_in">type</span> [native/canonical] --savepointPath [:targetDirectory] :jobId</span><br><span class="line"></span><br><span class="line">// 从 savepoint 恢复</span><br><span class="line">$ bin/flink run -s :savepointPath [:runArgs]</span><br><span class="line"></span><br><span class="line">// 删除 savepoint</span><br><span class="line">$ bin/flink savepoint -d :savepointPath</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 触发 savepoint 时，我们可以指定格式，两种格式的区别是：</p><ul><li><p>canonical（标准格式）：在任何存储都保持统一格式，重在保证兼容性。</p></li><li><p>native（原生格式）：标准格式创建和恢复都很慢，原生格式是以特定的状态后端的格式生成，可以更快的创建和恢复。</p></li></ul><h3 id="Checkpoint-与-Savepoint-区别"><a href="#Checkpoint-与-Savepoint-区别" class="headerlink" title="Checkpoint 与 Savepoint 区别"></a>Checkpoint 与 Savepoint 区别</h3><p>这是面试最常见的问题之一，有了 checkpoint，为什么还需要 savepoint？或者说两者之间有什么区别？</p><p>从概念上来讲，Checkpoint 类似数据库的恢复日志，而 Savepoint 类似数据库的备份。Checkpoint 主要用于作业故障的恢复，它的管理和删除也都是 Flink 内部处理，用户不需要过多关注。Savepoint 主要用于有计划的手动运维，例如升级 Flink 版本。它的创建、删除操作都需要用户手动执行。</p><p>下面是官方文档给出的 Checkpoint 和 Savepoint 支持的操作。✓表示完全支持，x表示不支持，!表示目前有效，但没有正式保证支持，使用时存在一定风险。</p><table><thead><tr><th>操作</th><th>标准 Savepoint</th><th>原生 Savepoint</th><th>对齐 Checkpoint</th><th>非对齐 Checkpoint</th></tr></thead><tbody><tr><td>更换状态后端</td><td>✓</td><td>x</td><td>x</td><td>x</td></tr><tr><td>State Processor API (写)</td><td>✓</td><td>x</td><td>x</td><td>x</td></tr><tr><td>State Processor API (读)</td><td>✓</td><td>!</td><td>!</td><td>x</td></tr><tr><td>自包含和可移动</td><td>✓</td><td>✓</td><td>x</td><td>x</td></tr><tr><td>Schema 变更</td><td>✓</td><td>!</td><td>!</td><td>!</td></tr><tr><td>任意 job 升级</td><td>✓</td><td>✓</td><td>✓</td><td>x</td></tr><tr><td>非任意 job 升级</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Flink 小版本升级</td><td>✓</td><td>✓</td><td>✓</td><td>x</td></tr><tr><td>Flink bug/patch 版本升级</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>扩缩容</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们介绍了 Flink 是如何做容错的，分别介绍了 Checkpoint 和 Savepoint，以及它们之间的区别。本文多次提到了 Checkpoint 和 Savepoint 依赖的稳定存储，我会在下一篇文章进行详细的介绍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们已经了解了 Flink 的状态如何定义和使用，那 Flink 是如何做容错的呢？今天我们一起来了解一下。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：状态类型和应用</title>
    <link href="https://jackeyzhe.github.io/2025/08/04/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://jackeyzhe.github.io/2025/08/04/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/</id>
    <published>2025-08-04T15:33:44.000Z</published>
    <updated>2025-08-14T14:43:30.348Z</updated>
    
    <content type="html"><![CDATA[<p>Flink 被广泛应用的原因，除了我们前面提到的对时间以及窗口的应用之外，另一点就是它强大的容错机制，以及对 Exactly Once 的支持。<span id="more"></span></p><p>今天就来了解一下 Flink 的状态以及应用，首先第一个问题是：什么是有状态计算？</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在数据流处理中，大部分操作都是每次只处理一个事件，比如对输入的数据进行结构化解析，这类操作我们称为无状态计算。而有些操作则需要记住多个事件并进行处理，比如前面我们在窗口中对数据做的求和操作，这类操作我们称之为有状态计算。</p><p>在 Flink 中，状态的另一个重要作用是用来做故障恢复，故障恢复主要依赖于 checkpoint 和 savepoint。当我们使用状态时，通常需要从 State Backend 读取。</p><p>通过介绍有状态计算的基本概念，我们又引出了 checkpoint、State Backend 等概念，下面我们再来一一解释。</p><h3 id="状态分类"><a href="#状态分类" class="headerlink" title="状态分类"></a>状态分类</h3><p>Flink 状态分类可以参考下图</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1754928263/Blog/flink/4/%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB.png" alt="状态分类"></p><p>首先是分为 Raw State 和 Managed State 两大类，我们分别从管理方式、数据类型、适用场景这三个方面来看它们的区别</p><table><thead><tr><th></th><th>Raw State</th><th>Managed State</th></tr></thead><tbody><tr><td>管理方式</td><td>开发者自行管理，需要手动序列化和反序列化</td><td>由 Flink Runtime 管理，自动存储和恢复数据</td></tr><tr><td>数据类型</td><td>仅支持 byte 数组</td><td>支持 value, list, map</td></tr><tr><td>适用场景</td><td>需要自定义 Operator</td><td>支持大部分计算场景</td></tr></tbody></table><p>Managed State 又分为 Keyed State 和 Operator State 两类，下面我们详细介绍这两类状态。</p><h4 id="Keyed-State"><a href="#Keyed-State" class="headerlink" title="Keyed State"></a>Keyed State</h4><p>Keyed State 只能用在 KeyedStream 上，也就是在使用前，要先对数据流进行 keyBy 操作。Keyed State 支持以下几种状态类型：</p><ul><li><p>ValueState<T>：保存一个值，可以通过 update() 方法更新，通过 value() 方法获取保存的值。</p></li><li><p>ListState<T>：保存一个 list，可以通过 add() 或 addAll() 方法向 list 中添加元素，也可以通过 update() 直接覆盖。使用 get() 方法获取整个列表。</p></li><li><p>ReducingState<T>：保存一个值，表示添加到状态所有值的聚合，使用 add() 方法添加元素，使用 get() 方法获取保存的值。</p></li><li><p>AggregatingState&lt;IN, OUT&gt;：保存一个值，与 ReducingState 不同的是，输入和输出的元素类型可以不同。</p></li><li><p>MapState&lt;UK, UV&gt;：保存一个 map，可以使用 put() 或 putAll() 添加键值对，使用 get() 获取值。</p></li></ul><p>在知道了各个类型的 Keyed State 怎么用之后，我们再来看如何创建一个 Keyed State。以 ValueState 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(</span><br><span class="line">                <span class="string">&quot;average&quot;</span>,</span><br><span class="line">                TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;Tuple2&lt;Long, Long&gt;&gt;() &#123;&#125;));</span><br><span class="line">ValueState&lt;Tuple2&lt;Long, Long&gt;&gt; sum = getRuntimeContext().getState(descriptor);</span><br></pre></td></tr></table></figure><p>要想创建一个 State，必须先创建一个 StateDescriptor，然后通过 RuntimeContext 来获取 State。每个 State 都对应一种 StateDescriptor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValueState&lt;T&gt; <span class="title function_">getState</span><span class="params">(ValueStateDescriptor&lt;T&gt;)</span></span><br><span class="line">ReducingState&lt;T&gt; <span class="title function_">getReducingState</span><span class="params">(ReducingStateDescriptor&lt;T&gt;)</span></span><br><span class="line">ListState&lt;T&gt; <span class="title function_">getListState</span><span class="params">(ListStateDescriptor&lt;T&gt;)</span></span><br><span class="line">AggregatingState&lt;IN, OUT&gt; <span class="title function_">getAggregatingState</span><span class="params">(AggregatingStateDescriptor&lt;IN, ACC, OUT&gt;)</span></span><br><span class="line">MapState&lt;UK, UV&gt; <span class="title function_">getMapState</span><span class="params">(MapStateDescriptor&lt;UK, UV&gt;)</span></span><br></pre></td></tr></table></figure><h4 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a>Operator State</h4><p>算子状态也称为非 keyed 状态，是绑定到一个并行算子实例的状态。State 需要支持重新分布。 最典型的是 Kafka Connector 中，维护了一个 topic partitions 和 offset 的 map 作为一个算子状态。</p><p>和 Keyed State 类似，想要创建一个 Operator State，同样也需要一个 StateDescriptor，同时，需要实现 CheckpointedFunction，它提供了两个方法，分别是在 checkpoint 时 调用的 snapshotState() 和 自定义函数初始化时调用的 initializeState()。</p><p>Talk is cheap, show me your code!</p><p>我们来看 Flink 官方文档提供的 Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferingSink</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SinkFunction</span>&lt;Tuple2&lt;String, Integer&gt;&gt;,</span><br><span class="line">                   CheckpointedFunction &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Tuple2&lt;String, Integer&gt;&gt; checkpointedState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tuple2&lt;String, Integer&gt;&gt; bufferedElements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferingSink</span><span class="params">(<span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">        <span class="built_in">this</span>.bufferedElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Tuple2&lt;String, Integer&gt; value, Context context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bufferedElements.add(value);</span><br><span class="line">        <span class="keyword">if</span> (bufferedElements.size() &gt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element: bufferedElements) &#123;</span><br><span class="line">                <span class="comment">// send it to the sink</span></span><br><span class="line">            &#125;</span><br><span class="line">            bufferedElements.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        checkpointedState.update(bufferedElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(</span><br><span class="line">                <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">                TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line"></span><br><span class="line">        checkpointedState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : checkpointedState.get()) &#123;</span><br><span class="line">                bufferedElements.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在 initializeState 方法中使用 getOperatorStateStore().getListState() 创建了一个 ListState，然后将数据缓存到这个 list 中，当缓存数据大小超过一个阈值时，再统一发送到下游。</p><p>这里还有一个方法值得注意，就是 isRestored()，它是用来判断当前任务是否是从故障中恢复的，如果是，我们需要执行故障恢复相关的逻辑。在这个例子中就是把 state 的数据恢复到本地的变量中。</p><h5 id="Broadcast-State"><a href="#Broadcast-State" class="headerlink" title="Broadcast State"></a>Broadcast State</h5><p>了解了如何创建和使用 Operator State 之后，我们再来看一种特殊的 Operator State —— Broadcast State。</p><p>Broadcast State 本身是类似于 Map 类型的格式，使用时需要指定 key 和 value 的类型。它的作用是将一条数据流的数据广播到下游算子的各个节点。</p><p>Broadcast State 的一个比较常见的作用就是大流关联小流。例如，我们有一个订单流，需要关联商品详情，这时可以把商品详情的流作为 broadcast 流进行广播，这样在每个 TaskManager 中会有一份商品详情数据，订单流就可以直接查询 broadcast 的数据，不需要再访问 MySQL 数据库来做查询操作。</p><p>那么具体要怎么实现呢？其实也很简单，可以看下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapStateDescriptor&lt;String, Product&gt; productStateDescriptor =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MapStateDescriptor</span>&lt;&gt;(<span class="string">&quot;productBroadcastState&quot;</span>, String.class, Product.class);</span><br><span class="line"></span><br><span class="line">BroadcastStream&lt;Product&gt; broadcastProductStream = productStream.broadcast(productStateDescriptor);</span><br><span class="line"></span><br><span class="line">BroadcastConnectedStream&lt;Order, Product&gt; connectedStreams = orderStream.connect(broadcastProductStream);</span><br></pre></td></tr></table></figure><p>拿到 BroadcastConnectedStream 之后，我们就可以调用 process 方法进行处理了。完整的代码我放到 <a href="https://github.com/Jackeyzhe/flink-training/blob/feature/wz-demo/common/src/main/java/org/apache/flink/training/examples/state/BroadcastStateDemo.java">GitHub</a> 上了。感兴趣的可以查看。</p><p>在使用 Broadcast State 的时需要注意，目前 RocksDB 不支持保存 Broadcast State，因此，广播流吞吐量必须要小，并且 Flink 任务要预留足够的内存。</p><p>聊完了 Broadcast State，我们再来看看 Operator State 是如何进行重新分布的。正常 Operator State 支持两种重新分布的方式，按照不同的方式，我们可以划分为 ListState 和 UnionListState。</p><ul><li><p>ListState：所有的 element 均匀分布到 task 上</p></li><li><p>UnionListState：每个 element 都要在所有的 task 上</p></li></ul><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1755107607/Blog/flink/4/OperatorStateResize.png" alt="OperatorStateResize"></p><p>Broadcast State 由于本身就是广播状态，因此重新分布后仍然是需要进行广播的。</p><h4 id="状态有效期"><a href="#状态有效期" class="headerlink" title="状态有效期"></a>状态有效期</h4><p>最后再来扩展一个知识点，就是状态的有效期。在 Flink 中，只有 Keyed State 支持有效期。具体使用方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">    .newBuilder(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;text state&quot;</span>, String.class);</span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure><p>这里有三个属性，我们分别来解释一下，首先第一个是过期时间，在调用 newBuilder 时就要传入。</p><p>第二个是 UpdateType，也就是更新策略，默认是 OnCreateAndWrite，表示在创建和写入时更新，也可以设置为 OnReadAndWrite，表示在读取和写入时更新。</p><p>第三个是可见性，默认是 NeverReturnExpired，即不返回过期数据，也可以设置为 ReturnExpiredIfNotCleanedUp，表示会返回过期但未被清理的数据。</p><p>状态数据清理策略也分为两种：一种是做全量快照时进行清理，创建 ttl 时调用 cleanupFullSnapshot() 方法即可。</p><p>另一种是增量数据清理，在访问或处理状态时，状态后端保留一个所有状态的惰性迭代器，每次清理时选择已经过期的数据进行清理。设置方法时在创建 ttl 时调用 cleanupIncrementally(10, true) ，可以看到它提供两个参数，第一个参数是设置每次检查的条数，默认是5。第二个参数是是否在处理每条记录时都触发清理，默认是 false。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们来总结一下，本文我们主要介绍了 Flink 的状态及应用，首先介绍有状态计算的概念。接着重点学习了 Keyed State 和 Operator State。我们通过一个表格来进行总结。</p><table><thead><tr><th></th><th>Keyed State</th><th>Operator State</th></tr></thead><tbody><tr><td>使用算子类型</td><td>只能被用于 KeyedStream 中的Operator 上</td><td>可以被用于所有 Operator</td></tr><tr><td>状态分配</td><td>每个 Key 对应一个状态，单个 Operator 中可以包含多个 Key</td><td>单个 Operator 对应一个状态</td></tr><tr><td>创建和访问方式</td><td>重写 RichFunction，通过访问 RuntimeContext 对象获取</td><td>实现 CheckpointedFunction 或 ListCheckpointed 接口</td></tr><tr><td>横向拓展</td><td>状态随着 Key 自动在多个算子 Task 上迁移</td><td>有多种重新分配的方式：均匀分布。将所有状态合并再分发到每个实例上</td></tr><tr><td>支持数据类型</td><td>ValueState, ListState, ReducingState, AggregatingState, MapState</td><td>ListState, UnionListState, Broadcast State</td></tr></tbody></table><p>最后，我们又介绍了状态有效期的定义和使用方法。有了状态之后，Flink 就可以为我们提供非常强大的容错能力了，具体怎么做的我们后面再聊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flink 被广泛应用的原因，除了我们前面提到的对时间以及窗口的应用之外，另一点就是它强大的容错机制，以及对 Exactly Once 的支持。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：多流 Join</title>
    <link href="https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E6%B5%81join/"/>
    <id>https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E6%B5%81join/</id>
    <published>2025-07-18T17:36:58.000Z</published>
    <updated>2025-08-02T17:22:41.499Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经了解了 Flink 几个核心概念，分别是时间、Watermark 已经窗口。今天我们来一起了解下 Flink 是怎么进行多个流的 Join 的。<span id="more"></span></p><p>我们今天从两个流的 Join 来入手，扩展到多个流也是一样的道理。Flink 中的 Join 可以分为两种：Window Join 和 Interval Join。</p><h3 id="Window-Join"><a href="#Window-Join" class="headerlink" title="Window Join"></a>Window Join</h3><p>Window Join 是将两个流中在相同窗口中且有相同 key 的元素进行关联。关联后，可以使用 JoinFunction 和 FlatJoinFunction 进行处理。Window Join 可以根据窗口类型分为三种：Tumbling Window Join、Sliding Window Join 和 Session Window Join。</p><h4 id="Tumbling-Window-Join"><a href="#Tumbling-Window-Join" class="headerlink" title="Tumbling Window Join"></a>Tumbling Window Join</h4><p>首先来看Tumbling Window Join，其实就是对应的使用滚动窗口进行 Join。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1754148421/Blog/flink/3/TumblingWindowJoin.png" alt="TumblingWindowJoin"> </p><p>具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; result = source1.join(source2)</span><br><span class="line">        .where(record -&gt; record.f0)</span><br><span class="line">        .equalTo(record -&gt; record.f0)</span><br><span class="line">        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">2L</span>)))</span><br><span class="line">        .apply(<span class="keyword">new</span> <span class="title class_">JoinFunction</span>&lt;Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple2&lt;String, Double&gt; <span class="title function_">join</span><span class="params">(Tuple2&lt;String, Double&gt; record1, Tuple2&lt;String, Double&gt; record2)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(record1.f0, record1.f1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>其中 source1 和 source2 分别代表两个流，where 为 source1 的 join key 提取方法，equalTo 为 source2 的 join key 提取方法，最后，join 好之后的数据通过 JoinFunction 来处理。</p><h4 id="Sliding-Window-Join"><a href="#Sliding-Window-Join" class="headerlink" title="Sliding Window Join"></a>Sliding Window Join</h4><p>Sliding Window Join 和 Tumbling Window Join 的用法基本一致，只是将窗口指定为滑动窗口。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1754148862/Blog/flink/3/SlidingWindowJoin.png" alt="SlidingWindowJoin"></p><h4 id="Session-Window-Join"><a href="#Session-Window-Join" class="headerlink" title="Session Window Join"></a>Session Window Join</h4><p>Session Window Join 也类似，只是指定的窗口不同，具体的处理流程都是一样的，这里也不过多解释。</p><h3 id="Interval-Join"><a href="#Interval-Join" class="headerlink" title="Interval Join"></a>Interval Join</h3><p>Interval Join 是将两个流中 key 相同，且一个流的 timestamp 处于另一个流的 timestamp 上下波动范围内。</p><p>假设我们有两个流 a 和 b，Interval Join可以表达为<code>b.timestamp ∈ [a.timestamp + lowerBound; a.timestamp + upperBound]</code> 或 <code>a.timestamp + lowerBound &lt;= b.timestamp &lt;= a.timestamp + upperBound</code>。</p><p>需要注意的是，目前 Interval Join 仅支持 event time。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1754153595/Blog/flink/3/IntervalJoin.png" alt="IntervalJoin"></p><p>它的使用方法也很简单，只需要定义上下偏移量以及处理函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; intervalJoinResult = source1.keyBy(record -&gt; record.f0)</span><br><span class="line">        .intervalJoin(source2.keyBy(record -&gt; record.f0))</span><br><span class="line">        .between(Time.seconds(-<span class="number">2</span>), Time.seconds(<span class="number">2</span>))</span><br><span class="line">        .process(<span class="keyword">new</span> <span class="title class_">ProcessJoinFunction</span>&lt;Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Tuple2&lt;String, Double&gt; record1, Tuple2&lt;String, Double&gt; record2, ProcessJoinFunction&lt;Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;&gt;.Context context, Collector&lt;Tuple2&lt;String, Double&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                out.collect(Tuple2.of(record1.f0, record1.f1 + record2.f1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="CoGroup"><a href="#CoGroup" class="headerlink" title="CoGroup"></a>CoGroup</h3><p>前面介绍的两种 Join 都是 inner join，那么 Flink 有没有办法支持 left join 呢？答案是肯定的，我们可以使用 coGroup 来实现。</p><p>coGroup 的通用用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream.coGroup(otherStream)</span><br><span class="line">.where(&lt;KeySelector&gt;)</span><br><span class="line">.equalTo(&lt;KeySelector&gt;)</span><br><span class="line">.window(&lt;WindowAssigner&gt;)</span><br><span class="line">.apply(&lt;CoGroupFunction&gt;);</span><br></pre></td></tr></table></figure><p>我们通过自定义 CoGroupFunction 来实现 left join。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LeftJoinFunction</span> <span class="keyword">implements</span> <span class="title class_">CoGroupFunction</span>&lt;Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;, Tuple2&lt;String, Double&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coGroup</span><span class="params">(Iterable&lt;Tuple2&lt;String, Double&gt;&gt; iterable1, Iterable&lt;Tuple2&lt;String, Double&gt;&gt; iterable2, Collector&lt;Tuple2&lt;String, Double&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Double&gt; record1 : iterable1) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Double&gt; record2 : iterable2) &#123;</span><br><span class="line">                match = <span class="literal">true</span>;</span><br><span class="line">                collector.collect(Tuple2.of(record1.f0, record1.f1 + record2.f1));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有join的元素 key:&quot;</span> + record1.f0);</span><br><span class="line">                collector.collect(Tuple2.of(record1.f0, record1.f1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 coGroupFunction 中，需要实现 coGroup 方法，方法的参数包括两个输入流的 Iterable 和输出的 collector。如果第二个流中没有匹配的元素，那么就直接输出第一个流的元素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后来总结一下，Flink 中有两种 Join 方法，分别为 Window Join 和 Interval Join，Window Join 是依赖窗口来执行，对窗口内的元素进行 join，Interval Join 不依赖窗口，是根据 event time 的范围来进行 join。最后还介绍了 CoGroup，我们可以使用 CoGroup 来实现 left join 和 right join。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面我们已经了解了 Flink 几个核心概念，分别是时间、Watermark 已经窗口。今天我们来一起了解下 Flink 是怎么进行多个流的 Join 的。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：窗口</title>
    <link href="https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AA%97%E5%8F%A3/"/>
    <id>https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AA%97%E5%8F%A3/</id>
    <published>2025-07-18T17:23:29.000Z</published>
    <updated>2025-07-18T17:26:38.649Z</updated>
    
    <content type="html"><![CDATA[<p>在前文中，我们已经了解了 Flink 时间和 Watermark 两个概念，今天就来聊一下 Flink 实时数据处理的另一个核心概念：窗口。<span id="more"></span></p><p>所谓窗口，可以理解为是对数据流中的一段数据进行处理的方法。那我们为什么需要窗口呢？在生产环境中，数据流中的数据往往是源源不断的，如果我们想要获取一段时间内数据的一些统计指标（最大值/最小值/平均值），这时就需要利用窗口来将数据收集起来，然后再进行计算。</p><p>如果按照处理的数据流的类型来划分，Flink 中的窗口可以分为 Keyed Window 和 Non-Keyed Window，其中 Keyed Window 是用来处理按照 key 分片之后的数据流，也就是需要先调用 keyBy 方法，再调用 window 方法。而 Non-Keyed Window 处理的则是未按照 key 分片的数据流，在使用的时候直接调用 windowAll 方法。</p><p>在官方文档中，列举了两种窗口的使用方法。</p><p><strong>Keyed Window</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">       .keyBy(...)               &lt;-  仅 keyed 窗口需要</span><br><span class="line">       .window(...)              &lt;-  必填项：<span class="string">&quot;assigner&quot;</span></span><br><span class="line">      [.trigger(...)]            &lt;-  可选项：<span class="string">&quot;trigger&quot;</span> (省略则使用默认 trigger)</span><br><span class="line">      [.evictor(...)]            &lt;-  可选项：<span class="string">&quot;evictor&quot;</span> (省略则不使用 evictor)</span><br><span class="line">      [.allowedLateness(...)]    &lt;-  可选项：<span class="string">&quot;lateness&quot;</span> (省略则为 <span class="number">0</span>)</span><br><span class="line">      [.sideOutputLateData(...)] &lt;-  可选项：<span class="string">&quot;output tag&quot;</span> (省略则不对迟到数据使用 side output)</span><br><span class="line">       .reduce/aggregate/apply()      &lt;-  必填项：<span class="string">&quot;function&quot;</span></span><br><span class="line">      [.getSideOutput(...)]      &lt;-  可选项：<span class="string">&quot;output tag&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Non-Keyed Window</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">       .windowAll(...)           &lt;-  必填项：<span class="string">&quot;assigner&quot;</span></span><br><span class="line">      [.trigger(...)]            &lt;-  可选项：<span class="string">&quot;trigger&quot;</span> (<span class="keyword">else</span> <span class="keyword">default</span> trigger)</span><br><span class="line">      [.evictor(...)]            &lt;-  可选项：<span class="string">&quot;evictor&quot;</span> (<span class="keyword">else</span> no evictor)</span><br><span class="line">      [.allowedLateness(...)]    &lt;-  可选项：<span class="string">&quot;lateness&quot;</span> (<span class="keyword">else</span> zero)</span><br><span class="line">      [.sideOutputLateData(...)] &lt;-  可选项：<span class="string">&quot;output tag&quot;</span> (<span class="keyword">else</span> no side output <span class="keyword">for</span> late data)</span><br><span class="line">       .reduce/aggregate/apply()      &lt;-  必填项：<span class="string">&quot;function&quot;</span></span><br><span class="line">      [.getSideOutput(...)]      &lt;-  可选项：<span class="string">&quot;output tag&quot;</span></span><br></pre></td></tr></table></figure><h3 id="窗口分类"><a href="#窗口分类" class="headerlink" title="窗口分类"></a>窗口分类</h3><p>在上面的示例中，调用 window 和 windowAll 方法时，需要传入 assigner 参数，Window Assigner 是用来定义如何将数据流中的元素划分到各个窗口中。</p><p>下面我们再对窗口进行一次分类，首先是根据划分依据，可以分为 time window 和 count window，time window 是根据处理数据的时间来划分，count window 则是根据处理数据的数量来划分。接着，我们再根据划分规则来分类，这里又可以将窗口分为滚动窗口（Tumbling Windows）、滑动窗口（Sliding Windows）、会话窗口（Session Windows）和全局窗口（Global Windows），需要注意的是，后面两种窗口不支持 count window。我们用一张图来表示窗口的分类会更加清晰。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1752334267/Blog/flink/2/windows_1.png" alt="窗口分类"></p><p>我们在日常数据处理中，最常用的就是时间窗口，接下来就来详细了解下时间窗口的四种类型。</p><h4 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h4><p>滑动窗口是以一个固定的步长不断向前滑动的窗口，滑动过程中，窗口的大小是保持不变的。在滑动窗口中，一个元素是可以被多个窗口计算的。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1752599153/Blog/flink/2/sliding_window.png" alt="sliding_window"></p><p>在代码中，可以通过 SlidingEventTimeWindows 类来定义滑动窗口，具体使用方法可以参考下面这个简单的 demo（这里多说一句，旧版本 Flink 传的是参数是 Time，新版本传的是 Duration）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动 event-time 窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingEventTimeWindows.of(Duration.ofSeconds(<span class="number">10</span>), Duration.ofSeconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动 processing-time 窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Duration.ofSeconds(<span class="number">10</span>), Duration.ofSeconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动 processing-time 窗口，偏移量为 -8 小时</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Duration.ofHours(<span class="number">12</span>), Duration.ofHours(<span class="number">1</span>), Duration.ofHours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不传 offset 参数的话，窗口开始时间会和 Linux 的 epoch 对齐，如果想要一些偏移量的话，就可以通过 offset 参数来控制（第二种方法）。在 demo 中，偏移量设置为 -8 小时，也就是使用东 8 区时间。</p><h4 id="Tumbling-Windows"><a href="#Tumbling-Windows" class="headerlink" title="Tumbling Windows"></a>Tumbling Windows</h4><p>了解了滑动窗口之后，我们再来看滚动窗口。滚动窗口可以认为是一种特殊的滑动窗口（Window Size = Window Slide）。滚动窗口之间是没有重叠的，也就是说，每个元素只能落到一个窗口中。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1752600673/Blog/flink/2/Tumbling_Window.png" alt="tumbling_window"></p><p>在代码中通过使用 TumblingEventTimeWindows 来定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动 event-time 窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Duration.ofSeconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动 processing-time 窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingProcessingTimeWindows.of(Duration.ofSeconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为一天的滚动 event-time 窗口， 偏移量为 -8 小时。</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Duration.ofDays(<span class="number">1</span>), Duration.ofHours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure><h4 id="Session-Windows"><a href="#Session-Windows" class="headerlink" title="Session Windows"></a>Session Windows</h4><p>会话窗口和前两种不同，它的窗口大小是不固定的，也没有固定的开始和结束时间。当一个窗口超过 Seesion gap 没有收到数据之后，窗口就会关闭。Flink 也支持动态定义判断会话窗口不活跃的条件。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1752682681/Blog/flink/2/session_window.png" alt="session_window"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了固定间隔的 event-time 会话窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withGap(Duration.ofMinutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了动态间隔的 event-time 会话窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 决定并返回会话间隔</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了固定间隔的 processing-time session 窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withGap(Duration.ofMinutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了动态间隔的 processing-time 会话窗口</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 决定并返回会话间隔</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure><h4 id="Global-Windows"><a href="#Global-Windows" class="headerlink" title="Global Windows"></a>Global Windows</h4><p>最后是全局窗口，它将所有的key都写到一个窗口，并且必须要指定 trigger 才能触发窗口的计算。</p><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>现在我们已经知道如何划分窗口，或者说如何把指定元素放入对应的窗口中了。接下来的问题就是窗口中的数据要怎么处理。这就是窗口函数的职责了。Flink 支持三种窗口函数，分别是：ReduceFunction、AggregateFunction 和 ProcessWindowFunction。</p><h4 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h4><p>ReduceFunction 定义了如何把两条数据合并为一条。例如最常见的对 key 进行求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(<span class="keyword">new</span> <span class="title class_">ReduceFunction</span>&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">      <span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title function_">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(v1.f0, v1.f1 + v2.f1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>窗口输出的数据就是将多条相同 key 的数据求和后的数据。</p><h4 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h4><p>ReduceFunction 其实是一种特殊的 AggregateFunction，AggregateFunction 的定义更加宽泛。它接收三个类型：IN（输入数据的类型）、ACC（累加器的类型）、OUT（输出数据的类型）。同时定义了四个方法：createAccumulator（创建一个累加器）、add（将一条数据加进累加器）、getResult（获取累加器结果）、merge（将两个累加器合并）</p><p>下面这个例子展示了如何对输入数据进行求平均值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AverageAggregate</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Double <span class="title function_">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .aggregate(<span class="keyword">new</span> <span class="title class_">AverageAggregate</span>());</span><br></pre></td></tr></table></figure><h4 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h4><p>ProcessWindowFunction 执行效率不如前两者，因为它要获取窗口内所有的数据进行计算。但它也有另外两个窗口没有的能力，那就是在 ProcessWindowFunction 中可以通过 Context 获取到时间和状态信息。这样的能力带来的代价是大量的资源消耗，因此，为了减少不必要的资源消耗，我们通常将 ProcessWindowFunction 与 ReduceFunction 或 AggregateFunction 配合使用。我们来看一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .window(&lt;window assigner&gt;)</span><br><span class="line">  .reduce(<span class="keyword">new</span> <span class="title class_">MyReduceFunction</span>(), <span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;SensorReading&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SensorReading <span class="title function_">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> r1.value() &gt; r2.value() ? r2 : r1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                    Context context,</span></span><br><span class="line"><span class="params">                    Iterable&lt;SensorReading&gt; minReadings,</span></span><br><span class="line"><span class="params">                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out)</span> &#123;</span><br><span class="line">      <span class="type">SensorReading</span> <span class="variable">min</span> <span class="operator">=</span> minReadings.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;Long, SensorReading&gt;(context.window().getStart(), min));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们返回了窗口中最小的元素和窗口的开始时间。因为我们先做了聚合，所以在 ProcessFunction 中就不用把所有的数据都存储在 State 中，而是只存储聚合后的数据即可。</p><h3 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h3><p>Trigger 决定何时触发窗口计算，每个 Window Assigner 都有一个默认的 trigger。当然，Flink 也提供自定义 trigger，自定义 trigger 只需要实现 Trigger 接口，并且在 .trigger() 方法中调用即可（在文章开头的示例中提到过）。</p><p>Trigger 接口提供了 5 个方法，分别是：</p><ul><li><p>onElement() 方法在接收到元素时调用</p></li><li><p>onProcessingTime() 方法是在一个基于 ProcessTime 的 timer 触发时调用</p></li><li><p>onEventTime() 方法是在一个基于 EventTime 的 timer 触发时调用</p></li><li><p>onMerge() 方法在多个窗口合并时调用</p></li><li><p>clear() 方法是在窗口被移除时调用</p></li></ul><p>前三个方法都会返回一个 TriggerResult，而这个 TriggerResult 的值就决定了窗口是否触发。TriggerResult 的值有以下四种：</p><ul><li><p>CONTINUE：什么也不做</p></li><li><p>FIRE_AND_PURGE：触发计算并清空窗口内的元素</p></li><li><p>FIRE：只触发计算，不清空窗口内元素</p></li><li><p>PURGE：清空窗口内元素</p></li></ul><p>Flink 内置了多个 trigger，常见的有 EventTimeTrigger、ProcessingTimeTrigger、CountTrigger 和 PurgingTrigger。</p><h3 id="Evictors"><a href="#Evictors" class="headerlink" title="Evictors"></a>Evictors</h3><p>Evictor 可以用于在 trigger 触发后、调用窗口函数之前或之后删除窗口内的元素。Evictor 接口提供了两个方法：</p><ul><li><p>evictBefore() 方法是在调用窗口函数之前调用</p></li><li><p>evictAfter() 方法是在调用窗口函数之后调用</p></li></ul><p>Flink 内置了三种 Evictor：</p><ul><li><p>CountEvictor：记录用户设置的最大元素数量，当窗口内元素数量大于最大元素数量时，删除开头的元素</p></li><li><p>DeltaEvictor：用户需要设置计算差值的方法，evictor 会计算最后一个元素与窗口内每个元素的差值差值，并将大于用户设置的 threshold 的元素删除</p></li><li><p>TimeEvictor：用户需要指定窗口大小 windowSize，evictor 会计算窗口内元素最大的时间戳 maxTimestamp，将时间戳小于等于 maxTimestamp - windowSize 的元素清除</p></li></ul><p>关于 Trigger 和 Evictor，只看概念可能还比较迷惑。我们来看一个具体的例子：假设我们需要一个实时监控系统，当连续收到 5 个大于阈值的数据时，发送告警。最终窗口中只保留 10 条数据。</p><p>trigger 的实现应该是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TriggerResult <span class="title function_">onElement</span><span class="params">(Tuple2&lt;String, Double&gt; item, <span class="type">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ValueState&lt;Integer&gt; state = triggerContext.getPartitionedState(<span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(stateName, Integer.class, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item.f1 &gt; threshold) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> state.value() + <span class="number">1</span>;</span><br><span class="line">        state.update(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= countThreshold) &#123;</span><br><span class="line">            state.clear();</span><br><span class="line">            <span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evictor 的实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictAfter</span><span class="params">(Iterable&lt;TimestampedValue&lt;Tuple2&lt;String, Double&gt;&gt;&gt; elements, <span class="type">int</span> size, TimeWindow timeWindow, EvictorContext evictorContext)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;TimestampedValue&lt;Tuple2&lt;String, Double&gt;&gt;&gt; elementList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    elements.forEach(elementList::add);</span><br><span class="line">    <span class="type">int</span> <span class="variable">toEvict</span> <span class="operator">=</span> size - maxSize;</span><br><span class="line">    List&lt;TimestampedValue&lt;Tuple2&lt;String, Double&gt;&gt;&gt; toRemove = elementList.subList(maxSize, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 通过迭代器删除需要移除的元素（关键：遍历原始迭代器，匹配并删除）</span></span><br><span class="line">    Iterator&lt;TimestampedValue&lt;Tuple2&lt;String, Double&gt;&gt;&gt; iterator = elements.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        TimestampedValue&lt;Tuple2&lt;String, Double&gt;&gt; element = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (toRemove.contains(element)) &#123; <span class="comment">// 匹配需要删除的元素</span></span><br><span class="line">            iterator.remove(); <span class="comment">// 实际删除</span></span><br><span class="line">            toEvict--;</span><br><span class="line">            <span class="keyword">if</span> (toEvict &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Evictor finished: 保留了 &quot;</span> + maxSize + <span class="string">&quot; 个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码我放到 <a href="https://github.com/Jackeyzhe/flink-training/blob/feature/wz-demo/common/src/main/java/org/apache/flink/training/examples/trigger/TriggerAndEvictorDemo.java">GitHub</a> 了，感兴趣的可以看一下。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结一下，今天我们了解了 Flink 中窗口相关的概念，首先是窗口分类，然后是 Window Assginer（分别介绍了滑动窗口、滚动窗口、会话窗口和全局窗口）。接着又了解窗口处理函数，即怎么计算窗口中的数据。最后学习的 trigger 和 evictor 的作用和用法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文中，我们已经了解了 Flink 时间和 Watermark 两个概念，今天就来聊一下 Flink 实时数据处理的另一个核心概念：窗口。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：时间与Watermark</title>
    <link href="https://jackeyzhe.github.io/2025/06/30/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B8%8EWatermark/"/>
    <id>https://jackeyzhe.github.io/2025/06/30/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B8%8EWatermark/</id>
    <published>2025-06-30T14:58:16.000Z</published>
    <updated>2025-07-15T15:23:49.476Z</updated>
    
    <content type="html"><![CDATA[<p>在前文中，我学习 Flink 的整体架构，接下来的几篇文章，我将重点学习一下 Flink 的几个核心概念。包括时间属性、Watermark、窗口、状态以及容错机制。今天就来学习时间属性和 Watermark。<span id="more"></span></p><h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p>首先来学习 Flink 的时间属性，作为流处理引擎，时间是实时数据处理的重要依赖，特别是在做时序分析或者特定时间段数据处理时，时间的概念更显得尤为重要。</p><p>Flink 中支持三种时间属性，分别是：</p><ul><li><p>EventTime：事件时间，即为事件产生的时间。</p></li><li><p>ProcessTime：处理时间，Flink 算子处理事件的时间。</p></li><li><p>IngestionTime：摄入时间，Flink 读取事件的时间。</p></li></ul><p>这样描述可能比较抽象，我们通过一张图来看一下。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1750094745/Blog/flink/1/flink_time.png" alt="FlinkTime"></p><p>从上图中可以看出，在时间产生/存储时，记录一个设备时间，就是 Event Time。当 Flink 的 DataSource 读取到事件时，这时再记录一个时间，这就是 Ingestion Time。在 Flink 程序中，每个算子处理事件时，又会记录一个时间，这个时间就是 Process Time。</p><h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><p>介绍完了时间概念，再来看下 Watermark 的概念。它是 Flink 处理迟到事件的妙招。</p><p>Watermark 本身也属于一种特殊的事件，它由 Source 生成，同时携带由 Timestamp，并且会跟随正常的事件一起在 Flink 算子之间流转。Watermark 的作用是定义何时停止等待较早的事件。这么介绍可能比较抽象，下面我们通过一些具体的例子来进行更进一步的说明。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1751033706/Blog/flink/1/watermark.png" alt="watermark"></p><p>上图代表的是一段乱序的事件数据流。假设我们定义 maxOutOfOrderness 为4，也就是容忍最大迟到时间为4（这里不带具体时间单位，可能是4秒也可能是4分钟）。当我们收到时间戳为7的事件时，就会生成一个时间为3的 Watermark。这代表着3之前的数据都已就绪。如果此时再有小于3的数据，我们认为它是迟到数据。</p><p>而对于迟到的数据，通常有三种处理方法：</p><ul><li><p>重新开启已经关闭的窗口，重新计算并修正结果</p></li><li><p>将迟到事件使用旁路输出收集起来单独处理</p></li><li><p>将迟到事件视为错误消息丢弃</p></li></ul><p>在 Flink 中 Watermark 本身是没有意义的，它的主要作用是作为窗口的触发条件。窗口可以认为是一个时间段，它有开始时间和结束时间。在窗口内可以计算一批事件的统计结果。关于窗口，我们后面再做详细介绍。</p><p>那么 Watermark 是如何触发窗口的呢？答案是必须要满足以下两个条件：</p><ol><li><p>Watermark 的时间戳 &gt;= 窗口的 end_time</p></li><li><p>窗口中有数据</p></li></ol><p>从概念上看还是比较抽象，我们还用上面的数据流作为例子，Watermark 设置为最大时间减 4，假设我们设置10秒一个窗口。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">SingleOutputStreamOperator&lt;Event&gt; withTimestampsAndWatermarks = source</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.forGenerator(ctx -&gt; <span class="keyword">new</span> <span class="title class_">CustomWatermarkGenerator</span>())</span><br><span class="line">                                .withTimestampAssigner(((event, l) -&gt; event.timestamp))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">OutputTag&lt;Event&gt; lateTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;Event&gt;(<span class="string">&quot;late-tag&quot;</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; windowResult = withTimestampsAndWatermarks</span><br><span class="line">        .keyBy(event -&gt; event.num)</span><br><span class="line">        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">        .sideOutputLateData(lateTag)</span><br><span class="line">        .process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Event, String, Long, TimeWindow&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Long key, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">             <span class="comment">// 一些逻辑处理</span></span><br><span class="line">             out.collect(result);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理迟到数据</span></span><br><span class="line">DataStream&lt;Event&gt; lateStream = windowResult.getSideOutput(lateTag);</span><br><span class="line">lateStream.process(<span class="keyword">new</span> <span class="title class_">ProcessFunction</span>&lt;Event, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Event event, Context ctx, Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">        out.collect(<span class="string">&quot;迟到事件: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).print();</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event, <span class="type">long</span> l, WatermarkOutput watermarkOutput)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">eventTime</span> <span class="operator">=</span> event.timestamp;</span><br><span class="line">    <span class="comment">// 使用CAS确保线程安全</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> currentMaxTime.get();</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= current) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentMaxTime.compareAndSet(current, eventTime)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput watermarkOutput)</span> &#123;</span><br><span class="line">    watermarkOutput.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(currentMaxTime.get() - timeDiff));</span><br><span class="line">&#125;</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Jackeyzhe/flink-training/blob/feature/wz-demo/common/src/main/java/org/apache/flink/training/examples/watermark/WatermarkDemo.java">完整代码我放在 github 上了</a></p><p>当我们输入测试数据时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>,<span class="number">1750867204000</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1750867202000</span></span><br><span class="line"><span class="number">7</span>,<span class="number">1750867207000</span></span><br><span class="line"><span class="number">10</span>,<span class="number">1750867210000</span></span><br><span class="line"><span class="number">9</span>,<span class="number">1750867209000</span></span><br><span class="line"><span class="number">15</span>,<span class="number">1750867215000</span></span><br><span class="line"><span class="number">12</span>,<span class="number">1750867212000</span></span><br><span class="line"><span class="number">13</span>,<span class="number">1750867213000</span></span><br><span class="line"><span class="number">25</span>,<span class="number">1750867225000</span></span><br><span class="line"><span class="number">14</span>,<span class="number">1750867214000</span></span><br><span class="line"><span class="number">35</span>,<span class="number">1750867235000</span></span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1751035105/Blog/flink/1/%E6%88%AA%E5%B1%8F2025-06-27_22.35.50.png" alt="print"></p><p>通过输出的日志，我们可以看出，当watermark推进到大于等于时间窗口的结束时间时，窗口就会完成计算并关闭。而对于迟到的数据，我们可以通过侧输出流单独处理，也可以通过设置<code>allowedLateness</code>，使窗口重新打开。</p><h3 id="生成-Watermark"><a href="#生成-Watermark" class="headerlink" title="生成 Watermark"></a>生成 Watermark</h3><p>了解了 Watermark 的原理之后，我们再来看一下如何生成 Watermark。在 Flink 中，需要使用 WatermarkStrategy 来定义如何生成时间戳和 watermark。WatermarkStrategy 继承了 TimestampAssignerSupplier 和 WatermarkGeneratorSupplier 两个接口，其中 TimestampAssignerSupplier 定义了抽取 EventTime 的方法，而 WatermarkGeneratorSupplier 则是定义了如何生成 Watermark 的方法。</p><h4 id="Flink-内置的-Watermark-生成器"><a href="#Flink-内置的-Watermark-生成器" class="headerlink" title="Flink 内置的 Watermark 生成器"></a>Flink 内置的 Watermark 生成器</h4><p>Flink 中内置了两个 watermark 生成器。分别是 AscendingTimestampsWatermarks 和 BoundedOutOfOrdernessWatermarks。</p><p>我们先来看 BoundedOutOfOrdernessWatermarks，它定义了一个 watermark 滞后于最大事件时间一个固定值的 watermark 生成器。在使用时，可以给定一个时间，这样 Flink 就会 根据最大的 eventTime 来周期性的生成 watermark，例如，我们前面定义的 watermark 滞后4秒，就可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>AscendingTimestampsWatermarks 是单调递增时间分配器，也就是只处理有序的数据，它继承了 BoundedOutOfOrdernessWatermarks，并且最大容忍时间为0。在使用时，可以直接通过以下方法生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forMonotonousTimestamps();</span><br></pre></td></tr></table></figure><h4 id="自定义-WatermarkGenerator"><a href="#自定义-WatermarkGenerator" class="headerlink" title="自定义 WatermarkGenerator"></a>自定义 WatermarkGenerator</h4><p>除了上面两个内置的 WatermarkGenerator 外，我们还可以自定义，实现起来也比较简单。只需要实现 WatermarkGenerator 接口并重写 onEvent 和 onPeriodicEmit 两个方法即可。onEvent 是每个事件到来时调用一次，可以用来记录最大事件时间。onPeriodicEmit 则是周期性调用，可以生成 watermark。在前面的例子中，我使用的 CustomWatermarkGenerator 就是自定义的 watermark，对应的实现也在前文中贴了。</p><h3 id="如何处理空闲数据源"><a href="#如何处理空闲数据源" class="headerlink" title="如何处理空闲数据源"></a>如何处理空闲数据源</h3><p>最后，再补充一个与 watermark 相关的比较重要的特性。在 Flink 中，会有一些算子有多个输入源。这时，这个算子的 watermark 是以它收到的数据源中最小的 eventTime 来计算的。直接看官网的例子：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1752592909/Blog/flink/1/parallel_streams_watermarks.png" alt="parallel_streams_watermarks"></p><p>那么这里就存在一个问题：如果一个输入源数据量很少，很久才发一条消息，而另一个数据源发了很多消息，那么就会在下游算子中积累很多消息等待处理，这对于整个系统的稳定性造成了很大的风险。</p><p>那这种情况有办法处理吗？答案是肯定的，Flink 提供了 withIdleness 方法，它可以用来检测空闲数据源，如果超过一定时间没有数据到来，Flink 认为这个数据源属于空闲数据源，这时就不会再阻塞下游算子触发窗口。达到定期处理数据的目的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们先了解了 Flink 中时间的概念，EventTime 是事件产生的时间，通常由上游数据源生成，ProcessTime 是处理时间，通常由处理算子本身生成，IngestionTime是摄入时间，通常由 Flink 的 Source 生成。</p><p>接着我们由了解了 Flink 的 watermark，它是窗口触发的条件，在处理迟到数据时发挥着重要的作用。我们可以定义可以容忍的最大迟到时间，这样当遇到乱序数据时也可以得到正确的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文中，我学习 Flink 的整体架构，接下来的几篇文章，我将重点学习一下 Flink 的几个核心概念。包括时间属性、Watermark、窗口、状态以及容错机制。今天就来学习时间属性和 Watermark。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：整体架构</title>
    <link href="https://jackeyzhe.github.io/2025/06/09/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://jackeyzhe.github.io/2025/06/09/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2025-06-09T03:31:31.000Z</published>
    <updated>2025-06-11T13:14:07.240Z</updated>
    
    <content type="html"><![CDATA[<p>开一个新坑，系统性的学习下 Flink，计划从整体架构到核心概念再到调优方法，最后是相关源码的阅读。<span id="more"></span></p><!-- more --><p>今天就来学习 Flink 整体架构，我们先看官网的架构图</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1647276646/Blog/flink/0/flink0_0.png" alt="Flink Architecture"></p><p>图中包含三部分，分别是 Client、JobManager 和 TaskManager。其中 Client 并不属于 Flink 集群，它主要用来把用户编写的程序翻译成 StreamGraph 然后优化成 JobGraph，再将 JobGraph 提交到 Flink 集群执行。</p><h3 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a>JobManager</h3><p>Flink 集群的 JobManager 是用来接收 Client 提交的任务，并且分发给 TaskManager 去执行。此外，JobManager 还有一些其他的职责，例如任务调度，协调 checkpoint 和协调从失败中恢复。</p><p>每个 Flink 集群至少要有一个 JobManager，但在生产环境中通常是高可用模式部署，即部署多台 JobManager，其中一台作为 Leader，其他的作为 Standby 节点。当 Leader 挂掉时，其他的 Standby 节点会有一台被选举为新的 Leader 提供服务。这样就能避免 JobManager 单机故障影响到整个 Flink 集群的可用性。</p><p>JobManager 主要由以下几部分组成，下面我们分别来看每部分的作用。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749308494/Blog/flink/0/JobManager.png" alt="JobManager"></p><h4 id="DataFlow-Graph"><a href="#DataFlow-Graph" class="headerlink" title="DataFlow Graph"></a>DataFlow Graph</h4><p>JobManager 收到 JobGraph 之后，根据并行度的设置，将各个算子任务拆分成并行的子任务，最终生成 ExecutionGraph。</p><h4 id="Checkpoint-coordinator"><a href="#Checkpoint-coordinator" class="headerlink" title="Checkpoint coordinator"></a>Checkpoint coordinator</h4><p>Checkpoint 是 Flink 最核心的概念之一，Flink 的容错机制主要靠 checkpoint 来保障。而 checkpoint 的生成会恢复则由 checkpoint coordinator 来负责。</p><h4 id="Job-Dispatch"><a href="#Job-Dispatch" class="headerlink" title="Job Dispatch"></a>Job Dispatch</h4><p>Job Dispatch 提供了 REST 接口用于提交 Flink 任务，并为每个任务启动一个 JobMaster。JobMaster 负责管理单个 JobGraph 的执行。</p><h4 id="Task-Scheduling"><a href="#Task-Scheduling" class="headerlink" title="Task Scheduling"></a>Task Scheduling</h4><p>Task Scheduling 负责 Task 部署和调度，值得一提的是，JobManager 和 TaskManager 以及 Client 之间的通信都是通过一个叫 Actor System 的 RPC 系统实现的。</p><h4 id="Resource-Manager"><a href="#Resource-Manager" class="headerlink" title="Resource Manager"></a>Resource Manager</h4><p>Resource Manager 负责集群中的资源的分配回收，它管理的资源单元叫做 task slot，对于不同的部署环境，Resource Manager 有不同的实现，</p><h4 id="Actor-System"><a href="#Actor-System" class="headerlink" title="Actor System"></a>Actor System</h4><p>Actor System 是 Flink 集群中的一种 RPC 通信的组件，JobManager 和 TaskManager 以及 Client 之间的通信都是基于 Actor System 的。而 TaskManager 之间的数据传递是基于 Netty 的。</p><h3 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a>TaskManager</h3><p>聊完了 JobManager，我们再来看下 TaskManager 的结构。TaskManager 主要负责执行作业的 task，并缓存和交换数据流。TaskManager 中最小的资源调度单位是 task slot，这点在前面介绍 Resource Manager 时也提到过。它表示并发处理 task 的数量。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749399164/Blog/flink/0/TaskManager.png" alt="TaskManager"></p><h4 id="Task-Execution"><a href="#Task-Execution" class="headerlink" title="Task Execution"></a>Task Execution</h4><p>TaskManager 在接到 JobManager 部署的任务后，就会申请相应的 task slot 去执行任务。</p><h4 id="Data-Exchange"><a href="#Data-Exchange" class="headerlink" title="Data Exchange"></a>Data Exchange</h4><p>Data Execution 主要负责 TaskManager 之间的数据交互的一些操作，这里主要关注逻辑层面，例如一些 shuffle 操作。而网络传输则主要是由 Network Manager 来实现。</p><h4 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h4><p>Memory Management 负责 TaskManager 的内存管理，在执行任务过程中，接收到的一些数据是需要放在内存中进行处理的。相应的内存管理操作依赖于 Memory Management 模块。</p><h4 id="Actor-System-1"><a href="#Actor-System-1" class="headerlink" title="Actor System"></a>Actor System</h4><p>Actor System 我们在前面提到过，TaskManager 和 JobManager 之间的通信全靠它。</p><h4 id="Network-Manager"><a href="#Network-Manager" class="headerlink" title="Network Manager"></a>Network Manager</h4><p>Network Manager 主要负责 TaskManager 之间的数据交互，它是基于 Netty 实现的。</p><p>最后多提一个 Graph 的概念，前面我们已经了解到了 JobManager 会将 JobGraph 根据并行度的配置转换成 ExecutionGraph。在这之后，JobManager 会对作业进行调度，将 task 部署到各个 TaskManager 上，最终就形成了物理执行图，也就是 PhysicalGraph。</p><p>这里小结一下，Flink 中四种图的生成顺序是：用户编写的代码生成 StreamGraph，Client 将其进行优化，主要是将多个符合条件的节点 chain 在一起，生成了 JobGraph，然后将 JobGraph 提交到 JobManager，再由 JobManager 生成并行版本的 ExecutionGraph，待JobManager 将 task 调度后，生成的图被称为 PhysicalGraph。</p><h3 id="Flink-的几种部署模式"><a href="#Flink-的几种部署模式" class="headerlink" title="Flink 的几种部署模式"></a>Flink 的几种部署模式</h3><p>根据集群的生命周期、资源隔离以及 main() 方法的执行，通常将 Flink 的部署模式分为三种：Session Mode、Per-Job Mode 和 Application Mode。下面我们分别介绍这三种部署模式。</p><h4 id="Session-Mode"><a href="#Session-Mode" class="headerlink" title="Session Mode"></a>Session Mode</h4><p>Session Mode 下，所有的任务共享 JobManager 和 TaskManager，JobManager 的生命周期不受提交的 Job 影响，会长期运行。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/SessionMode.png" alt="SessionMode"></p><h4 id="Per-Job-Mode"><a href="#Per-Job-Mode" class="headerlink" title="Per-Job Mode"></a>Per-Job Mode</h4><p>Per-Job Mode 下，每个任务独享 JobManager 和 TaskManager，资源充分隔离。JobManager 的生命周期和 Job 的生命周期绑定。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/Per-job.png" alt="Per-JobMode"></p><h4 id="Application-Mode"><a href="#Application-Mode" class="headerlink" title="Application Mode"></a>Application Mode</h4><p>Application Mode 下，每个 Application 对应一个 JobManager，且可以运行多个作业。客户端无需将依赖包上传到 JobManager，只负责提交作业，减轻了客户端的压力。提交作业后，JobManager 主动从 HDFS 拉取依赖包。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/Application.png" alt="ApplicationMode"></p><h4 id="三种模式的对比"><a href="#三种模式的对比" class="headerlink" title="三种模式的对比"></a>三种模式的对比</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Session</th><th style="text-align:center">Per-Job</th><th style="text-align:center">Application</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:center">1、资源充分共享，提升资源利用率<br/>2、作业集中管理，运维简单</td><td style="text-align:center">1、资源充分隔离<br/>2、每个作业的 TM Slots 可以不同</td><td style="text-align:center">1、有效降低带宽和客户端负载<br/>2、Application 之间实现资源隔离，Application 中的资源共享</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">1、资源隔离差<br/>2、TM 不易扩展，伸缩性差</td><td style="text-align:center">1、资源浪费</td><td style="text-align:center">1、仅支持 Yarn 和 Kubunetes （个人感觉够用了）</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后来总结一下，今天主要学习了 Flink 的整体架构和三种部署模式。</p><p>1、Flink 的集群架构上主要包含 JobManager 和 TaskManager，其中 JobManager 主要负责一些作业调度和资源协调的工作，TaskManager 则主要负责执行任务。</p><p>2、Flink 的部署模式分为 Session、Per-Job 和 Application 三种，Session 模式是所有 Job 共享 JobManager 和 TaskManager，Per-Job 则是作业独享的，而 Application 模式则是在 Application 中共享 JobManager。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开一个新坑，系统性的学习下 Flink，计划从整体架构到核心概念再到调优方法，最后是相关源码的阅读。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：最后一舞</title>
    <link href="https://jackeyzhe.github.io/2020/04/19/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%80%E5%90%8E%E4%B8%80%E8%88%9E/"/>
    <id>https://jackeyzhe.github.io/2020/04/19/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%80%E5%90%8E%E4%B8%80%E8%88%9E/</id>
    <published>2020-04-19T13:15:29.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rust入坑指南系列我觉得应该告一段落了，最后来做一个总结吧。<span id="more"></span></p><p>在我看来，Rust语言本身设计得算是非常好了。Ownership和borrow帮助我们保证了程序了安全性。同时也提供了Unsafe，给开发者更多玩一些骚操作的空间。唯一的缺点就是入门比较困难了吧，我现在的水平感觉自己也就是刚刚入门。而《Rust入坑指南》也是希望帮助更多想要学习Rust的同学快速入门。</p><p>这里简单回顾一下学习过程吧。</p><p>最开始接触一门语言一定绕不开Hello，World</p><p>Rust也是一样，所以我们的第一篇文章就是关于Rust的安装、Hello，World程序的。</p><p><a href="https://jackeyzhe.github.io/2019/09/21/Rust入坑指南：坑主驾到/">Rust入坑指南：坑主驾到</a></p><p>接着就是介绍一些基础的语法、Rust的所有权、数据结构这些概念。关于这部分知识我用了四篇文章来做介绍。其中最重要的应该是Rust所有权了，这也是Rust语言的亮点之一。</p><p><a href="https://jackeyzhe.github.io/2019/10/08/Rust入坑指南：常规套路/">Rust入坑指南：常规套路</a></p><p><a href="https://jackeyzhe.github.io/2019/10/13/Rust入坑指南：核心概念/">Rust入坑指南：核心概念</a></p><p><a href="https://jackeyzhe.github.io/2019/10/27/Rust入坑指南：千人千构/">Rust入坑指南：千人千构</a></p><p><a href="https://jackeyzhe.github.io/2019/11/27/Rust入坑指南：鳞次栉比/">Rust入坑指南：鳞次栉比</a></p><p>接着呢，我们介绍了Package和Crate，用来帮助我们组织代码的。同时Crate也是为了让我们可以直接使用别人的代码，避免重复造轮子。</p><p><a href="https://jackeyzhe.github.io/2019/11/03/Rust入坑指南：有条不紊/">Rust入坑指南：有条不紊</a></p><p>之后又是两个比较通用的概念，大多数编程语言时都要涉及到的：异常处理和泛型</p><p><a href="https://jackeyzhe.github.io/2019/12/30/Rust入坑指南：亡羊补牢/">Rust入坑指南：亡羊补牢</a></p><p><a href="https://jackeyzhe.github.io/2020/01/14/Rust入坑指南：海纳百川/">Rust入坑指南：海纳百川</a></p><p>如果你对代码的正确性不放心，那么一定要写下完备的单元测试，这是对自己的代码负责。</p><p><a href="https://jackeyzhe.github.io/2020/02/21/Rust入坑指南：步步为营/">Rust入坑指南：步步为营</a></p><p>除了OwnerShip和borrow之外，Rust的另外两个比较核心的概念也需要了解，分别是生命周期和智能指针。这两篇文章可以帮你快速了解这两个概念。</p><p><a href="https://jackeyzhe.github.io/2020/03/02/Rust入坑指南：朝生暮死/">Rust入坑指南：朝生暮死</a></p><p><a href="https://jackeyzhe.github.io/2020/03/09/Rust入坑指南：智能指针/">Rust入坑指南：智能指针</a></p><p>接着是并发编程，Rust声称的安全并发，究竟是怎么保证的？</p><p><a href="https://jackeyzhe.github.io/2020/03/15/Rust入坑指南：齐头并进（上）/">Rust入坑指南：齐头并进（上）</a></p><p><a href="https://jackeyzhe.github.io/2020/03/23/Rust入坑指南：齐头并进（下）/">Rust入坑指南：齐头并进（下）</a></p><p>Safe Rust有这样那样的限制，有的开发者可能会觉得束手束脚，难以发挥实力。这时就可以考虑看看Unsafe Rust了。</p><p><a href="https://jackeyzhe.github.io/2020/03/31/Rust入坑指南：居安思危/">Rust入坑指南：居安思危</a></p><p>最后是Rust的元编程，我们从最开始就在使用的<code>println!</code>宏，它是如何定义的呢？我们又怎么定义自己的宏？希望这篇文章对你有帮助。</p><p><a href="https://jackeyzhe.github.io/2020/04/08/Rust入坑指南：万物初始/">Rust入坑指南：万物初始</a></p><p>经过这几个月的学习，我对Rust也有了一个初步的了解，在这里要感谢对我的分享提出意见的同学。也希望我的分享能对大家有所帮助。</p><p>虽然标题叫最后一舞，但是后面我还是会继续保持学习，也会不定期分享一些入门的代码案例给大家。</p><p>Rust编程，我们后会有期。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust入坑指南系列我觉得应该告一段落了，最后来做一个总结吧。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：万物初始</title>
    <link href="https://jackeyzhe.github.io/2020/04/08/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%B8%87%E7%89%A9%E5%88%9D%E5%A7%8B/"/>
    <id>https://jackeyzhe.github.io/2020/04/08/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%B8%87%E7%89%A9%E5%88%9D%E5%A7%8B/</id>
    <published>2020-04-08T15:02:34.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>有没有同学记得我们一起挖了多少个坑？嗯…其实我自己也不记得了，今天我们再来挖一个特殊的坑，这个坑可以说是挖到根源了——<strong>元编程</strong>。<span id="more"></span></p><p>元编程是编程领域的一个重要概念，它允许程序将代码作为数据，在运行时对代码进行修改或替换。如果你熟悉Java，此时是不是想到了Java的反射机制？没错，它就是属于元编程的一种。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Rust也同样支持反射，Rust的反射是由标准库中的<code>std::any::Any</code>包支持的。</p><p>这个包中提供了以下几个方法</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1586171714/Blog/rust/15/rust15-1.png" alt="Any包的方法"></p><p>TypeId是Rust中的一种类型，它被用来表示某个类型的唯一标识。<code>type_id(&amp;self)</code>这个方法返回变量的TypeId。</p><p><code>is()</code>方法则用来判断某个函数的类型。</p><p>可以看一下它的源码实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is</span>&lt;T: Any&gt;(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">t</span> = TypeId::of::&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">concrete</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">type_id</span>();</span><br><span class="line"></span><br><span class="line">  t == concrete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的实现非常简单，就是对比TypeId。</p><p><code>downcast_ref()</code>和<code>downcast_mut()</code>是一对用于将泛型T转换为具体类型的方法。其返回的类型是<code>Option&lt;&amp;T&gt;</code>和<code>Option&lt;&amp;mut T&gt;</code>，也就是说<code>downcast_ref()</code>将类型T转换为不可变引用，而<code>downcast_mut()</code>将T转换为可变引用。</p><p>最后我们通过一个例子来看一下这几个函数的具体使用方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::&#123;Any, TypeId&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="string">&quot;Jackey&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: &amp;Any;</span><br><span class="line">    a = &amp;v1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">type_id</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(a.is::&lt;&amp;<span class="type">str</span>&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_any</span>(&amp;v1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">u32</span> = <span class="number">33</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_any</span>(&amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_any</span>(any: &amp;Any) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = any.downcast_ref::&lt;<span class="type">u32</span>&gt;() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;u32 &#123;:x&#125;&quot;</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = any.downcast_ref::&lt;&amp;<span class="type">str</span>&gt;() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;str &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;else&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>Rust的反射机制提供的功能比较有限，但是Rust还提供了宏来支持元编程。</p><p>到目前为止，宏对我们来说是一个既熟悉又陌生的概念，熟悉是因为我们一直在使用<code>println!</code>宏，陌生则是因为我们从没有详细介绍过它。</p><p>对于<code>println!</code>宏，我们直观上的使用感受是它和函数差不多。但两者之间还是有一定的区别的。</p><p>我们知道对于函数，它接收参数的个数是固定的，并且在函数定义时就已经固定了。而宏接收的参数个数则是不固定的。</p><p>这里我们说的宏都是类似函数的宏，此外，Rust还有一种宏是类似于属性的宏。它有点类似于Java中的注解，通常作为一种标记写在函数名上方。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure><p>route在这里是用来指定接口方法的，对于这个服务来讲，根路径的<code>GET</code>请求都被路由到这个index函数上。这样的宏是通过属于<strong>过程宏</strong>，它的定义使用了<code>#[proc_macro_attribute]</code>注解。而函数类似的过程宏在定义时使用的注解是<code>#[proc_macro]</code>。</p><p>除了过程宏以外，宏的另一大分类叫做<strong>声明宏</strong>。声明宏是通过<code>macro_rules!</code>来声明定义的宏，它比过程宏的应用要更加广泛。我们曾经接触过的<code>vec!</code>就是声明宏的一种。它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来定义一个属于自己的宏。</p><p>自定义宏需要使用<code>derive</code>注解。（例子来自the book）</p><p>我们先来创建一个叫做hello_macro的lib库，只定义一个trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HelloMacro</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着再创建一个子目录hello_macro_derive，在hello_macro_derive/Cargo.toml文件中添加依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-<span class="keyword">macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">syn = <span class="string">&quot;0.14.4&quot;</span></span><br><span class="line">quote = <span class="string">&quot;0.6.3&quot;</span></span><br></pre></td></tr></table></figure><p>然后就可以在hello_macro_derive/lib.rs文件中定义我们自定义宏的功能实现了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="comment">// Construct a representation of Rust code as a syntax tree</span></span><br><span class="line">    <span class="comment">// that we can manipulate</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the trait implementation</span></span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了两个crate：syn和quote，其中syn是把Rust代码转换成一种特殊的可操作的数据结构，而quote的作用则与它刚好相反。</p><p>可以看到，我们自定义宏使用的注解是<code>#[proc_macro_derive(HelloMacro)]</code>，其中HelloMacro是宏的名称，在使用时，我们只需要使用注解<code>#[derive(HelloMacro)]</code>即可。</p><p>在使用时我们应该先引入这两个依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello_macro = &#123; path = <span class="string">&quot;../hello_macro&quot;</span> &#125;</span><br><span class="line">hello_macro_derive = &#123; path = <span class="string">&quot;../hello_macro/hello_macro_derive&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>然后再来使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pancakes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Pancakes::<span class="title function_ invoke__">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示，我们能够成功在实现中捕获到结构体的名字。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1586190192/Blog/rust/15/rust15-2.png" alt="result"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们在本文中先后介绍了Rust的两种元编程：反射和宏。其中反射提供的功能能力较弱，但是宏提供的功能非常强大。我们所介绍的宏的相关知识其实只是皮毛，要想真正理解宏，还需要花更多的时间学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有没有同学记得我们一起挖了多少个坑？嗯…其实我自己也不记得了，今天我们再来挖一个特殊的坑，这个坑可以说是挖到根源了——&lt;strong&gt;元编程&lt;/strong&gt;。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：居安思危</title>
    <link href="https://jackeyzhe.github.io/2020/03/31/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%B1%85%E5%AE%89%E6%80%9D%E5%8D%B1/"/>
    <id>https://jackeyzhe.github.io/2020/03/31/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%B1%85%E5%AE%89%E6%80%9D%E5%8D%B1/</id>
    <published>2020-03-31T10:17:48.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何事情都是相对的，就像Rust给我们的印象一直是安全、快速，但实际上，完全的安全是不可能实现的。因此，Rust中也是会有不安全的代码的。<span id="more"></span></p><p>严格来讲，Rust语言可以分为<strong>Safe Rust</strong>和<strong>Unsafe Rust</strong>。Unsafe Rust是Safe Rust的超集。在Unsafe Rust中并不会禁用任何的安全检查，Unsafe Rust出现的原因是为了让开发者可以做一些更加底层的操作。这些事情本身也是不安全的，如果仍然要进行Rust的安全检查，那么就无法进行这些操作。</p><p>在进行下面这5种操作时，Unsafe Rust不会进行安全检查。</p><ul><li>解引用原生指针</li><li>调用unsafe的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现unsafe的trait</li><li>读写联合体中的字段</li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>Unsafe Rust的关键字是unsafe，它可以用来修饰函数、方法和trait，也可以用来标记代码块。</p><p>标准库中也有不少函数是unsafe的。例如String中的<code>from_utf8_unchecked()</code>函数。它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">from_utf8_unchecked</span>(bytes: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">  <span class="type">String</span> &#123; vec: bytes &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数被标记为unsafe的原因是函数并没有检查传入参数是否是合法的UTF-8序列。也就是提醒使用者注意，使用这个函数要自己保证参数的合法性。</p><p>用unsafe标记的trait也比较常见，在前面我们见过的Send和Sync都是unsafe的trait。它们被用来保证线程安全， 将其标记为unsafe是告诉开发者，如果自己实现这两个trait，那么代码就会有安全风险。</p><p>我们在调用unsafe函数或方法时，需要使用unsafe代码块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sparkle_heart</span> = <span class="built_in">vec!</span>[<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sparkle_heart</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_unchecked</span>(sparkle_heart)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;💖&quot;</span>, sparkle_heart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解了unsafe的基础语法之后，我们再来具体看看前面提到的5种操作。</p><h3 id="解引用原生指针"><a href="#解引用原生指针" class="headerlink" title="解引用原生指针"></a>解引用原生指针</h3><p>Rust的原生指针分为两种：可变类型<code>*mut T</code>和不可变类型<code>*const T</code>。</p><p>与引用和智能指针不同，原生指针具有以下特性：</p><ul><li>可以不遵循借用规则，在同一代码块中可以同时出现可变和不可变指针，也可以同时有多个可变指针</li><li>不保证指向有效内存</li><li>允许是null</li><li>不会自动清理内存</li></ul><p>由这些特性可以看出，原生指针并不受Rust那一套安全规则的限制，因此，解引用原生指针是一种不安全的操作。换句话说，我们应该把这种操作放在unsafe代码块中。下面这段代码就展示了原生指针的第一条特性，以及如何解引用原生指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Rust编程中，原生指针常被用作和C语言打交道，原生指针有一些特有的方法，例如可以用<code>is_null()</code>来判断原生指针是否是空指针，用<code>offset()</code>来获取指定偏移量的内存地址的内容，使用<code>read()/write()</code>方法来读写内存等。</p><h3 id="调用unsafe的函数或方法"><a href="#调用unsafe的函数或方法" class="headerlink" title="调用unsafe的函数或方法"></a>调用unsafe的函数或方法</h3><p>调用unsafe的函数或方法必须放到unsafe代码块中，这点我们在基础知识中已经介绍过。因为函数本身被标记为unsafe，也就意味着调用它可能存在风险。这点无需赘述。</p><h3 id="访问或修改可变的静态变量"><a href="#访问或修改可变的静态变量" class="headerlink" title="访问或修改可变的静态变量"></a>访问或修改可变的静态变量</h3><p>对于不可变的静态变量，我们访问它不会存在任何安全问题，但是对于可变的静态变量而言，如果我们在多线程中都访问同一个变量，那么就会造成数据竞争。这当然也是一种不安全的操作。所以要放到unsafe代码块中，此时线程安全应由开发者自己来保证。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中我们没有使用多线程，这里只是想展示一下如何访问和修改可变静态变量。</p><h3 id="实现unsafe的trait"><a href="#实现unsafe的trait" class="headerlink" title="实现unsafe的trait"></a>实现unsafe的trait</h3><p>当trait中包含一个或多个编译器无法验证其安全性的方法时，这个trait就必须被标记为unsafe。而想要实现unsafe的trait，首先在实现代码块的关键字<code>impl</code>前也要加上unsafe标记。其次，无法被编译器验证安全性的方法，其安全性必须由开发者自己来保证。</p><p>前面我们也提到了，常见的unsafe的trait有Send和Sync这两个。</p><h3 id="读写联合体中的字段"><a href="#读写联合体中的字段" class="headerlink" title="读写联合体中的字段"></a>读写联合体中的字段</h3><p>Rust中的Union联合体和Enum相似。我们可以使用union关键字来定义一个联合体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">MyUnion</span> &#123;</span><br><span class="line">    i: <span class="type">i32</span>,</span><br><span class="line">    f: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_union</span> = MyUnion&#123;i: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, my_union.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化时，我们每次只能指定一个字段的值。这就造成我们在访问联合体中的字段时，有可能会访问到未定义的字段。因此，Rust让我们把访问操作放到unsafe代码块中，以此来警示我们必须自己保证程序的安全性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们聊了Unsafe Rust的一些使用场景和使用方法。你只需要记住Unsafe的5种操作就好，在遇到这些操作时，一定要使用unsafe代码块。unsafe代码块不光是为了“骗”过编译器，要时刻提醒自己，<strong>unsafe代码块中的程序要由开发者自己保证其正确性</strong>。</p><ul><li>解引用原生指针</li><li>调用unsafe的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现unsafe的trait</li><li>读写联合体中的字段</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何事情都是相对的，就像Rust给我们的印象一直是安全、快速，但实际上，完全的安全是不可能实现的。因此，Rust中也是会有不安全的代码的。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>走近源码：Redis如何清除过期key</title>
    <link href="https://jackeyzhe.github.io/2020/03/30/%E8%B5%B0%E8%BF%91%E6%BA%90%E7%A0%81%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E8%BF%87%E6%9C%9Fkey/"/>
    <id>https://jackeyzhe.github.io/2020/03/30/%E8%B5%B0%E8%BF%91%E6%BA%90%E7%A0%81%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E8%BF%87%E6%9C%9Fkey/</id>
    <published>2020-03-30T14:18:37.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>“叮……”，美好的周六就这么被一阵钉钉消息吵醒了。<span id="more"></span></p><p>业务组的同学告诉我说很多用户的帐号今天被强制下线。我们的帐号系统正常的逻辑是用户登录一次后，token的有效期可以维持一天的时间。现在的问题是用户大概每10分钟左右就需要重新登录一次。这种情况一般有两种原因：1、token生成时出问题。2、验证token时出现问题。</p><p>通过检查日志，我发现是验证token时，Redis中已经没有对应的token了。并且确定了生成新的token时，set到Redis中的有效期是正确的，那么就基本可以确定是Redis的问题了。</p><p>于是又去检查了Redis的监控，发现在那段时间Redis由于内存占用过高强制清理了几次key。但从日志上来看，这段时间并没有出现流量暴涨的情况，而且Redis中key的数量也没有显著增加。那是什么原因导致Redis内存占用过高呢？确定了Redis内存升高不是我们造成的之后，我们又联系了业务组的同学协助他们，他们表示最近确实有上线，并且新上线的功能有使用到Redis。但我仍然感觉很奇怪，为什么Redis中的key没有增多，并且没看到有其他业务的key。经过一番询问，才了解到，业务组同学使用的是这个Redis的db1，而我用的（和刚查的）是db0。这里确实是我在排查问题时出现了疏忽。</p><p>那么Redis的不同db之间会互相影响吗？通常情况下，我们使用不同的db进行数据隔离，这没问题。<strong>但Redis进行清理时，并不是只清理数据量占用最大的那个db，而是会对所有的db进行清理。</strong>在这之前我并不是很了解这方面知识，这里也只是根据现象进行的猜测。</p><p>好奇心驱使我来验证一下这个想法。于是我决定直接来看Redis的源码。清理key相关的代码在<a href="https://github.com/antirez/redis/blob/unstable/src/evict.c">evict.c</a>文件中。</p><p>Redis中会保存一个“过期key池”，这个池子中存放了一些可能会被清理的key。其中保存的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="type">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中idle是对象空闲时间，在Reids中，key的过期算法有两种：一种是近似LRU，一种是LFU。默认使用的是近似LRU。</p><h3 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h3><p>在解释近似LRU之前，先来简单了解一下LRU。当Redis的内存占用超过我们设置的maxmemory时，会把长时间没有使用的key清理掉。按照LRU算法，我们需要对所有key（也可以设置成只淘汰有过期时间的key）按照空闲时间进行排序，然后淘汰掉空闲时间最大的那部分数据，使得Redis的内存占用降到一个合理的值。</p><p>LRU算法的缺点是，我们需要维护一个全部（或只有过期时间）key的列表，还要按照最近使用时间排序。这会消耗大量内存，并且每次使用key时更新排序也会占用额外的CPU资源。对于Redis这样对性能要求很高的系统来说是不被允许的。</p><p>因此，Redis采用了一种近似LRU的算法。当Redis接收到新的写入命令，而内存又不够时，就会触发近似LRU算法来强制清理一些key。具体清理的步骤是，Redis会对key进行采样，通常是取5个，然后会把过期的key放到我们上面说的“过期池”中，过期池中的key是按照空闲时间来排序的，Redis会优先清理掉空闲时间最长的key，直到内存小于maxmemory。</p><p>近似LRU算法的清理效果图如图（图片来自Redis官方文档）</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1585453145/Blog/Redis/evict/lru_comparison.png" alt="lru_comparison"></p><p>这么说可能不够清楚，我们直接上代码。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1585453153/Blog/Redis/evict/lru_call.png" alt="lru_call"></p><p>上图展示了代码中近似LRU算法的主要逻辑调用路径。</p><p>其中主要逻辑是在<code>freeMemoryIfNeeded</code>函数中</p><p>首先调用<code>getMaxmemoryState</code>函数判断当前内存的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMaxmemoryState</span><span class="params">(<span class="type">size_t</span> *total, <span class="type">size_t</span> *logical, <span class="type">size_t</span> *tofree, <span class="type">float</span> *level)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="type">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="type">float</span>)mem_used / (<span class="type">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用内存低于maxmemory的话，就返回<code>C_OK</code>，否则返回<code>C_ERR</code>。另外，这个函数还通过传递指针型的参数来返回一些额外的信息。</p><ul><li><strong>total</strong>：已使用的字节总数，无论是<code>C_OK</code>还是<code>C_ERR</code>都有效。</li><li><strong>logical</strong>：已使用的内存减去slave或AOF缓冲区后的大小，只有返回<code>C_ERR</code>时有效。</li><li><strong>tofree</strong>：需要释放的内存大小，只有返回<code>C_ERR</code>时有效。</li><li><strong>level</strong>：已使用内存的比例，通常是0到1之间，当超出内存限制时，就大于1。无论是<code>C_OK</code>还是<code>C_ERR</code>都有效。</li></ul><p>判断完内存状态以后，如果内存没有超过使用限制就会直接返回，否则就继续向下执行。此时我们已经知道需要释放多少内存空间了，下面就开始进行释放内存的操作了。每次释放内存都会记录释放内存的大小，直到释放的内存不小于<code>tofree</code>。</p><p>首先根据<code>maxmemory_policy</code>进行判断，对于不同的清除策略有不同的实现方法，我们来看LRU的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">  db = server.db+i;</span><br><span class="line">  dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">    db-&gt;dict : db-&gt;expires;</span><br><span class="line">  <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">    evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">    total_keys += keys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是填充“过期池”，这里遍历了每一个db（验证了我最开始的想法），调用<code>evictionPoolPopulate</code>函数进行填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"><span class="comment">/* some code */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* some code */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k--;</span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* some code */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于篇幅原因，我截取了部分代码，通过这段代码我们可以看到，Redis首先是采样了一部分key，这里采样数量maxmemory_samples通常是5，我们也可以自己设置，采样数量越大，结果就越接近LRU算法的结果，带来的影响是性能随之变差。</p><p>采样之后我们需要获得每个key的空闲时间，然后将其填充到“过期池”中的指定位置。这里“过期池”是按照空闲时间从小到大排序的，也就是说，idle大大key排在最右边。</p><p>填充完“过期池”之后，会从后向前获取到最适合清理的key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line"><span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">  bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">    de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                  pool[k].key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                  pool[k].key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* some code */</span></span><br><span class="line">  <span class="keyword">if</span> (de) &#123;</span><br><span class="line">    bestkey = dictGetKey(de);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到需要删除的key后，就需要根据设置清理策略进行同步/异步清理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">  dbAsyncDelete(db,keyobj);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  dbSyncDelete(db,keyobj)</span><br></pre></td></tr></table></figure><p>最后记下本次清理的空间大小，用来在循环条件判断是否要继续清理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delta -= (<span class="type">long</span> <span class="type">long</span>) zmalloc_used_memory();</span><br><span class="line">mem_freed += delta;</span><br></pre></td></tr></table></figure><h3 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h3><p>最后我们来看一下Redis支持的几种清理策略</p><ul><li><strong>noeviction</strong>：不会继续处理写请求（DEL可以继续处理）。</li><li><strong>allkeys-lru</strong>：对所有key的近似LRU</li><li><strong>volatile-lru</strong>：使用近似LRU算法淘汰设置了过期时间的key</li><li><strong>allkeys-random</strong>：从所有key中随机淘汰一些key</li><li><strong>volatile-random</strong>：对所有设置了过期时间的key随机淘汰</li><li><strong>volatile-ttl</strong>：淘汰有效期最短的一部分key</li></ul><p>Redis4.0开始支持了LFU策略，和LRU类似，它分为两种：</p><ul><li><strong>volatile-lfu</strong>：使用LFU算法淘汰设置了过期时间的key</li><li><strong>allkeys-lfu</strong>：从全部key中进行淘汰，使用LFU</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>现在我知道了Redis在内存达到上限时做了哪些事了。以后出问题时也就不会只检查自己的db了。</p><p>关于这次事故的后续处理，我首先是让业务同学回滚了代码，然后让他们使用一个单独的Redis，这样业务再出现类似问题就不会影响到我们的帐号服务了，整体的影响范围也会变得更加可控。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“叮……”，美好的周六就这么被一阵钉钉消息吵醒了。</summary>
    
    
    
    
    <category term="Redis" scheme="https://jackeyzhe.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：齐头并进（下）</title>
    <link href="https://jackeyzhe.github.io/2020/03/23/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://jackeyzhe.github.io/2020/03/23/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-23T13:24:02.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程。<span id="more"></span></p><h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>许多编程语言都会提供原子类型，Rust也不例外，在前文中我们聊了Rust中锁的使用，有了锁，就要小心死锁的问题，Rust虽然声称是安全并发，但是仍然无法帮助我们解决死锁的问题。原子类型就是编程语言为我们提供的无锁并发编程的最佳手段。熟悉Java的同学应该知道，Java的编译器并不能保证代码的执行顺序，编译器会对我们的代码的执行顺序进行优化，这一操作成为指令重排。而Rust的多线程内存模型不会进行指令重排，它可以保证指令的执行顺序。</p><p>通常来讲原子类型会提供以下操作：</p><ul><li>Load：从原子类型读取值</li><li>Store：为一个原子类型写入值</li><li>CAS（Compare-And-Swap）：比较并交换</li><li>Swap：交换</li><li>Fetch-add（sub/and/or）：表示一系列的原子的加减或逻辑运算</li></ul><p>Ok，这些基础的概念聊完以后，我们就来看看Rust为我们提供了哪些原子类型。Rust的原子类型定义在标准库<code>std::sync::atomic</code>中，目前它提供了12种原子类型。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584877213/Blog/rust/13/rust13-1.png" alt="原子类型"></p><p>下面这段代码是Rust演示了如何用原子类型实现一个自旋锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock_clone</span> = spinlock.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">        spinlock_clone.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> spinlock.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="number">0</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(panic) = thread.<span class="title function_ invoke__">join</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用AtomicUsize的store方法将它的值设置为0，然后用load方法获取到它的值，如果不是0，则程序一直空转。在store和load方法中，我们都用到了一个参数：<code>Ordering::SeqCst</code>，在声明中能看出来它也是属于atomic包。</p><p>我们在文档中发现它是一个枚举。其定义为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Ordering</span> &#123;</span><br><span class="line">    Relaxed,</span><br><span class="line">    Release,</span><br><span class="line">    Acquire,</span><br><span class="line">    AcqRel,</span><br><span class="line">    SeqCst,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是将内存顺序的控制权交给开发者，我们可以自己定义底层的内存排序。下面我们一起来看一下这5种排序分别代表什么意思</p><ul><li>Relaxed：表示「没有顺序」，也就是开发者不会干预线程顺序，线程只进行原子操作</li><li>Release：对于使用Release的store操作，在它之前所有使用Acquire的load操作都是可见的</li><li>Acquire：对于使用Acquire的load操作，在它之前的所有使用Release的store操作也都是可见的</li><li>AcqRel：它代表读时使用Acquire顺序的load操作，写时使用Release顺序的store操作</li><li>SeqCst：使用了SeqCst的原子操作都必须先存储，再加载。</li></ul><p>一般情况下建议使用SeqCst，而不推荐使用Relaxed。</p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>Go语言文档中有这样一句话：<strong>不要使用共享内存来通信，应该使用通信实现共享内存。</strong></p><p>Rust标准库选择了CSP并发模型，也就是依赖channel来进行线程间的通信。它的定义是在标准库<code>std::sync::mpsc</code>中，里面定义了三种类型的CSP进程：</p><ul><li>Sender：发送异步消息</li><li>SyncSender：发送同步消息</li><li>Receiver：用于接收消息</li></ul><p>我们通过一个栗子来看一下channel是如何创建并收发消息的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们先是使用了<code>channel()</code>函数来创建一个channel，它会返回一个（Sender, Receiver）元组。它的缓冲区是无界的。此外，我们还可以使用<code>sync_channel()</code>来创建channel，它返回的则是（SyncSender, Receiver）元组，这样的channel发送消息是同步的，并且可以设置缓冲区大小。</p><p>接着，在子线程中，我们定义了一个字符串变量，并使用<code>send()</code>函数向channel中发送消息。这里send返回的是一个Result类型，所以使用unwrap来传播错误。</p><p>在main函数最后，我们又用<code>recv()</code>函数来接收消息。</p><p>这里需要注意的是，<code>send()</code>函数会转移所有权，所以，如果你在发送消息之后再使用val变量时，程序就会报错。</p><p>现在我们已经掌握了使用Channel进行线程间通信的方法了，这里还有一段代码，感兴趣的同学可以自己执行一下这段代码看是否能够顺利执行。如果不能，应该怎么修改这段代码呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">rx</span> <span class="keyword">in</span> rx.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在实际工作中，如果每次都要创建新的线程，每次创建、销毁线程的开销就会变得非常可观，甚至会成为系统性能的瓶颈。对于这种问题，我们通常使用线程池来解决。</p><p>Rust的标准库中没有现成的线程池给我们使用，不过还是有一些第三方库来支持的。这里我使用的是<a href="https://crates.io/crates/threadpool">threadpool</a>。</p><p>首先需要在Cargo.toml中增加依赖<code>threadpool = &quot;1.7.1&quot;</code>。然后就可以使用<code>use threadpool::ThreadPool;</code>将ThreadPool引入我们的程序中了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> threadpool::ThreadPool;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_workers</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_jobs</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(n_workers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n_jobs &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;channel will be there waiting for the pool&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(rx.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">take</span>(n_jobs).<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |a, b| a + b), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用<code>ThreadPool::new()</code>来创建一个线程池，初始化4个工作线程。使用时用<code>execute()</code>方法就可以拿出一个线程来进行具体的工作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们介绍了Rust并发编程的三种特性：原子类型、线程间通信和线程池的使用。</p><p>原子类型是我们进行无锁并发的重要手段，线程间通信和线程池也都是工作中所必须使用的。当然并发编程的知识远不止于此，大家有兴趣的可以自行学习也可以与我交流讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：齐头并进（上）</title>
    <link href="https://jackeyzhe.github.io/2020/03/15/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://jackeyzhe.github.io/2020/03/15/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-03-15T14:30:49.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如今CPU的计算能力已经非常强大，其速度比内存要高出许多个数量级。为了充分利用CPU资源，多数编程语言都提供了并发编程的能力，Rust也不例外。<span id="more"></span></p><p>聊到并发，就离不开多进程和多线程这两个概念。其中，进程是资源分配的最小单位，而线程是程序运行的最小单位。线程必须依托于进程，多个线程之间是共享进程的内存空间的。进程间的切换复杂，CPU利用率低等缺点让我们在做并发编程时更加倾向于使用多线程的方式。</p><p>当然，多线程也有缺点。其一是程序运行顺序不能确定，因为这是由内核来控制的，其二就是多线程编程对开发者要求比较高，如果不充分了解多线程机制的话，写出的程序就非常容易出Bug。</p><p>多线程编程的主要难点在于如何保证线程安全。什么是线程安全呢？因为多个线程之间是共享内存空间的，因此就会存在同时对相同的内存进行写操作，那就会出现写入数据互相覆盖的问题。如果多个线程对内存只有读操作，没有任何写操作，那么也就不会存在安全问题，我们可以称之为线程安全。</p><p>常见的并发安全问题有<strong>竞态条件</strong>和<strong>数据竞争</strong>两种，竞态条件是指多个线程对相同的内存区域（我们称之为临界区）进行了“读取-修改-写入”这样的操作。而数据竞争则是指一个线程写一个变量，而另一个线程需要读这个变量，此时两者就是数据竞争的关系。这么说可能不太容易理解，不过不要紧，待会儿我会举两个具体的例子帮助大家理解。不过在此之前，我想先介绍一下Rust中是如何进行并发编程的。</p><h3 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h3><p>在Rust标准库中，提供了两个包来进行多线程编程：</p><ul><li>std::thread，定义一些管理线程的函数和一些底层同步原语</li><li>std::sync，定义了锁、Channel、条件变量和屏障</li></ul><p>我们使用std::thread中的<code>spawn</code>函数来创建线程，它的使用非常简单，其参数是一个闭包，传入创建的线程需要执行的程序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们有两个线程，一个主线程，一个是用<code>spawn</code>创建出来的线程，两个线程都执行了一个循环。循环中打印了一句话，然后让线程休眠1毫秒。它的执行结果是这样的：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584253897/Blog/rust/12/rust12-1.png" alt="执行结果"></p><p>从结果中我们能看出两件事：第一，两个线程是交替执行的，但是并没有严格的顺序，第二，当主线程结束时，它并没有等子线程运行完。</p><p>那我们有没有办法让主线程等子线程执行结束呢？答案当然是有的。Rust中提供了<code>join</code>函数来解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样主线程就必须要等待子线程执行完毕。</p><p>在某些情况下，我们需要将一些变量在线程间进行传递，正常来讲，闭包需要捕获变量的引用，这里就涉及到了生命周期问题，而子线程的闭包的存活周期有可能长于当前的函数，这样就会造成悬垂指针，这在Rust中是绝对不允许的。因此我们需要使用<code>move</code>关键字将所有权转移到闭包中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>thread::spawn</code>创建线程是不是非常简单。但是也是因为它的简单，所以可能无法满足我们一些定制化的需求。例如制定线程的栈大小，线程名称等。这时我们可以使用<code>thread::Builder</code>来创建线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::&#123;Builder, current&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread_name</span> = <span class="built_in">format!</span>(<span class="string">&quot;child-&#123;&#125;&quot;</span>, id);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">size</span>: <span class="type">usize</span> = <span class="number">3</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">builder</span> = Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">name</span>(thread_name).<span class="title function_ invoke__">stack_size</span>(size);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child</span> = builder.<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;in child:&#123;&#125;&quot;</span>, <span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">name</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">child</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        child.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap_or_default</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>thread::spawn</code>创建的线程返回的类型是<code>JoinHandle&lt;T&gt;</code>，而使用<code>builder.spawn</code>返回的是<code>Result&lt;JoinHandle&lt;T&gt;&gt;</code>，因此这里需要加上<code>unwrap</code>方法。</p><p>除了刚才提到了这些函数和结构体，<code>std::thread</code>还提供了一些底层同步原语，包括park、unpark和yield_now函数。其中park提供了阻塞线程的能力，unpark用来恢复被阻塞的线程。yield_now函数则可以让线程放弃时间片，让给其他线程执行。</p><h3 id="Send和Sync"><a href="#Send和Sync" class="headerlink" title="Send和Sync"></a>Send和Sync</h3><p>聊完了线程管理，我们再回到线程安全的话题，Rust提供的这些线程管理工具看起来和其他没有什么区别，那Rust又是如何保证线程安全的呢？</p><p>秘密就在<code>Send</code>和<code>Sync</code>这两个trait中。它们的作用是：</p><ul><li>Send：实现Send的类型可以安全的在线程间传递所有权。</li><li>Sync：实现Sync的类型可以安全的在线程间传递不可变借用。</li></ul><p>现在我们可以看一下<code>spawn</code>函数的源码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt; <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T, F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>, T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br><span class="line">&#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">spawn</span>(f).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to spawn thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其参数F和返回值类型T都加上了<code>Send + &#39;static</code>限定，Send表示闭包必须实现Send，这样才可以在线程间传递。而<code>&#39;static</code>表示T只能是非引用类型，因为使用引用类型则无法保证生命周期。</p><p>在<a href="https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">Rust入坑指南：智能指针</a>一文中，我们介绍了共享所有权的指针<code>Rc&lt;T&gt;</code>，但在多线程之间共享变量时，就不能使用<code>Rc&lt;T&gt;</code>，因为它的内部不是原子操作。不过不要紧，Rust为我们提供了线程安全版本：<code>Arc&lt;T&gt;</code>。</p><p>下面我们一起来验证一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s_clone</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            s_clone.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会报如下错误</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584278809/Blog/rust/12/rust12-2.png" alt="Rc报错"></p><p>那我们把<code>Rc</code>替换为<code>Arc</code>试一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><p>很遗憾，程序还是报错。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584279037/Blog/rust/12/rust12-3.png" alt="Arc报错"></p><p>这是因为，Arc默认是不可变的，我们还需要提供内部可变性。这时你可能想到来RefCell，但是它也是线程不安全的。所以这里我们需要使用<code>Mutex&lt;T&gt;</code>类型。它是Rust实现的互斥锁。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Rust中使用<code>Mutex&lt;T&gt;</code>实现互斥锁，从而保证线程安全。如果类型T实现了Send，那么<code>Mutex&lt;T&gt;</code>会自动实现Send和Sync。它的使用方法也比较简单，在使用之前需要通过<code>lock</code>或<code>try_lock</code>方法来获取锁，然后再进行操作。那么现在我们就可以对前面的代码进行修复了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s_clone</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s_clone</span> = s_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            s_clone.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">child</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        child.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>介绍完了互斥锁之后，我们再来了解一下Rust中提供的另外一种锁——读写锁<code>RwLock&lt;T&gt;</code>。互斥锁用来独占线程，而读写锁则可以支持多个读线程和一个写线程。</p><p>在使用读写锁时要注意，读锁和写锁是不能同时存在的，在使用时必须要使用显式作用域把读锁和写锁隔离开。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们先是介绍了Rust管理线程的两个函数：<code>spawn</code>、<code>join</code>。并且知道了可以使用Builder结构体定制化创建线程。然后又学习了Rust提供线程安全的两个trait，Send和Sync。最后我们一起学习了Rust提供的两种锁的实现：互斥锁和读写锁。</p><p>关于Rust并发编程坑还没有到底，接下来还有条件变量、原子类型这些坑等着我们来挖。今天就暂时歇业了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道，如今CPU的计算能力已经非常强大，其速度比内存要高出许多个数量级。为了充分利用CPU资源，多数编程语言都提供了并发编程的能力，Rust也不例外。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】推荐你使用Vim的三个半理由</title>
    <link href="https://jackeyzhe.github.io/2020/03/11/%E3%80%90%E8%AF%91%E3%80%91%E6%8E%A8%E8%8D%90%E4%BD%A0%E4%BD%BF%E7%94%A8Vim%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8D%8A%E7%90%86%E7%94%B1/"/>
    <id>https://jackeyzhe.github.io/2020/03/11/%E3%80%90%E8%AF%91%E3%80%91%E6%8E%A8%E8%8D%90%E4%BD%A0%E4%BD%BF%E7%94%A8Vim%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8D%8A%E7%90%86%E7%94%B1/</id>
    <published>2020-03-11T14:45:45.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很久以前，软件行业就有一种争论：究竟要不要使用Vim。这种争论有点像音乐界关于模拟信号与数字信号的争论。<span id="more"></span></p><p>在大多数工程师眼中，Vim是一种老旧的，已经过时了的文本编辑器。它缺乏很多优秀的功能，用起来也没有现代的IDE舒服。但实际上，Vim绝对不是一种老旧的文本编辑器。</p><p>Vim就像是手动挡的汽车一样。</p><p>你必须要学会如何去驾驭它，如何手动换挡。而一旦你习惯了以后，就会获得成倍的收获与乐趣。它可以带着你在蜿蜒的小路上行驶，你需要保持全神贯注，并且精巧的换挡。这时你会觉得你和汽车之间仿佛建立了某种连接，它就像是你身体的一部分一样。</p><p>Vim就是这样子，这也是为什么它会如此有趣的原因。</p><p>下面就是我推荐你使用Vim的3个半理由。</p><h3 id="1-不用鼠标"><a href="#1-不用鼠标" class="headerlink" title="1. 不用鼠标"></a>1. 不用鼠标</h3><p>当你使用Vim的时候，你几乎可以不使用鼠标，你必须用键盘去做所有的事情。这会使你成为更强大、更高效的开发者。</p><p>你的手离开键盘的次数越多，你的工作效率就会越低。每次使用鼠标都会拖慢你的工作效率，你的大脑就像CPU一样要进行线程上下文的切换。所以你应该慢慢学会使用快捷键。</p><p>Vim的一大好处就是它只能使用快捷键，你想用鼠标都不行。</p><p>你必须学着习惯这一点。</p><h3 id="2-本地开发"><a href="#2-本地开发" class="headerlink" title="2. 本地开发"></a>2. 本地开发</h3><p>在大多数Unix系统中，默认都可以使用Vim或者Vi。这两者是完全运行在命令行上的编辑器看，由于没有GUI，因此它们更加通用和轻便。</p><p>因为Vim是完全由命令行驱动的，当你使用SSH连接远程服务器编辑文本或者在线修改代码时，就会有飞一样的感觉了。</p><p>在使用像Ubuntu Server这样本身并不包含GUI的系统时，VIm更是显得尤为重要。</p><p>有了Vim，你就不需要在系统直接来回传输文件，也不用使用SSHFS来挂载远程系统了。只需要用vim打开你的配置文件，编辑，然后<code>:wq</code>。</p><h3 id="3-不会分心"><a href="#3-不会分心" class="headerlink" title="3. 不会分心"></a>3. 不会分心</h3><p>你是否真的需要自动补全和集成代码分析呢？你又真的需要那些花里胡哨的UI吗？</p><p>你应该学会的是简单思考，Vim没有那些大型IDE臃肿的功能，它能让你专注于问题的本质：代码。</p><p>使用Vim时，你会变得更加有条理和严谨。你会更加清楚你当前在编辑的是哪个文件，它在什么目录下。即使没有展示在你面前，你也会很清楚它们的位置。</p><p>由于编辑器的简单性，在文件之间进行编辑，剪切，粘贴和移动这些动作会变得更加清晰和明确。</p><p>当然了，有时候你可能需要一些额外的功能。可以通过安装Vim插件来达到目的。这些插件都是按需取用的，你只需要选择你真正需要用的即可。</p><p>你可以使用<a href="https://github.com/tpope/vim-pathogen">Pathogen</a>来帮助你管理Vim的插件。</p><h3 id="3½-街头威望"><a href="#3½-街头威望" class="headerlink" title="3½ 街头威望"></a>3½ 街头威望</h3><p>其他不使用Vim的开发人员看到你使用Vim开发时会觉得你很疯狂，你可以利用他们的这种心态来展示自己的优势，同时还能提高影响力。</p><p>记住，你可以比别人开发的更快。因为Vim比那些现代的大型IDE占用的内存要少得多。</p><p>无论你是为了什么目的去使用Vim，抑或是被迫去使用的。你都可以学着去爱上它，这样你自己也会成长很多。</p><p>Vim是最好的厨师才能用的刀。你可以用它来切东西，或者被它切。。。</p><h3 id="译者点评"><a href="#译者点评" class="headerlink" title="译者点评"></a>译者点评</h3><p>Vim在开发中的用处还是很大的，不过我本人也只是把它作为一个文本编辑器来用，写代码还是更习惯用IDE。因为我真的需要代码补全功能。用Vim编程也许只有那些初代目大佬才能做到吧。大家还是可以适当学一学使用Vim，毕竟在外行看来可以算是装X利器了。</p><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://medium.com/better-programming/3%C2%BD-reasons-why-you-should-be-using-vim-8202360afa3">https://medium.com/better-programming/3%C2%BD-reasons-why-you-should-be-using-vim-8202360afa3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在很久以前，软件行业就有一种争论：究竟要不要使用Vim。这种争论有点像音乐界关于模拟信号与数字信号的争论。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：智能指针</title>
    <link href="https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2020-03-09T14:26:45.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。<span id="more"></span></p><p>智能指针是Rust中一种特殊的数据结构。它与普通指针的本质区别在于普通指针是对值的借用，而智能指针通常拥有对数据的所有权。在Rust中，如果你想要在堆内存中定义一个对象，并不是像Java中那样直接new一个，也不是像C语言中那样需要手动malloc函数来分配内存空间。Rust中使用的是<code>Box::new</code>来对数据进行封箱，而<code>Box&lt;T&gt;</code>就是我们今天要介绍的智能指针之一。除了<code>Box&lt;T&gt;</code>之外，Rust标准库中提供的智能指针还有<code>Rc&lt;T&gt;</code>、<code>Ref&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code>等等。在详细介绍之前，我们还是先了解一下智能指针的基本概念。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们说Rust的智能指针是一种特殊的数据结构，那么它特殊在哪呢？它与普通数据结构的区别在于智能指针实现了<code>Deref</code>和<code>Drop</code>这两个traits。实现<code>Deref</code>可以使智能指针能够解引用，而实现<code>Drop</code>则使智能指针具有自动析构的能力。</p><h4 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h4><p>Deref有一个特性是强制隐式转换：<strong>如果一个类型T实现了Deref&lt;Target=U&gt;，则该类型T的引用在应用的时候会被自动转换为类型U</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x.<span class="title function_ invoke__">chars</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你查看Rc的源码，会发现它并没有实现chars()方法，但我们上面这段代码却可以直接调用，这是因为Rc实现了Deref。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就使得智能指针在使用时被自动解引用，像是不存在一样。</p><p>Deref的内部实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="string">&quot;deref&quot;</span>]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="string">&quot;*&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="string">&quot;&amp;*&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="comment">/// The resulting type after dereferencing.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Dereferences the value.</span></span><br><span class="line">    <span class="meta">#[must_use]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[lang = <span class="string">&quot;deref_mut&quot;</span>]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="string">&quot;*&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">DerefMut</span>: Deref &#123;</span><br><span class="line">    <span class="comment">/// Mutably dereferences the value.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DerefMut和Deref类似，只不过它是返回可变引用的。</p><h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>Drop对于智能指针非常重要，它是在智能指针被丢弃时自动执行一些清理工作，这里所说的清理工作并不仅限于释放堆内存，还包括一些释放文件和网络连接等工作。之前我总是把Drop理解成Java中的GC，随着对它的深入了解后，我发现它比GC要强大许多。</p><p>Drop的内部实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="string">&quot;drop&quot;</span>]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Drop</span> &#123;</span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只有一个drop方法，实现了Drop的结构体，在消亡之前，都会调用drop方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::<span class="built_in">Drop</span>;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;drop &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">S</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;create x: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">S</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;create y: &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果为</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583204435/Blog/rust/11/rust11-1.png" alt="结果"></p><p>可以看到x和y在生命周期结束时都去执行了drop方法。</p><p>对智能指针的基本概念就先介绍到这里，下面我们进入正题，具体来看看每个智能指针都有什么特点吧。</p><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<T></h3><p>前面我们已经提到了Box<T>在Rust中是用来在堆内存中保存数据使用的。它的使用方法非常简单：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x.<span class="title function_ invoke__">chars</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看一下<code>Box::new</code>的源码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">box</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里只有一个box关键字，这个关键字是用来进行堆内存分配的，它只能在Rust源码内部使用。box关键字会调用Rust内部的exchange_malloc和box_free方法来管理内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[lang = <span class="string">&quot;exchange_malloc&quot;</span>]</span></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">exchange_malloc</span>(size: <span class="type">usize</span>, align: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        align <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">layout</span> = Layout::<span class="title function_ invoke__">from_size_align_unchecked</span>(size, align);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="title function_ invoke__">alloc</span>(layout);</span><br><span class="line">        <span class="keyword">if</span> !ptr.<span class="title function_ invoke__">is_null</span>() &#123;</span><br><span class="line">            ptr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_alloc_error</span>(layout)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(not(test), lang = <span class="string">&quot;box_free&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">box_free</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(ptr: Unique&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = ptr.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">size</span> = <span class="title function_ invoke__">size_of_val</span>(&amp;*ptr);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">align</span> = <span class="title function_ invoke__">min_align_of_val</span>(&amp;*ptr);</span><br><span class="line">    <span class="comment">// We do not allocate for Box&lt;T&gt; when T is ZST, so deallocation is also not necessary.</span></span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">layout</span> = Layout::<span class="title function_ invoke__">from_size_align_unchecked</span>(size, align);</span><br><span class="line">        <span class="title function_ invoke__">dealloc</span>(ptr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc<T></h3><p>在前面的学习中，我们知道Rust中一个值在同一时间只能有一个变量拥有其所有权，但有时我们可能会需要多个变量拥有所有权，例如在图结构中，两个图可能对同一条边拥有所有权。</p><p>对于这样的情况，Rust为我们提供了智能指针Rc<T>（reference counting）来解决共享所有权的问题。每当我们通过Rc共享一个所有权时，引用计数就会加一。当引用计数为0时，该值才会被析构。</p><p>Rc<T>是单线程引用计数指针，不是线程安全类型。</p><p>我们还是通过一个简单的例子来看一下Rc<T>的应用吧。（示例来自<a href="https://doc.rust-lang.org/book/ch15-04-rc.html">the book</a>）</p><p>如果我们想要造一个“双头”的链表，如下图所示，3和4都指向5。我们先来尝试使用Box实现。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583289009/Blog/rust/11/rust11-2.svg" alt="双头链表"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,</span><br><span class="line">                 <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,</span><br><span class="line">                               <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在编译时就会报错，因为a绑定给了b以后就无法再绑定给c了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583289016/Blog/rust/11/rust11-3.png" alt="Box无法共享所有权"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count a &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们可以看到a的引用计数是3，这是因为这里计算的是节点5的引用计数，而a本身也是对5的一次绑定。这种通过clone方法共享所有权的引用称作<strong>强引用</strong>。</p><p>Rust还为我们提供了另一种智能指针Weak<T>，你可以把它当作是Rc<T>的另一个版本。它提供的引用属于<strong>弱引用</strong>。它共享的指针没有所有权。但他可以帮助我们有效的避免循环引用。</p><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell<T></h3><p>前文中我们聊过变量的可变性和不可变性，主要是针对变量的。按照前面所讲的，对于结构体来说，我们也只能控制它的整个实例是否可变。实例的具体某个成员是否可变我们是控制不了的。但在实际开发中，这样的场景也是比较常见的。比如我们有一个User结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们只能修改一个人的名称或者年龄，而不能修改用户的id。如果我们把User的实例设置成了可变状态，那就不能保证别人不会去修改id。</p><p>为了应对这种情况，Rust为我们提供了<code>Cell&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>。它们本质上不属于智能指针，而是可以提供内部可变性的容器。内部可变性实际上是一种设计模式，它的内部是通过一些<code>unsafe</code>代码来实现的。</p><p>我们先来看一下<code>Cell&lt;T&gt;</code>的使用方法吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: Cell&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = Foo &#123; x: <span class="number">1</span>, y: Cell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, foo.x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, foo.y.<span class="title function_ invoke__">get</span>());</span><br><span class="line">    foo.y.<span class="title function_ invoke__">set</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, foo.y.<span class="title function_ invoke__">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用Cell的set/get方法来设置/获取起内部的值。这有点像我们在Java实体类中的setter/getter方法。这里有一点需要注意：<code>Cell&lt;T&gt;</code>中包裹的T必须要实现Copy才能够使用get方法，如果没有实现Copy，则需要使用Cell提供的get_mut方法来返回可变借用，而set方法在任何情况下都可以使用。由此可见Cell并没有违反借用规则。</p><p>对于没有实现Copy的类型，使用<code>Cell&lt;T&gt;</code>还是比较不方便的，还好Rust还提供了<code>RefCell&lt;T&gt;</code>。话不多说，我们直接来看代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">    x.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码中我们可以观察到<code>RefCell&lt;T&gt;</code>的borrow_mut和borrow方法对应了<code>Cell&lt;T&gt;</code>中的set和get方法。</p><p><code>RefCell&lt;T&gt;</code>和<code>Cell&lt;T&gt;</code>还有一点区别是：<code>Cell&lt;T&gt;</code>没有运行时开销（不过也不要用它包裹大的数据结构），而<code>RefCell&lt;T&gt;</code>是有运行时开销的，这是因为使用<code>RefCell&lt;T&gt;</code>时需要维护一个借用检查器，如果违反借用规则，则会引起线程恐慌。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于智能指针我们就先介绍这么多，现在我们简单总结一下。Rust的智能指针为我们提供了很多有用的功能，智能指针的一个特点就是实现了<code>Drop</code>和<code>Deref</code>这两个trait。其中<code>Drop</code>trait中提供了drop方法，在析构时会去调用。<code>Deref</code>trait提供了自动解引用的能力，让我们在使用智能指针的时候不需要再手动解引用了。</p><p>接着我们分别介绍了几种常见的智能指针。<code>Box&lt;T&gt;</code>可以帮助我们在堆内存中分配值，<code>Rc&lt;T&gt;</code>为我们提供了多次借用的能力。<code>RefCell&lt;T&gt;</code>使内部可变性成为现实。</p><p>最后再多说一点，其实我们以前见到过的<code>String</code>和<code>Vec</code>也属于智能指针。</p><p>至于它们为什么属于智能指针，Rust又提供了哪些其他的智能指针呢？这里就留个坑吧，感兴趣的同学可以自己踩一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：朝生暮死</title>
    <link href="https://jackeyzhe.github.io/2020/03/02/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%9D%E7%94%9F%E6%9A%AE%E6%AD%BB/"/>
    <id>https://jackeyzhe.github.io/2020/03/02/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%9D%E7%94%9F%E6%9A%AE%E6%AD%BB/</id>
    <published>2020-03-02T15:17:41.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天想和大家一起把我们之前挖的坑再刨深一些。在Java中，一个对象能存活多久全靠JVM来决定，程序员并不需要去关心对象的生命周期，但是在Rust中就大不相同，一个对象从生到死我们都需要掌握的很清楚。<span id="more"></span></p><p>在<a href="https://jackeyzhe.github.io/2019/10/13/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">Rust入坑指南：核心概念</a>一文中我们介绍了Rust的几个核心概念：所有权（Ownership）、所有权转移和所有权借用。今天就来介绍Rust中的另外一个核心概念：生命周期。</p><p>为什么生命周期要单独介绍呢？因为我在这之前一直没搞清楚Rust中的生命周期参数究竟是怎么一回事。</p><p>现在我终于弄明白了，于是迫不及待要和大家分享，当然如果我有什么说的不对的地方请帮忙指正。</p><p>在Rust中，值的生命周期与作用域有关，这里你可以结合所有权一起理解。在一个函数内，Rust中值的所有权的范围即为其生命周期。Rust通过借用检查器对值的生命周期进行检查，其目的是为了避免出现悬垂指针。这点很容易理解，我们通过一段简单的代码来看一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>;  <span class="comment">// &#x27;a ---------------+</span></span><br><span class="line">    &#123;                   <span class="comment">//       |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">1</span>; <span class="comment">// &#x27;b ----+   |</span></span><br><span class="line">        a = &amp;b;           <span class="comment">// |   |</span></span><br><span class="line">    &#125;<span class="comment">// ---------------------+   |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;&quot;</span>, a); <span class="comment">//     |</span></span><br><span class="line">&#125; <span class="comment">// ----------------------------+</span></span><br></pre></td></tr></table></figure><p>在上面这段代码中，我已经标注了a和b的生命周期。在代码的第5行，b将所有权出借给了a，而在第7行我们想使用a时，b的生命周期已经结束，也就是说，从第7行开始，a成为了一个悬垂指针。因此这段代码会报一个编译错误。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582994323/Blog/rust/10/rust10-1.png" alt="生命周期编译错误"></p><p>而当所有权在函数之间传递时，Rust的借用检查器就没有办法来确定值的生命周期了。这个时候我们就需要借助生命周期参数来帮助Rust的借用检查器来进行生命周期的检查。生命周期参数分为显式的和隐式的两种。</p><h3 id="显式生命周期参数"><a href="#显式生命周期参数" class="headerlink" title="显式生命周期参数"></a>显式生命周期参数</h3><p>显式生命周期的标注方式通常是<code>&#39;a</code>这样的。它应该写在<code>&amp;</code>之后，<code>mut</code>之前（如果有）。</p><h4 id="函数签名中的生命周期参数"><a href="#函数签名中的生命周期参数" class="headerlink" title="函数签名中的生命周期参数"></a>函数签名中的生命周期参数</h4><p>在正式开始学习之前，我们还要先明确一些概念。下面是一个代有生命周期参数的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span> &lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, t: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span>&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>;</span><br></pre></td></tr></table></figure><p>其中第一个<code>&#39;a</code>，是生命周期参数的声明。参数的生命周期叫做输入声明周期，返回值的生命周期叫做输出生命周期。需要记住的一点是：<strong>输出的生命周期长度不能长于输入的生命周期</strong>。</p><p>另外还要注意：<strong>禁止在没有任何输入参数的情况下返回引用</strong>。因为这样明显会造成悬垂指针。试想当你没有任何输入参数时返回了引用，那么引用本身的值在函数返回时必然会被析构，返回的引用也就成了悬垂指针。</p><p>同样的道理我们可以得出另一个结论：<strong>从函数中返回一个引用，其生命周期参数必须与函数的参数相匹配，否则，标注生命周期参数也毫无意义</strong>。</p><p>说了这么多“不允许”之后，我们来看一个正常使用生命周期参数的例子吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1_r</span> = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">the_longest</span>(s1_r, &amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is the longest&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看这段代码的各个值的生命周期是否符合我们前面说的那一点原则。在调用th_longest函数时，两个参数的生命周期已经确定，s1的生命周期贯穿了main函数，s2的生命周期在内部的代码块中。函数返回时，将返回值绑定给了res，也就是说返回的生命周期为res的生命周期，由于后定义先析构的原则，res的生命周期是短于s2的生命周期的，当然也短于s1的生命周期。因此这个例子符合了我们说的<strong>输出的生命周期长度不能长于输入的生命周期</strong>的原则。</p><p>对于像示例当中有多个参数的函数，我们也可以为其标注不同的生命周期参数，但是编译器无法确定两个生命周期参数的大小，因此需要我们显式的指定。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>&gt; (s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>&#39;b: &#39;a</code>的意思是<code>&#39;b</code>的存活周期长于<code>&#39;a</code>。这点有些令人疑惑，<code>&#39;a</code>明明是长于<code>&#39;b</code>的，为什么会这样标注呢？还记得我们说过生命周期参数的意义吗？它是用来帮助Rust借用检查器来检查非法借用的，输出生命周期必须短于输入生命周期。因此这里的<code>&#39;a</code>实际上是返回值的生命周期，而不是第一个输入参数的生命周期。</p><p>函数中的生命周期参数的使用我们暂时先介绍到这里。生命周期在其他使用场景中的使用方法也比较类似，不过还是有一些值得注意的地方的。</p><h4 id="结构体中的生命周期参数"><a href="#结构体中的生命周期参数" class="headerlink" title="结构体中的生命周期参数"></a>结构体中的生命周期参数</h4><p>如果一个结构体包含引用类型的成员，那么结构体应该声明生命周期参数<code>&lt;&#39;a&gt;</code>。这是为了保证<strong>结构体实例的生命周期应该短于或等于任意一个成员的生命周期</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcept</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;call me Ishmael. Some year ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcept &#123; part: first_sentence&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i.part, <span class="string">&quot;call me Ishmael&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中<code>first_sentence</code>先于结构体实例<code>i</code>被定义，因此<code>i</code>的生命周期是短于<code>first_sentence</code>的，如果反过来，<code>i</code>的生命周期长于<code>first_sentence</code>即长于<code>part</code>，那么在<code>part</code>被析构以后，<code>i.part</code>就会成为悬垂指针。</p><h4 id="方法中的生命周期参数"><a href="#方法中的生命周期参数" class="headerlink" title="方法中的生命周期参数"></a>方法中的生命周期参数</h4><p>现在我们为刚才的结构体增加一个实现方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcept&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_first_sentence</span>(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">first_sentence</span> = s.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">next</span>()</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">        first_sentence</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ImportantExcept</code>包含引用成员，因此需要标注生命周期参数。在<code>impl</code>后面声明生命周期参数<code>&lt;&#39;a&gt;</code>在结构体名称后面使用。在<code>get_first_sentence</code>方法中使用的生命周期参数也是刚刚定义好的那个。这样就可以约束输入引用的生命周期长度长于结构体实例的生命周期长度。</p><h4 id="静态生命周期参数"><a href="#静态生命周期参数" class="headerlink" title="静态生命周期参数"></a>静态生命周期参数</h4><p>前面聊的都是我们自己定义的生命周期参数，现在来聊聊Rust中内置的生命周期参数<code>&#39;static</code>。<code>&#39;static</code>生命周期存活于整个程序运行期间。所有的字符串字面量都有<code>&#39;static</code>生命周期，类型为<code>&amp;&#39;static str</code>。</p><h3 id="隐式生命周期参数"><a href="#隐式生命周期参数" class="headerlink" title="隐式生命周期参数"></a>隐式生命周期参数</h3><p>在某些情况下，我们可以省略生命周期参数，对于省略的生命周期参数通常有三条规则：</p><ul><li>每个输入位置上省略的生命周期都将成为一个不同的生命周期参数</li><li>如果只有一个输入生命周期的位置，则该生命周期将分配给输出生命周期</li><li>如果存在多个输入生命周期的位置，但是其中包含&amp;self或&amp;mut self，则self的生命周期将分配给输出生命周期</li></ul><h3 id="生命周期限定"><a href="#生命周期限定" class="headerlink" title="生命周期限定"></a>生命周期限定</h3><p>生命周期参数也可以像trait那样作为范型的限定</p><ul><li>T: ‘a：表示T类型中的任何引用都要“活得”和’a一样长</li><li>T：Trait + ‘a：表示T类型必须实现Trait这个trait，并且T类型中的任何引用都要“活得”和’a一样长</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我把我对Rust生命周期的了解都分享完了。其实只要记住一个原则就可以了，那就是：<strong>生命周期参数的目的是帮助借用检查器验证引用的合法性，避免出现悬垂指针</strong>。</p><p>Rust还有几个深坑，我们下次继续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想和大家一起把我们之前挖的坑再刨深一些。在Java中，一个对象能存活多久全靠JVM来决定，程序员并不需要去关心对象的生命周期，但是在Rust中就大不相同，一个对象从生到死我们都需要掌握的很清楚。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】教你用16个小时从0构建一个Rust应用</title>
    <link href="https://jackeyzhe.github.io/2020/02/23/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A816%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BB%8E0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AARust%E5%BA%94%E7%94%A8/"/>
    <id>https://jackeyzhe.github.io/2020/02/23/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A816%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BB%8E0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AARust%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-23T15:26:43.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在2019年的最后两天，参加了Prodigy Education举办的黑客马拉松，许多团队聚在一起努力将他们的想法变成现实。<span id="more"></span></p><p>我们之中有的人只是单纯为了好玩，有的是想学一些新的知识，还有些人可能是想证明一些概念或想法。</p><p>我在过去几周总是被动的获取Rust相关信息或使用Rust的代码，因此我认为hackathon是一次学习Rust的绝佳时机。</p><p>hackathon的时间紧迫性使我更加快速的去学习，同时也会去解决现实世界的一些问题。</p><h3 id="为什么是Rust"><a href="#为什么是Rust" class="headerlink" title="为什么是Rust"></a>为什么是Rust</h3><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370825/Blog/Other/learn_rust/lr-2.jpg" alt="Getting a chance to peek under the hood again"></p><p>在我职业生涯的前10年中，有8年都在使用C和C++。</p><p>从好的方面来讲，我喜欢像C++这样可以提供静态类型的语言，因为它能在编译期就能够早早的发现错误。</p><p>我个人对于C++的一些看法是：</p><ul><li>工程师很容易搬起石头砸自己的脚</li><li>作为一门编程语言，它已经非常臃肿且复杂</li><li>缺乏良好的、标准的广泛适用的包管理系统</li></ul><p>自从我改做Web应用以来，一直是做Python和JavaScript开发，使用像Django、Flask和Express这样的框架。</p><p>到目前为止，我在Python和JavaScript中的开发经验是，它们可以提供良好的程序迭代和交付速度，但有时会占用大量的CPU和内存，即使服务是相对空闲的。</p><p>我经常发现自己写好的C++程序，会缺失一些安全性、速度和精简性。</p><p>我想要寻找一种像Rust这样精简的、裸机编程语言来开发web应用。</p><p>没有运行时，没有垃圾回收。直接加载二进制代码，交给内核执行。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我的目标是完成一个后端由Rust编写，前端是JavaScript+React完成的类似于S3作为图床的应用程序，用户可以做以下事情：</p><ul><li>浏览图床中所有的图片（分页可选）</li><li>上传图片</li><li>上传图片时可以给图片增加标签</li><li>通过名称进行查询或过滤</li></ul><p>所有有趣的hackathon项目都有一个名字，所以我决定将这个项目命名为：</p><p>RustIC -&gt; Rust + Image Contents</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370820/Blog/Other/learn_rust/lr3.jpg" alt="Let’s hack something great"></p><p>我认为如果我做到了以下这些事情，那么这次hackathon之行对我个人来说就是成功的：</p><ul><li>对Rust有一个基本的理解，包括它的类型系统和内存模型</li><li>探索S3的对于文件和任意标签的预签名链接功能</li><li>写出一个可以验证的功能正常的应用</li></ul><p>由于我的主要目标是开发功能，同时兼顾学习。很多代码是我一边学一边写的，所以代码组织和效率可能并不是最理想的，因为这些属于次要目标。</p><h3 id="Rust的原则"><a href="#Rust的原则" class="headerlink" title="Rust的原则"></a>Rust的原则</h3><p>在我开始之前，我带着好奇心去了解了要学习的语言的设计师在创建这门语言时内心的原则是什么。我找到了一个<a href="https://doc.rust-lang.org/1.4.0/complement-design-faq.html">简化版本</a>和一个<a href="https://github.com/dtolnay/rust-faq">详细版本</a>。</p><p>与我在许多博客上读到的内容相反，Rust是有可能发生内存泄露（循环引用）和之行不安全的操作（unsafe代码块中）的，详细描述在上面的FAQ中。</p><blockquote><p><em>“We [the language creators] do not intend [for Rust] to be 100% static, 100% safe, 100% reflective.”</em></p></blockquote><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370827/Blog/Other/learn_rust/lr-4.jpg" alt="Dazzling, intricate, sophisticated"></p><h3 id="从后端开始"><a href="#从后端开始" class="headerlink" title="从后端开始"></a>从后端开始</h3><p>Google搜索“Rust web framework“，排在最前面的是<a href="https://rocket.rs/">Rocket</a>。我进入这个网站，发现文档的示例都一目了然。</p><p>有一点需要注意的是Rocket需要Rust的nightly版本，不过在hackathon上这都是小问题。</p><p>GitHub的<a href="https://github.com/SergioBenitez/Rocket/tree/v0.4">代码库</a>中有着非常丰富的例子。完美！</p><p>我使用<a href="https://doc.rust-lang.org/cargo/">Cargo</a>创建了一个新的项目，在TOML文件中加入了Rocket依赖，然后跟着Rocket的<a href="https://rocket.rs/v0.4/guide/getting-started/">入门指南</a>，写了第一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    rocket::<span class="title function_ invoke__">ignite</span>().<span class="title function_ invoke__">mount</span>(<span class="string">&quot;/&quot;</span>, routes![index]).<span class="title function_ invoke__">launch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于熟悉Django、Flask、Express等框架等同学来说，这段代码读起来非常容易。作为一名Rocket用户，你可以使用宏作为装饰器来将路由映射到对应的处理函数上。</p><p>在编译时，宏将被扩展。这对开发者是完全透明的。如果你想看扩展后的代码，可以使用<a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a>。</p><p>以下是我在构建Rust应用程序时的一些有趣的或者有挑战性的亮点：</p><h4 id="指定路由响应"><a href="#指定路由响应" class="headerlink" title="指定路由响应"></a>指定路由响应</h4><p>我想要以JSON的数据格式返回S3中所有的文件列表。</p><p>你可以看到路由关联的处理函数的代码决定了响应类型。</p><p>设置响应结构非常容易，如果你想要返回JSON格式的数据，并且每个字段都有自己的结构和类型，那对应的就是Rust的<code>struct</code>。</p><p>所以你应该先定义一个结构体<code>struct(S)</code>来接受响应，并且需要进行标注：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Serialize)]</span></span><br></pre></td></tr></table></figure><p>struct(s)被标记了<code>#[derive(Serialize)]</code>，因此可以通过<code>rocket_contrib::json::Json将它转换成JSON</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Serialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BucketContents</span> &#123;</span><br><span class="line">    data: <span class="type">Vec</span>&lt;S3Object&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S3Object</span> &#123;</span><br><span class="line">    file_name: <span class="type">String</span>,</span><br><span class="line">    presigned_url: <span class="type">String</span>,</span><br><span class="line">    tags: <span class="type">String</span>,</span><br><span class="line">    e_tag: <span class="type">String</span>, <span class="comment">// AWS generated MD5 checksum hash for object</span></span><br><span class="line">    is_filtered: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="string">&quot;/contents?&lt;filter&gt;&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_bucket_contents</span>(</span><br><span class="line">    filter: <span class="type">Option</span>&lt;&amp;RawStr&gt;</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Json&lt;BucketContents&gt;, Custom&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Returns either Ok(Json(BucketContents)) or,</span></span><br><span class="line">    <span class="comment">// a Custom error with a reason</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理分段上传"><a href="#处理分段上传" class="headerlink" title="处理分段上传"></a>处理分段上传</h4><p>当我意识到我的前端很有可能使用POST方法上传格式为<code>multipart/form-data</code>的表单数据时，我就开始深入研究如何使用Rocket来构建程序了。</p><p>不幸的是，Rocket0.4版本不支持multipart，看起来在0.5版本会支持。</p><p>这意味着我需要使用<a href="https://crates.io/crates/multipart">multipart</a> crate并集成到Rocket中。最终代码可以正常运行，但是如果Rocket支持multipart将会使代码更加简洁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[post(<span class="string">&quot;/upload&quot;</span>, data = <span class="string">&quot;&lt;data&gt;&quot;</span>)]</span></span><br><span class="line"><span class="comment">// signature requires the request to have a `Content-Type`. The preferred way to handle the incoming</span></span><br><span class="line"><span class="comment">// data would have been to use the FromForm trait as described here: https://rocket.rs/v0.4/guide/requests/#forms</span></span><br><span class="line"><span class="comment">// Unfortunately, file uploads are not supported through that mechanism since a file upload is performed as a</span></span><br><span class="line"><span class="comment">// multipart upload, and Rocket does not currently (As of v0.4) support this. </span></span><br><span class="line"><span class="comment">// https://github.com/SergioBenitez/Rocket/issues/106</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">upload_file</span>(cont_type: &amp;ContentType, data: Data) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Custom&lt;<span class="type">String</span>&gt;, Custom&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// this and the next check can be implemented as a request guard but it seems like just</span></span><br><span class="line">    <span class="comment">// more boilerplate than necessary</span></span><br><span class="line">    <span class="keyword">if</span> !cont_type.<span class="title function_ invoke__">is_form_data</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="title function_ invoke__">Custom</span>(</span><br><span class="line">            Status::BadRequest,</span><br><span class="line">            <span class="string">&quot;Content-Type not multipart/form-data&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (_, boundary) = cont_type.<span class="title function_ invoke__">params</span>()</span><br><span class="line">                                 .<span class="title function_ invoke__">find</span>(|&amp;(k, _)| k == <span class="string">&quot;boundary&quot;</span>)</span><br><span class="line">                                 .<span class="title function_ invoke__">ok_or_else</span>(</span><br><span class="line">        || <span class="title function_ invoke__">Custom</span>(</span><br><span class="line">            Status::BadRequest,</span><br><span class="line">            <span class="string">&quot;`Content-Type: multipart/form-data` boundary param not provided&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">        )</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The hot mess that ensues is some weird combination of the two links that follow</span></span><br><span class="line">    <span class="comment">// and a LOT of hackery to move data between closures.</span></span><br><span class="line">    <span class="comment">// https://github.com/SergioBenitez/Rocket/issues/106</span></span><br><span class="line">    <span class="comment">// https://github.com/abonander/multipart/blob/master/examples/rocket.rs</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">d</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    data.<span class="title function_ invoke__">stream_to</span>(&amp;<span class="keyword">mut</span> d).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Unable to read&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mp</span> = Multipart::<span class="title function_ invoke__">with_body</span>(Cursor::<span class="title function_ invoke__">new</span>(d), boundary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">categories_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">raw_file_data</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    mp.foreach_entry(|<span class="keyword">mut</span> entry| &#123;</span><br><span class="line">        <span class="keyword">if</span> *entry.headers.name == *<span class="string">&quot;fileName&quot;</span> &#123; </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">file_name_vec</span> = entry.data.<span class="title function_ invoke__">fill_buf</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">            file_name = <span class="title function_ invoke__">from_utf8</span>(&amp;file_name_vec).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> *entry.headers.name == *<span class="string">&quot;tags&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tags_vec</span> = entry.data.<span class="title function_ invoke__">fill_buf</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">            categories_string = <span class="title function_ invoke__">from_utf8</span>(&amp;tags_vec).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> *entry.headers.name == *<span class="string">&quot;file&quot;</span> &#123;</span><br><span class="line">            raw_file_data = entry.data.<span class="title function_ invoke__">fill_buf</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_owned</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Unable to iterate&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3_file_manager</span> = s3_interface::S3FileManager::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>);</span><br><span class="line">    s3_file_manager.<span class="title function_ invoke__">put_file_in_bucket</span>(file_name.<span class="title function_ invoke__">clone</span>(), raw_file_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tag_name_val_pairs</span> = <span class="built_in">vec!</span>[(<span class="string">&quot;tags&quot;</span>.<span class="title function_ invoke__">to_string</span>(), categories_string)];</span><br><span class="line">    s3_file_manager.<span class="title function_ invoke__">put_tags_on_file</span>(file_name, tag_name_val_pairs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(</span><br><span class="line">        <span class="title function_ invoke__">Custom</span>(Status::<span class="literal">Ok</span>, <span class="string">&quot;Image Uploaded&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置CORS"><a href="#配置CORS" class="headerlink" title="配置CORS"></a>配置CORS</h4><p>路由写好了以后，我就开始用curl或Postman来进行测试了，现在已经是时候开始把前端集成进来了。我需要适当设置响应头以避免跨域问题。</p><p>Rocket依旧没有支持这个特性。</p><p>然后我在GitHub代码库中找到了一些解决方案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CORS Solution below comes from: https://github.com/SergioBenitez/Rocket/issues/25</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io::Cursor;</span><br><span class="line"><span class="keyword">use</span> rocket::fairing::&#123;Fairing, Info, Kind&#125;;</span><br><span class="line"><span class="keyword">use</span> rocket::&#123;Request, Response&#125;;</span><br><span class="line"><span class="keyword">use</span> rocket::http::&#123;Header, ContentType, Method&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CORS</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fairing</span> <span class="keyword">for</span> <span class="title class_">CORS</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">info</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Info &#123;</span><br><span class="line">        Info &#123;</span><br><span class="line">            name: <span class="string">&quot;Add CORS headers to requests&quot;</span>,</span><br><span class="line">            kind: Kind::Response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_response</span>(&amp;<span class="keyword">self</span>, request: &amp;Request, response: &amp;<span class="keyword">mut</span> Response) &#123;</span><br><span class="line">        <span class="keyword">if</span> request.<span class="title function_ invoke__">method</span>() == Method::Options || </span><br><span class="line">           response.<span class="title function_ invoke__">content_type</span>() == <span class="title function_ invoke__">Some</span>(ContentType::JSON) || </span><br><span class="line">           response.<span class="title function_ invoke__">content_type</span>() == <span class="title function_ invoke__">Some</span>(ContentType::Plain) &#123;</span><br><span class="line"></span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(Header::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:3000&quot;</span>));</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(Header::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS&quot;</span>));</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(Header::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>));</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(Header::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> request.<span class="title function_ invoke__">method</span>() == Method::Options &#123;</span><br><span class="line">            response.<span class="title function_ invoke__">set_header</span>(ContentType::Plain);</span><br><span class="line">            response.<span class="title function_ invoke__">set_sized_body</span>(Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    rocket::<span class="title function_ invoke__">ignite</span>().<span class="title function_ invoke__">attach</span>(</span><br><span class="line">        <span class="title function_ invoke__">CORS</span>()</span><br><span class="line">    ).<span class="title function_ invoke__">mount</span>(</span><br><span class="line">        <span class="string">&quot;/&quot;</span>, </span><br><span class="line">        routes![get_bucket_contents, upload_file]</span><br><span class="line">    ).<span class="title function_ invoke__">launch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过了一会，我发现了<a href="https://crates.io/crates/rocket_cors">rocket_cors</a>，它帮助我大幅缩减了代码量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">allowed_origins</span> = AllowedOrigins::<span class="title function_ invoke__">some_exact</span>(&amp;[<span class="string">&quot;http://localhost:3000&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cors</span> = rocket_cors::CorsOptions &#123;</span><br><span class="line">        allowed_origins,</span><br><span class="line">        allowed_methods: <span class="built_in">vec!</span>[Method::Get, Method::Post].<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(<span class="built_in">From</span>::from).<span class="title function_ invoke__">collect</span>(),</span><br><span class="line">        allowed_headers: AllowedHeaders::<span class="title function_ invoke__">some</span>(&amp;[<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Accept&quot;</span>]),</span><br><span class="line">        allow_credentials: <span class="literal">true</span>,</span><br><span class="line">        ..<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="title function_ invoke__">to_cors</span>()?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rocket::<span class="title function_ invoke__">ignite</span>().<span class="title function_ invoke__">attach</span>(cors)</span><br><span class="line">                    .<span class="title function_ invoke__">mount</span>(<span class="string">&quot;/&quot;</span>, routes![get_bucket_contents, upload_file])</span><br><span class="line">                    .<span class="title function_ invoke__">launch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h4><p>我们只需要一个简单的<code>cargo run</code>命令就可以让程序运行起来</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370830/Blog/Other/learn_rust/lr-5.png" alt="output"></p><p>我机器上的活动监视器告诉我这个程序正在运行中，并且只消耗了2.7MB内存。</p><p>而且这还只是没有经过优化的调试版本。项目使用<code>- release</code>标签打包的话，运行时只需要1.6MB内存。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370814/Blog/Other/learn_rust/lr-6.png" alt="memory"></p><p>基于Rust的后端服务器，我们请求<code>/contents</code>这个路由会得到如下响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;file_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Duck.gif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presigned_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://s3.amazonaws.com/rustic-images/Duck.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050353Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=1369c003b2f54510882bf9982ab56d024d6c9d2655a4d86f8907313c7499b56d&amp;X-Amz-SignedHeaders=host&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;animal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e_tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\&quot;93c570cadd6b8b2f85b47c2f14fd82a1\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;is_filtered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;file_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GIZMO.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presigned_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://s3.amazonaws.com/rustic-images/GIZMO.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050353Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=040e76c2df5a9a54ed4fbc8490378cf732b32bae78f628448536fc610018c0c3&amp;X-Amz-SignedHeaders=host&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;robots&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e_tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\&quot;2cde221a0c7a72c0a7a60cffce29a0bc\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;is_filtered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;file_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GreenSmile.gif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presigned_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://s3.amazonaws.com/rustic-images/GreenSmile.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050354Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=d115b107de530ce15b3590abdbab355c2a9481a81131f88bf4ad2a59ca11bbac&amp;X-Amz-SignedHeaders=host&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smile-face&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;e_tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\&quot;86854a599540f50bdc5e837d30ca34f9\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;is_filtered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>前端的工作相对简单一些，我们使用的是：</p><ul><li>React</li><li>React Bootstrap</li><li>react-grid-gallery</li><li>react-tags-input</li></ul><p>用户可以在我们的页面浏览图片，也可以通过文件名或标签来进行检索或过滤。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370817/Blog/Other/learn_rust/lr-7.png" alt="images"></p><p>用户还可以通过拖拽来上传文件，并且可以在提交上传之前打上标签。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370815/Blog/Other/learn_rust/lr-8.png" alt="upload"></p><h3 id="我喜欢使用Rust构建应用程序的原因"><a href="#我喜欢使用Rust构建应用程序的原因" class="headerlink" title="我喜欢使用Rust构建应用程序的原因"></a>我喜欢使用Rust构建应用程序的原因</h3><ul><li>Cargo对于依赖和应用管理的程度简直令人惊叹</li><li>编译器对于我们处理编译错误帮助非常大，有位博主在<a href="https://dmerej.info/blog/post/letting-the-compiler-tell-you-what-to-do/">博客</a>中描述了他是如何按照编译器大指导来写代码的。我的经验也比较类似。</li><li>我需要的每一项功能都有crate，这让我感到非常惊喜</li></ul><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370831/Blog/Other/learn_rust/lr-9.jpg" alt="Crates galore on crates.io! "></p><ul><li>在线的<a href="https://play.rust-lang.org/">Rust Playground</a>，让我可以运行小的代码片段。</li><li>Rust语言服务器，已经很好的集成到了Visual Studio Code，它能够提供实时错误检查、格式设置、符号查找等。这让我可以在几个小时内不编译就能取得不错的进展。</li></ul><h3 id="不便、惊喜和麻烦"><a href="#不便、惊喜和麻烦" class="headerlink" title="不便、惊喜和麻烦"></a>不便、惊喜和麻烦</h3><p>尽管Rust的文档很棒，但我不得不依赖一些crates的文档和例子。有些crates有很棒的集成测试，提供了一些关于如何使用的提示。当然了，Stack Overflow和Reddit也给我提供了很多帮助。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370822/Blog/Other/learn_rust/lr-10.jpg" alt="“Where’s the documentation?”"></p><p>另外还要注意的是：</p><ul><li>理解所有权、生命周期和所有权借用会使学习难度陡增，特别是在为期两天的黑客马拉松中努力提供功能时。我将它们与C++做比较并且弄清楚，但有时还是会感到困惑。</li><li>在所有的事情中，<code>Strings</code>拦住了我几分钟，特别是<code>String</code>和<code>&amp;str</code>的区别更是令人困惑——直到我花了些时间来理解所有权、生命周期和所有权借用才搞清楚这些。</li></ul><h3 id="其他的一些观察"><a href="#其他的一些观察" class="headerlink" title="其他的一些观察"></a>其他的一些观察</h3><ul><li>Rust中没有真正意义上的null类型，通常情况下，空值需要用<code>Option</code>类型的<code>None</code>来表示</li><li>模式匹配非常棒，这是我在Scala中最喜欢的一个特性，在Rust中也一样。这种代码看起来表现力很强，并且允许编译器标记未处理的情况。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> bucket_contents &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(why) =&gt; <span class="keyword">match</span> why &#123;</span><br><span class="line">        S3ObjectError::FileWithNoName =&gt; <span class="title function_ invoke__">Err</span>(<span class="title function_ invoke__">Custom</span>(</span><br><span class="line">            Status::InternalServerError,</span><br><span class="line">            <span class="string">&quot;Encountered bucket objects with no name&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">        )),</span><br><span class="line">        S3ObjectError::MultipleTagsWithSameName =&gt; <span class="title function_ invoke__">Err</span>(<span class="title function_ invoke__">Custom</span>(</span><br><span class="line">            Status::InternalServerError,</span><br><span class="line">            <span class="string">&quot;Encountered a file with a more than one tag named &#x27;tags&#x27;&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">        ))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s3_objects) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">visible_s3_objects</span>: <span class="type">Vec</span>&lt;S3Object&gt; = s3_objects.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">                                                          .<span class="title function_ invoke__">filter</span>(|obj| !obj.<span class="title function_ invoke__">is_hidden</span>())</span><br><span class="line">                                                          .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Json</span>(BucketContents::<span class="title function_ invoke__">new</span>(visible_s3_objects)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说起安全和不安全模式，你仍然可以进行更底层的编程，比如说在不安全的模式下可以和C语言代码通过接口交互。尽管Rust中有很多正确性检查，但你仍然可以在不安全模块中做一些骚操作，例如解引用。读代码的人也可以从不安全模块中获取到很多信息。</li><li>通过<code>Box</code>在堆中分配内存空间，而不是<code>new</code>和<code>delete</code>。刚开始感觉比较奇怪，但是也很容易理解。标准库中还定义了其他的一些<a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">智能指针</a>，如果你需要使用引用数量或者弱引用时就可以直接使用。</li><li>Rust中的异常也很有趣，因为它没有异常。你可以选择使用<code>Result&lt;T, E&gt;</code>表示可以恢复的错误，也可以用<code>panic!</code>宏表示不可恢复的错误。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This code:</span></span><br><span class="line"><span class="comment">// 1. Takes a vector of objects representing S3 contents</span></span><br><span class="line"><span class="comment">// 2. Uses filter to remove entries we don&#x27;t care about</span></span><br><span class="line"><span class="comment">// 3. Uses map to transform each object into another type, but terminates iteration</span></span><br><span class="line"><span class="comment">// .  if the lambda passed to map returns an Err. </span></span><br><span class="line"><span class="comment">// 4. If all iterations produced an Ok(S3Object) result, these are collected into a Vec&lt;S3Object&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bucket_contents</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;S3Object&gt;, S3ObjectError&gt; = bucket_list</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|bucket_obj| bucket_obj.size.<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>) != <span class="number">0</span>) <span class="comment">// Eliminate folders</span></span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|bucket_obj| &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">None</span> = bucket_obj.key &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(S3ObjectError::FileWithNoName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">file_name</span> = bucket_obj.key.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">e_tag</span> = bucket_obj.e_tag.<span class="title function_ invoke__">unwrap_or</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tag_req_output</span> = s3_file_manager.<span class="title function_ invoke__">get_tags_on_file</span>(file_name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tags_with_categories</span>: <span class="type">Vec</span>&lt;Tag&gt; = tag_req_output.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">                                                            .<span class="title function_ invoke__">filter</span>(|tag| tag.key == <span class="string">&quot;tags&quot;</span>)</span><br><span class="line">                                                            .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">            <span class="keyword">if</span> tags_with_categories.<span class="title function_ invoke__">len</span>() &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(S3ObjectError::MultipleTagsWithSameName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tag_value</span> = <span class="keyword">if</span> tags_with_categories.<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tags_with_categories[<span class="number">0</span>].value.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">presigned_url</span> = s3_file_manager.<span class="title function_ invoke__">get_presigned_url_for_file</span>(</span><br><span class="line">                file_name.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">            );</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(S3Object::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                file_name,</span><br><span class="line">                e_tag,</span><br><span class="line">                tag_value,</span><br><span class="line">                presigned_url,</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">            ))</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure><p>手册中是这样描述的：</p><blockquote><p>在多数情况下，Rust需要你尽可能了解错误，并且在编译之前对其做出相应的处理。这个需求使你的程序更加健壮，保证你在发布之前就可以发现并处理其中的错误。</p></blockquote><h3 id="要点和教训"><a href="#要点和教训" class="headerlink" title="要点和教训"></a>要点和教训</h3><ul><li>John Carmack曾经将编写Rust的经历描述为“非常有益”。我同意这种感受，这次hackathon给我的感觉就像是打开了一扇新世界的大门并且发现了很多新鲜事物，这些收获绝不仅仅是停留在代码层面的。</li><li>事后看来，我应该更加严谨的选择网络框架的。再多想一下的话，我可能会走出一条不同的道路。我下次可能会选择<a href="http://ironframework.io/">iron</a>、<a href="https://actix.rs/">actix-web</a>, 或者是 <a href="https://github.com/tiny-http/tiny-http">tiny-http</a>。</li><li>我只学到了Rust的皮毛，16个小时是不可能完全成为一名Rustacean的，即使我对这门语言充满了好奇心，也做了一些深入的了解。我对Rust的未来感到兴奋，我认为它为构建应用程序带来了很多规范，它是一种表现力非常丰富的语言，并且能为我们提供与C++性能相当的运行速度和内存性能呢。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="https://github.com/sidshank/rustic-backend">RustIC后端代码</a></p><p><a href="https://github.com/sidshank/rustic-frontend">RustIC前端代码</a></p><p><a href="https://www.rusoto.org/">Rusoto：一个Rust的AWS SDK</a></p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://medium.com/better-programming/learning-to-use-rust-over-a-16-hour-hackathon-5f0ac2f604df">https://medium.com/better-programming/learning-to-use-rust-over-a-16-hour-hackathon-5f0ac2f604df</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在2019年的最后两天，参加了Prodigy Education举办的黑客马拉松，许多团队聚在一起努力将他们的想法变成现实。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：步步为营</title>
    <link href="https://jackeyzhe.github.io/2020/02/21/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%AD%A5%E6%AD%A5%E4%B8%BA%E8%90%A5/"/>
    <id>https://jackeyzhe.github.io/2020/02/21/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%AD%A5%E6%AD%A5%E4%B8%BA%E8%90%A5/</id>
    <published>2020-02-20T16:05:43.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说：“测试写得好，奖金少不了。”<span id="more"></span></p><p>有经验的开发人员通常会通过单元测试来保证代码基本逻辑的正确性。如果你是一名新手开发者，并且还没体会到单元测试的好处，那么建议你先读一下我之前的一篇文章<a href="https://jackeyzhe.github.io/2018/09/04/%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9C%B0%E4%BD%8D/">代码洁癖系列（七）：单元测试的地位</a>。</p><p>写单元测试一般需要三个步骤：</p><ol><li>准备测试用例，测试用例要能覆盖尽可能多的代码</li><li>执行需要测试的代码</li><li>判断结果，是否是你希望得到的结果</li></ol><p>了解了这些以后，我们就来看看在Rust中应该怎么写单元测试。</p><p>首先我们建立一个library项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new adder --lib</span><br><span class="line">     Created library `adder` project</span><br></pre></td></tr></table></figure><p>然后在src/lib.rs文件中开始写测试代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在命令行运行<code>cargo test</code>就会得到测试结果</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582124140/Blog/rust/09/rust9-1.png" alt="测试结果1"></p><p>可以看到，结果显示，Rust运行了一项测试并且测试通过。后面的Doc-tests我们先放下，以后再聊。</p><p>当然，这并不是我们常见的测试，在日常开发中，我们通常是先写我们的业务代码然后再对各个函数进行单元测试，最后还会对某个模块进行集成测试。那么我们就来模拟一下日常开发过程中应该如何来写测试。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>我们仍然是用上面的项目，先来在src/lib.rs中写一段“业务代码”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的代码，对外暴露的函数只是一个加2的功能，内部调用了一个两数相加的函数。现在我们就对这个内部函数做一个单元测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试模块中，如果想要使用我们业务代码中的函数，就需要通过<code>use super::*;</code>将其引入可用范围。接着，还是执行<code>cargo test</code>，测试结果与刚才类似。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582125779/Blog/rust/09/rust9-2.png" alt="测试结果2"></p><p>测了半天全是通过的没什么意思，单元测试真正的作用是要发现代码中的问题，所以我们来尝试一个错误的试一下。假设我们希望2+2等于5。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582127769/Blog/rust/09/rust9-3.png" alt="测试结果3"></p><p>这里我们的assert_eq!左右不相等，引起了线程恐慌，因此导致测试失败。结果中给出了失败的原因，引起失败的位置，并且有一句提示：<code>note: run with RUST_BACKTRACE=1 environment variable to display a backtrace.</code> 我们按照这个提示，设置变量RUST_BACKTRACE=1，此时再执行<code>cargo test</code>。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582128445/Blog/rust/09/rust9-4.png" alt="错误栈"></p><p>Rust就会将错误栈打印出来，根据结果提示，这并不是完整的错误栈，我们还可以将RUST_BACKTRACE设置为full来查看更加详细的信息。这里我就不做演示了。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>接下来我们再演示一下集成测试。我们通常将集成测试单独放到一个目录中，在lib.rs文件中，rust识别测试mod的名称是tests，同样的，我们在src下创建tests目录。<strong>tests</strong>目录下就是我们的所有集成测试代码。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582129708/Blog/rust/09/rust9-5.png" alt="测试目录"></p><p>如图，integration_test是我们测试代码的文件，common目录下的mod.rs文件中是一些集成测试必要的配置。这里我们只是放了一个空的setup函数。</p><p>在集成测试中，我们就要像正常他人使用我们的代码时那样来进行测试，首先需要将我们的mod引入到可用范围，当然还需要加上common的mod。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tests]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就可以测试我们对外暴露的函数了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582130013/Blog/rust/09/rust9-6.png" alt="集成测试"></p><p>ok，集成测试的方法我们也掌握了。现在来看看一直被我们忽略的Doc-tests吧。</p><h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p>我们已经知道，Rust中的注释是双斜线<code>//</code>，像我们刚刚写的library代码，如果想要把它发布到crate.io上让别人使用，那么我们就需要增加相应的文档，这里文档的每行都应该是三斜线<code>///</code>开头，而文档中也应该放一些例子供他人参考。（注意：下面注释中的代码需要包含在markdown的代码块格式中，这里写上三个`的话文档格式会乱掉。。。运行测试代码时请自行补充）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds two to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = adder::add_two(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(7, answer);</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我给add_two函数加上了文档，我们再次执行<code>cargo test</code>命令。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582131276/Blog/rust/09/rust9-7.png" alt="文档测试"></p><p>现在我们就明白了，Doc-tests测试就是运行我们文档中的例子。</p><h3 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h3><p>到目前为止，我们已经知道了在Rust中如何写测试代码了。接下来我们再来了解几个比较常用的特性。</p><h4 id="运行指定的测试代码"><a href="#运行指定的测试代码" class="headerlink" title="运行指定的测试代码"></a>运行指定的测试代码</h4><p>我们在开发过程中肯定不会每次都去跑全量的单元测试，那样太浪费时间了。通常是我们开发完一个功能之后，编写对应的单元测试，然后单独跑这个测试。那么Rust中能不能单独跑一个单元测试呢？答案是肯定的。</p><p>相信细心的同学已经发现了，Rust测试结果中，是针对每个测试单独统计结果，并且每个测试都有自己的名字，像我们前面写的<code>it_works</code>和<code>internal</code>。假设我们的代码中同时存在这两个函数，如果你想要单独跑internal这一个测试，就可以使用<code>cargo test internal</code>命令。</p><p>你也可以使用这种方法来执行多个名称类似的测试，假如我们有名称为<code>internal_a</code>的测试，那么执行<code>cargo test internal</code>命令时它也会被执行。</p><h4 id="忽略某个测试"><a href="#忽略某个测试" class="headerlink" title="忽略某个测试"></a>忽略某个测试</h4><p>当我们有一个测试执行时间非常长的时候，我们一般不会轻易去执行，这时如果你想要执行多个测试，除了用我们上面提到的方法，去指定不同的名称列表以外。还可以把这个测试忽略掉。</p><p>现在我不想执行<code>internal</code>测试了，只需要对代码进行如下改动：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时再来运行测试，结果如图所示。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582212742/Blog/rust/09/rust9-8.png" alt="忽略测试"></p><p>我们发现此时<code>internal</code>测试已经被忽略了。</p><h4 id="测试异常情况"><a href="#测试异常情况" class="headerlink" title="测试异常情况"></a>测试异常情况</h4><p>除了测试代码逻辑正常的情况，我们有时还需要测试一些异常情况，比如接收到非法参数时程序能否返回我们希望看到的异常。</p><p>我们首先来看一下如何测试程序返回异常信息。</p><p>Rust为我们提供了一个叫做should_panic的注解。我们可以使用它来测试程序是否返回异常：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;a should bigger than 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(-<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们运行测试时就会发现internal测试通过，因为它发生了线程恐慌，这是我们希望看到的结果。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582213602/Blog/rust/09/rust9-9.png" alt="测试异常"></p><p>另外，我们还可以再指定我们具体期望的异常，那么就可以在should_panic后面加上expected参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;a should be positive&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(-<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以自行运行一下这段测试代码看看效果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文中我向大家介绍了在Rust中如何进行单元测试、集成测试，还有比较特殊的文档测试。最后还介绍了3种常见的测试特性。</p><p>最后想友情提醒大家一下，在开发过程中，不要写完一堆功能后再开始写单元测试，这时你很有可能会因为测试代码过于繁琐而放弃。建议大家每写一个功能，随即开始进行单元测试，这样也能立即看到自己的代码的执行效果，提高成就感。这就是所谓的“步步为营”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;俗话说：“测试写得好，奖金少不了。”</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】感谢你的Code Review</title>
    <link href="https://jackeyzhe.github.io/2020/02/17/%E3%80%90%E8%AF%91%E3%80%91%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84Code-Review/"/>
    <id>https://jackeyzhe.github.io/2020/02/17/%E3%80%90%E8%AF%91%E3%80%91%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84Code-Review/</id>
    <published>2020-02-17T14:52:18.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名初级工程师，当我看到一些问题时，通常会主动去解决它们，因此我总会进行一些大范围的代码修改。<span id="more"></span></p><p>这意味着我需要发出大量的代码审查。在一次修改中通常会涉及到从UI到数据库的所有部分。</p><p>我对于自己能够维护整个系统而骄傲，也为自己的快速处理问题的能力而骄傲。同时也为自己的勇敢和解决重大问题的能力而自豪。</p><p>直到有一天，一位资深工程师把我拉到一边，给我提出了迄今为止我收到过最好的代码审查返回。它告诉我应该将巨型的代码审查拆分为更小的增量修改。</p><p>我第一反应是感到恼怒。我不理解他为什么要我这么做。我对自己解决重大问题的能力非常有信心！为什么他说我的工作做的不好？！一点一点的进行修改只会拖慢我的脚步！</p><p>虽然当时我还不知道小规模、增量修改的种种好处，但是我很庆幸当时听了这位高级工程师的意见，很高兴我开始学着进行小规模、增量的修改。</p><p>这种方法给我后来的职业生涯带来了巨大的好处。</p><h3 id="增量修改的好处"><a href="#增量修改的好处" class="headerlink" title="增量修改的好处"></a>增量修改的好处</h3><p>进行增量修改有诸多好处，下面我来列举一些。</p><ul><li><strong>更少的合并冲突。</strong>你改的文件越多，和其他人的修改发生冲突的可能性就越大，小规模的修改可以有效的避免冲突，即使有冲突时也能更快的解决。</li><li><strong>更快的代码审查。</strong>对代码审查人员来说，审查5个文件无疑要比审查50多个文件轻松许多。与那些需要面对面交谈十分钟才能开始看的代码相比，小规模的修改能够更快速的开始审查并且更容易解释。当审查人员面对大量的代码审查工作时，他们有可能会犯懒，非常希望能找个人替他们完成这项工作。因此你可能需要花费很长时间才能找到一个愿意审查你的代码的人。</li><li><strong>更早的修正。</strong>你的代码审查者可能与你的思路相左。他们可能会要求你重做所有的事情。如果你之前只花了几个小时进行修改，那么这对你来说可能不是什么大问题。但是如果你在这个问题上已经花费了两天时间，那么重做可能是一件非常痛苦的事情。</li><li><strong>更快速的测试。</strong>如果你的代码修改涉及到了从UI到数据库的所有层级，你可能需要对整个产品进行重新测试。而如果你只进行小规模修改，那就只需要测试你所修改的那部分。如果你需要解决很多代码审查反馈或者是合并很多代码时，这种好处就非常明显了。重新测试所有东西会花费大量的时间，特别是手动测试。</li><li><strong>更少的bug。</strong>小规模修改意味着你不需要同时将所有东西都装进脑子里。你可以专注于你进行优化的这一部分代码，保证你可以把它做到最好。（我曾经见过一个工程师，它对自己的大规模改动感到不知所措，后来他养成了检查和修复都追求完美的习惯。希望你不要成为那样的人，即使没人抱怨，但是你的同事将会慢慢变得不信任你的代码。）</li><li><strong>更容易排除故障。</strong>如果你需要改动一些代码，那么小规模的改动可以帮助你更加容易的定位问题。</li><li><strong>增量部署。</strong>如果你想要不停机更新，那么更小的、增量的改动会帮助你解决这个问题。（但这并不是全部解决方法）</li><li><strong>还原更加简单。</strong>当你写了bug时，你的改动越小，还原就更加简单。如果你合入了大量代码，并且其他人又在后来进行了改动，那么还原你的代码就会是一件非常痛苦的事情。也许你可以进行快速修复，但这并不是一定奏效，生产环境出现事故时，剔除有问题的代码会使团队的其他人更加放心。</li><li><strong>部署回滚更加简单。</strong>如果单次部署更新了web服务和即时生效的UI功能，那么如果你想要回滚后端服务就必须先要回滚UI的改动。由于这样部署方式，想要做到不停机更新可能并不容易。最好的办法就是把它们分别合入代码仓库并部署。</li><li><strong>更低的风险。</strong>这实际上是上述所有情况的结果。</li></ul><h3 id="为你的未来交学费"><a href="#为你的未来交学费" class="headerlink" title="为你的未来交学费"></a>为你的未来交学费</h3><p>那天我从那位高级工程师那里收到的代码审查反馈，已经被证明是职业生涯迄今为止收到的最好的代码审查反馈了。</p><p>多年后，我遇到了另一名工程师，他一直在进行大规模、彻底的变更。我把相同的反馈分享给了他，他看起来很生我的气，但是我完全可以理解他。在我看到他有进步之前，我离开了那家公司，希望他最终能体验到小规模修改带来的好处。</p><p>相信他以后会是一名优秀的工程师。</p><h3 id="译者点评"><a href="#译者点评" class="headerlink" title="译者点评"></a>译者点评</h3><p>小范围的修改确实是很有必要的。我自己在做code review的时候看到那种几百行的代码修改也是很头疼的。作者对于小规模修改的好处总结的还是比较全面的，希望大家能有收获。</p><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://medium.com/better-programming/the-best-code-review-feedback-i-ever-received-43313a503517">https://medium.com/better-programming/the-best-code-review-feedback-i-ever-received-43313a503517</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名初级工程师，当我看到一些问题时，通常会主动去解决它们，因此我总会进行一些大范围的代码修改。</summary>
    
    
    
    
    <category term="Code Review" scheme="https://jackeyzhe.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>吐血推荐珍藏的IDEA插件</title>
    <link href="https://jackeyzhe.github.io/2020/02/10/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%E7%8F%8D%E8%97%8F%E7%9A%84IDEA%E6%8F%92%E4%BB%B6/"/>
    <id>https://jackeyzhe.github.io/2020/02/10/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%E7%8F%8D%E8%97%8F%E7%9A%84IDEA%E6%8F%92%E4%BB%B6/</id>
    <published>2020-02-10T05:01:05.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前给大家推荐了一些我自己常用的VS Code插件，很多同学表示很受用，并私信我说要再推荐一些IDEA插件。作为一名职业Java程序员/业余js开发者，我平时还是用IDEA比较多，所以也确实珍藏了一些IDEA插件。今天就一并分享给大家。<span id="more"></span></p><p>在最开始，我还是想先介绍一下IDEA中如何安装插件，首先打开Preferences（菜单栏打开或者使用快捷键Command+,）在Windows版本中应该是Settings。然后选择Plugins一栏，就可以从右侧的MarketPlace中选择自己需要的插件进行安装了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581059914/Blog/Other/idea_plugins/idea.png" alt="idea插件"></p><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>首先向我们走来的是Lombok。作为Java程序员，你还在为不断的写Getter/Setter方法而苦恼吗？你还在为每个Model类都要写类似的构造方法而感到烦恼吗？赶快试试Lombok吧，它可以有效帮助你解决这些问题，只需要一个注解，构造方法和Getter/Setter方法全部搞定，再也不用把时间浪费在无用功上了。</p><p>如果你还不是很了解Lombok的话，可以自己动手，到<a href="https://projectlombok.org/">Lombok官网</a>学习一番，学完记得回来点赞。</p><p>最后展示一个简单的例子供大家参考。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581059921/Blog/Other/idea_plugins/idea1.png" alt="lombok"></p><h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p>String Manipulation插件是一款非常强大的插件，它可以对代码进行很多操作，如排序、去除空行、字符串格式转换、Encode/Decode。其中我最常用的是字符串格式转换。你可以通过点击右键选择String Manipulation或者使用快捷键Option + M来选择相应的功能。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581061347/Blog/Other/idea_plugins/idea2.gif" alt="String Manipulation"></p><h3 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h3><p>作为一名高级CtrlCV工程师，我写代码有两大利器，一个是Google，另一个就是stackoverflow。两者相辅相成，帮我在编码的道路上越走越远。相信有不少同学跟我一样离不开stackoverflow，那么这款插件就会给你带来极大的方便，遇到问题怎么办？右键一下，点击「search stackoverflow」，大部分问题都可以轻松搞定。</p><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h3><p>在推荐VS Code的插件时我们就介绍过一款叫做Bracket Pair Colorizer的插件，它可以把括号变成不同的颜色，我觉得这样分辨括号非常方便，看起来也比较美观。所以在IDEA中也使用了相同效果的插件，就是Rainbow Brackets。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581062247/Blog/Other/idea_plugins/idea3.png" alt="Rainbow Brackets"></p><h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>我们在接外部接口时，别人给了一串JSON串，我们在代码中需要将JSON中的字段封装到一个类中，一个一个输入挺麻烦的，这时GsonFormat就可以派上用场了。它可以帮助我们根据JSON中的key快速生成我们需要的类。</p><p>它的使用快捷键是Option + S</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581066692/Blog/Other/idea_plugins/idea4.gif" alt="GsonFormat"></p><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>如果你的项目使用的构建工具是Maven的话，这个插件就能帮你避免各种依赖冲突，安装好插件之后，打开pom文件，可以看到最下方有一个叫Dependency Analyzer的Tab，这里就可以看到你的哪些依赖是有冲突的，然后在右侧Exclude掉不需要的依赖。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581063616/Blog/Other/idea_plugins/idea5.png" alt="Maven Helper"></p><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p>RestfulToolkit是一套辅助开发Restful服务的工具集，对于这个插件，我最常用的功能就是快速查找指定的url对应的方法。快捷键是Command + \</p><p>关于其他的一些功能，大家有兴趣的话可以直接访问该插件的<a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit">homepage</a>。</p><p>以上这些就是我常用的IDEA插件了，没有太多花里胡哨的东西，大家如果有什么好用的插件也欢迎分享出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前给大家推荐了一些我自己常用的VS Code插件，很多同学表示很受用，并私信我说要再推荐一些IDEA插件。作为一名职业Java程序员/业余js开发者，我平时还是用IDEA比较多，所以也确实珍藏了一些IDEA插件。今天就一并分享给大家。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
