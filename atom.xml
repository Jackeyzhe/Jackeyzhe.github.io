<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackeyzhe&#39;s Blog</title>
  
  <subtitle>靠脸吃饭</subtitle>
  <link href="https://jackeyzhe.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackeyzhe.github.io/"/>
  <updated>2025-06-30T15:08:13.851Z</updated>
  <id>https://jackeyzhe.github.io/</id>
  
  <author>
    <name>Jackey Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink学习笔记：时间与Watermark</title>
    <link href="https://jackeyzhe.github.io/2025/06/30/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B8%8EWatermark/"/>
    <id>https://jackeyzhe.github.io/2025/06/30/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B8%8EWatermark/</id>
    <published>2025-06-30T14:58:16.000Z</published>
    <updated>2025-06-30T15:08:13.851Z</updated>
    
    <content type="html"><![CDATA[<p>在前文中，我学习 Flink 的整体架构，接下来的几篇文章，我将重点学习一下 Flink 的几个核心概念。包括时间属性、Watermark、窗口、状态以及容错机制。今天就来学习时间属性和 Watermark。<a id="more"></a></p><h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p>首先来学习 Flink 的时间属性，作为流处理引擎，时间是实时数据处理的重要依赖，特别是在做时序分析或者特定时间段数据处理时，时间的概念更显得尤为重要。</p><p>Flink 中支持三种时间属性，分别是：</p><ul><li><p>EventTime：事件时间，即为事件产生的时间。</p></li><li><p>ProcessTime：处理时间，Flink 算子处理事件的时间。</p></li><li><p>IngestionTime：摄入时间，Flink 读取事件的时间。</p></li></ul><p>这样描述可能比较抽象，我们通过一张图来看一下。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1750094745/Blog/flink/1/flink_time.png" alt="FlinkTime"></p><p>从上图中可以看出，在时间产生/存储时，记录一个设备时间，就是 Event Time。当 Flink 的 DataSource 读取到事件时，这时再记录一个时间，这就是 Ingestion Time。在 Flink 程序中，每个算子处理事件时，又会记录一个时间，这个时间就是 Process Time。</p><h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><p>介绍完了时间概念，再来看下 Watermark 的概念。它是 Flink 处理迟到事件的妙招。</p><p>Watermark 本身也属于一种特殊的事件，它由 Source 生成，同时携带由 Timestamp，并且会跟随正常的事件一起在 Flink 算子之间流转。Watermark 的作用是定义何时停止等待较早的事件。这么介绍可能比较抽象，下面我们通过一些具体的例子来进行更进一步的说明。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1751033706/Blog/flink/1/watermark.png" alt="watermark"></p><p>上图代表的是一段乱序的事件数据流。假设我们定义 maxOutOfOrderness 为4，也就是容忍最大迟到时间为4（这里不带具体时间单位，可能是4秒也可能是4分钟）。当我们收到时间戳为7的事件时，就会生成一个时间为3的 Watermark。这代表着3之前的数据都已就绪。如果此时再有小于3的数据，我们认为它是迟到数据。</p><p>而对于迟到的数据，通常有三种处理方法：</p><ul><li><p>重新开启已经关闭的窗口，重新计算并修正结果</p></li><li><p>将迟到事件使用旁路输出收集起来单独处理</p></li><li><p>将迟到事件视为错误消息丢弃</p></li></ul><p>在 Flink 中 Watermark 本身是没有意义的，它的主要作用是作为窗口的触发条件。窗口可以认为是一个时间段，它有开始时间和结束时间。在窗口内可以计算一批事件的统计结果。关于窗口，我们后面再做详细介绍。</p><p>那么 Watermark 是如何触发窗口的呢？答案是必须要满足以下两个条件：</p><ol><li><p>Watermark 的时间戳 &gt;= 窗口的 end_time</p></li><li><p>窗口中有数据</p></li></ol><p>从概念上看还是比较抽象，我们还用上面的数据流作为例子，Watermark 设置为最大时间减 4，假设我们设置10秒一个窗口。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">SingleOutputStreamOperator&lt;Event&gt; withTimestampsAndWatermarks = source</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.forGenerator(ctx -&gt; <span class="keyword">new</span> CustomWatermarkGenerator())</span><br><span class="line">                                .withTimestampAssigner(((event, l) -&gt; event.timestamp))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">OutputTag&lt;Event&gt; lateTag = <span class="keyword">new</span> OutputTag&lt;Event&gt;(<span class="string">"late-tag"</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; windowResult = withTimestampsAndWatermarks</span><br><span class="line">        .keyBy(event -&gt; event.num)</span><br><span class="line">        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">        .sideOutputLateData(lateTag)</span><br><span class="line">        .process(<span class="keyword">new</span> ProcessWindowFunction&lt;Event, String, Long, TimeWindow&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Long key, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 一些逻辑处理</span></span><br><span class="line">             out.collect(result);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理迟到数据</span></span><br><span class="line">DataStream&lt;Event&gt; lateStream = windowResult.getSideOutput(lateTag);</span><br><span class="line">lateStream.process(<span class="keyword">new</span> ProcessFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event event, Context ctx, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">        out.collect(<span class="string">"迟到事件: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).print();</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event, <span class="keyword">long</span> l, WatermarkOutput watermarkOutput)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> eventTime = event.timestamp;</span><br><span class="line">    <span class="comment">// 使用CAS确保线程安全</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = currentMaxTime.get();</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= current) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentMaxTime.compareAndSet(current, eventTime)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput watermarkOutput)</span> </span>&#123;</span><br><span class="line">    watermarkOutput.emitWatermark(<span class="keyword">new</span> Watermark(currentMaxTime.get() - timeDiff));</span><br><span class="line">&#125;</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Jackeyzhe/flink-training/blob/feature/wz-demo/common/src/main/java/org/apache/flink/training/examples/watermark/WatermarkDemo.java" target="_blank" rel="noopener">完整代码我放在 github 上了</a></p><p>当我们输入测试数据时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>,<span class="number">1750867204000</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1750867202000</span></span><br><span class="line"><span class="number">7</span>,<span class="number">1750867207000</span></span><br><span class="line"><span class="number">10</span>,<span class="number">1750867210000</span></span><br><span class="line"><span class="number">9</span>,<span class="number">1750867209000</span></span><br><span class="line"><span class="number">15</span>,<span class="number">1750867215000</span></span><br><span class="line"><span class="number">12</span>,<span class="number">1750867212000</span></span><br><span class="line"><span class="number">13</span>,<span class="number">1750867213000</span></span><br><span class="line"><span class="number">25</span>,<span class="number">1750867225000</span></span><br><span class="line"><span class="number">14</span>,<span class="number">1750867214000</span></span><br><span class="line"><span class="number">35</span>,<span class="number">1750867235000</span></span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1751035105/Blog/flink/1/%E6%88%AA%E5%B1%8F2025-06-27_22.35.50.png" alt="print"></p><p>通过输出的日志，我们可以看出，当watermark推进到大于等于时间窗口的结束时间时，窗口就会完成计算并关闭。而对于迟到的数据，我们可以通过侧输出流单独处理，也可以通过设置<code>allowedLateness</code>，使窗口重新打开。</p><h3 id="生成-Watermark"><a href="#生成-Watermark" class="headerlink" title="生成 Watermark"></a>生成 Watermark</h3><p>了解了 Watermark 的原理之后，我们再来看一下如何生成 Watermark。在 Flink 中，需要使用 WatermarkStrategy 来定义如何生成时间戳和 watermark。WatermarkStrategy 继承了 TimestampAssignerSupplier 和 WatermarkGeneratorSupplier 两个接口，其中 TimestampAssignerSupplier 定义了抽取 EventTime 的方法，而 WatermarkGeneratorSupplier 则是定义了如何生成 Watermark 的方法。</p><h4 id="Flink-内置的-Watermark-生成器"><a href="#Flink-内置的-Watermark-生成器" class="headerlink" title="Flink 内置的 Watermark 生成器"></a>Flink 内置的 Watermark 生成器</h4><p>Flink 中内置了两个 watermark 生成器。分别是 AscendingTimestampsWatermarks 和 BoundedOutOfOrdernessWatermarks。</p><p>我们先来看 BoundedOutOfOrdernessWatermarks，它定义了一个 watermark 滞后于最大事件时间一个固定值的 watermark 生成器。在使用时，可以给定一个时间，这样 Flink 就会 根据最大的 eventTime 来周期性的生成 watermark，例如，我们前面定义的 watermark 滞后4秒，就可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>AscendingTimestampsWatermarks 是单调递增时间分配器，也就是只处理有序的数据，它继承了 BoundedOutOfOrdernessWatermarks，并且最大容忍时间为0。在使用时，可以直接通过以下方法生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forMonotonousTimestamps();</span><br></pre></td></tr></table></figure><h4 id="自定义-WatermarkGenerator"><a href="#自定义-WatermarkGenerator" class="headerlink" title="自定义 WatermarkGenerator"></a>自定义 WatermarkGenerator</h4><p>除了上面两个内置的 WatermarkGenerator 外，我们还可以自定义，实现起来也比较简单。只需要实现 WatermarkGenerator 接口并重写 onEvent 和 onPeriodicEmit 两个方法即可。onEvent 是每个事件到来时调用一次，可以用来记录最大事件时间。onPeriodicEmit 则是周期性调用，可以生成 watermark。在前面的例子中，我使用的 CustomWatermarkGenerator 就是自定义的 watermark，对应的实现也在前文中贴了。</p><h3 id="如何处理空闲数据源"><a href="#如何处理空闲数据源" class="headerlink" title="如何处理空闲数据源"></a>如何处理空闲数据源</h3><p>最后，再补充一个与 watermark 相关的比较重要的特性。在 Flink 中，会有一些算子有多个输入源。这时，这个算子的 watermark 是以它收到的数据源中最小的 eventTime 来计算的。直接看官网的例子：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1751294872/Blog/flink/1/parallel_streams_watermarks.svg" alt="parallel_stream_watermark"></p><p>那么这里就存在一个问题：如果一个输入源数据量很少，很久才发一条消息，而另一个数据源发了很多消息，那么就会在下游算子中积累很多消息等待处理，这对于整个系统的稳定性造成了很大的风险。</p><p>那这种情况有办法处理吗？答案是肯定的，Flink 提供了 withIdleness 方法，它可以用来检测空闲数据源，如果超过一定时间没有数据到来，Flink 认为这个数据源属于空闲数据源，这时就不会再阻塞下游算子触发窗口。达到定期处理数据的目的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们先了解了 Flink 中时间的概念，EventTime 是事件产生的时间，通常由上游数据源生成，ProcessTime 是处理时间，通常由处理算子本身生成，IngestionTime是摄入时间，通常由 Flink 的 Source 生成。</p><p>接着我们由了解了 Flink 的 watermark，它是窗口触发的条件，在处理迟到数据时发挥着重要的作用。我们可以定义可以容忍的最大迟到时间，这样当遇到乱序数据时也可以得到正确的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文中，我学习 Flink 的整体架构，接下来的几篇文章，我将重点学习一下 Flink 的几个核心概念。包括时间属性、Watermark、窗口、状态以及容错机制。今天就来学习时间属性和 Watermark。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记：整体架构</title>
    <link href="https://jackeyzhe.github.io/2025/06/09/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://jackeyzhe.github.io/2025/06/09/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2025-06-09T03:31:31.000Z</published>
    <updated>2025-06-11T13:14:07.240Z</updated>
    
    <content type="html"><![CDATA[<p>开一个新坑，系统性的学习下 Flink，计划从整体架构到核心概念再到调优方法，最后是相关源码的阅读。<a id="more"></a></p><!-- more --><p>今天就来学习 Flink 整体架构，我们先看官网的架构图</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1647276646/Blog/flink/0/flink0_0.png" alt="Flink Architecture"></p><p>图中包含三部分，分别是 Client、JobManager 和 TaskManager。其中 Client 并不属于 Flink 集群，它主要用来把用户编写的程序翻译成 StreamGraph 然后优化成 JobGraph，再将 JobGraph 提交到 Flink 集群执行。</p><h3 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a>JobManager</h3><p>Flink 集群的 JobManager 是用来接收 Client 提交的任务，并且分发给 TaskManager 去执行。此外，JobManager 还有一些其他的职责，例如任务调度，协调 checkpoint 和协调从失败中恢复。</p><p>每个 Flink 集群至少要有一个 JobManager，但在生产环境中通常是高可用模式部署，即部署多台 JobManager，其中一台作为 Leader，其他的作为 Standby 节点。当 Leader 挂掉时，其他的 Standby 节点会有一台被选举为新的 Leader 提供服务。这样就能避免 JobManager 单机故障影响到整个 Flink 集群的可用性。</p><p>JobManager 主要由以下几部分组成，下面我们分别来看每部分的作用。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749308494/Blog/flink/0/JobManager.png" alt="JobManager"></p><h4 id="DataFlow-Graph"><a href="#DataFlow-Graph" class="headerlink" title="DataFlow Graph"></a>DataFlow Graph</h4><p>JobManager 收到 JobGraph 之后，根据并行度的设置，将各个算子任务拆分成并行的子任务，最终生成 ExecutionGraph。</p><h4 id="Checkpoint-coordinator"><a href="#Checkpoint-coordinator" class="headerlink" title="Checkpoint coordinator"></a>Checkpoint coordinator</h4><p>Checkpoint 是 Flink 最核心的概念之一，Flink 的容错机制主要靠 checkpoint 来保障。而 checkpoint 的生成会恢复则由 checkpoint coordinator 来负责。</p><h4 id="Job-Dispatch"><a href="#Job-Dispatch" class="headerlink" title="Job Dispatch"></a>Job Dispatch</h4><p>Job Dispatch 提供了 REST 接口用于提交 Flink 任务，并为每个任务启动一个 JobMaster。JobMaster 负责管理单个 JobGraph 的执行。</p><h4 id="Task-Scheduling"><a href="#Task-Scheduling" class="headerlink" title="Task Scheduling"></a>Task Scheduling</h4><p>Task Scheduling 负责 Task 部署和调度，值得一提的是，JobManager 和 TaskManager 以及 Client 之间的通信都是通过一个叫 Actor System 的 RPC 系统实现的。</p><h4 id="Resource-Manager"><a href="#Resource-Manager" class="headerlink" title="Resource Manager"></a>Resource Manager</h4><p>Resource Manager 负责集群中的资源的分配回收，它管理的资源单元叫做 task slot，对于不同的部署环境，Resource Manager 有不同的实现，</p><h4 id="Actor-System"><a href="#Actor-System" class="headerlink" title="Actor System"></a>Actor System</h4><p>Actor System 是 Flink 集群中的一种 RPC 通信的组件，JobManager 和 TaskManager 以及 Client 之间的通信都是基于 Actor System 的。而 TaskManager 之间的数据传递是基于 Netty 的。</p><h3 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a>TaskManager</h3><p>聊完了 JobManager，我们再来看下 TaskManager 的结构。TaskManager 主要负责执行作业的 task，并缓存和交换数据流。TaskManager 中最小的资源调度单位是 task slot，这点在前面介绍 Resource Manager 时也提到过。它表示并发处理 task 的数量。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749399164/Blog/flink/0/TaskManager.png" alt="TaskManager"></p><h4 id="Task-Execution"><a href="#Task-Execution" class="headerlink" title="Task Execution"></a>Task Execution</h4><p>TaskManager 在接到 JobManager 部署的任务后，就会申请相应的 task slot 去执行任务。</p><h4 id="Data-Exchange"><a href="#Data-Exchange" class="headerlink" title="Data Exchange"></a>Data Exchange</h4><p>Data Execution 主要负责 TaskManager 之间的数据交互的一些操作，这里主要关注逻辑层面，例如一些 shuffle 操作。而网络传输则主要是由 Network Manager 来实现。</p><h4 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h4><p>Memory Management 负责 TaskManager 的内存管理，在执行任务过程中，接收到的一些数据是需要放在内存中进行处理的。相应的内存管理操作依赖于 Memory Management 模块。</p><h4 id="Actor-System-1"><a href="#Actor-System-1" class="headerlink" title="Actor System"></a>Actor System</h4><p>Actor System 我们在前面提到过，TaskManager 和 JobManager 之间的通信全靠它。</p><h4 id="Network-Manager"><a href="#Network-Manager" class="headerlink" title="Network Manager"></a>Network Manager</h4><p>Network Manager 主要负责 TaskManager 之间的数据交互，它是基于 Netty 实现的。</p><p>最后多提一个 Graph 的概念，前面我们已经了解到了 JobManager 会将 JobGraph 根据并行度的配置转换成 ExecutionGraph。在这之后，JobManager 会对作业进行调度，将 task 部署到各个 TaskManager 上，最终就形成了物理执行图，也就是 PhysicalGraph。</p><p>这里小结一下，Flink 中四种图的生成顺序是：用户编写的代码生成 StreamGraph，Client 将其进行优化，主要是将多个符合条件的节点 chain 在一起，生成了 JobGraph，然后将 JobGraph 提交到 JobManager，再由 JobManager 生成并行版本的 ExecutionGraph，待JobManager 将 task 调度后，生成的图被称为 PhysicalGraph。</p><h3 id="Flink-的几种部署模式"><a href="#Flink-的几种部署模式" class="headerlink" title="Flink 的几种部署模式"></a>Flink 的几种部署模式</h3><p>根据集群的生命周期、资源隔离以及 main() 方法的执行，通常将 Flink 的部署模式分为三种：Session Mode、Per-Job Mode 和 Application Mode。下面我们分别介绍这三种部署模式。</p><h4 id="Session-Mode"><a href="#Session-Mode" class="headerlink" title="Session Mode"></a>Session Mode</h4><p>Session Mode 下，所有的任务共享 JobManager 和 TaskManager，JobManager 的生命周期不受提交的 Job 影响，会长期运行。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/SessionMode.png" alt="SessionMode"></p><h4 id="Per-Job-Mode"><a href="#Per-Job-Mode" class="headerlink" title="Per-Job Mode"></a>Per-Job Mode</h4><p>Per-Job Mode 下，每个任务独享 JobManager 和 TaskManager，资源充分隔离。JobManager 的生命周期和 Job 的生命周期绑定。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/Per-job.png" alt="Per-JobMode"></p><h4 id="Application-Mode"><a href="#Application-Mode" class="headerlink" title="Application Mode"></a>Application Mode</h4><p>Application Mode 下，每个 Application 对应一个 JobManager，且可以运行多个作业。客户端无需将依赖包上传到 JobManager，只负责提交作业，减轻了客户端的压力。提交作业后，JobManager 主动从 HDFS 拉取依赖包。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1749406344/Blog/flink/0/Application.png" alt="ApplicationMode"></p><h4 id="三种模式的对比"><a href="#三种模式的对比" class="headerlink" title="三种模式的对比"></a>三种模式的对比</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Session</th><th style="text-align:center">Per-Job</th><th style="text-align:center">Application</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:center">1、资源充分共享，提升资源利用率<br>2、作业集中管理，运维简单</td><td style="text-align:center">1、资源充分隔离<br>2、每个作业的 TM Slots 可以不同</td><td style="text-align:center">1、有效降低带宽和客户端负载<br>2、Application 之间实现资源隔离，Application 中的资源共享</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">1、资源隔离差<br>2、TM 不易扩展，伸缩性差</td><td style="text-align:center">1、资源浪费</td><td style="text-align:center">1、仅支持 Yarn 和 Kubunetes （个人感觉够用了）</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后来总结一下，今天主要学习了 Flink 的整体架构和三种部署模式。</p><p>1、Flink 的集群架构上主要包含 JobManager 和 TaskManager，其中 JobManager 主要负责一些作业调度和资源协调的工作，TaskManager 则主要负责执行任务。</p><p>2、Flink 的部署模式分为 Session、Per-Job 和 Application 三种，Session 模式是所有 Job 共享 JobManager 和 TaskManager，Per-Job 则是作业独享的，而 Application 模式则是在 Application 中共享 JobManager。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开一个新坑，系统性的学习下 Flink，计划从整体架构到核心概念再到调优方法，最后是相关源码的阅读。</summary>
    
    
    
    
    <category term="Flink" scheme="https://jackeyzhe.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：最后一舞</title>
    <link href="https://jackeyzhe.github.io/2020/04/19/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%80%E5%90%8E%E4%B8%80%E8%88%9E/"/>
    <id>https://jackeyzhe.github.io/2020/04/19/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%80%E5%90%8E%E4%B8%80%E8%88%9E/</id>
    <published>2020-04-19T13:15:29.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rust入坑指南系列我觉得应该告一段落了，最后来做一个总结吧。<a id="more"></a></p><p>在我看来，Rust语言本身设计得算是非常好了。Ownership和borrow帮助我们保证了程序了安全性。同时也提供了Unsafe，给开发者更多玩一些骚操作的空间。唯一的缺点就是入门比较困难了吧，我现在的水平感觉自己也就是刚刚入门。而《Rust入坑指南》也是希望帮助更多想要学习Rust的同学快速入门。</p><p>这里简单回顾一下学习过程吧。</p><p>最开始接触一门语言一定绕不开Hello，World</p><p>Rust也是一样，所以我们的第一篇文章就是关于Rust的安装、Hello，World程序的。</p><p><a href="https://jackeyzhe.github.io/2019/09/21/Rust入坑指南：坑主驾到/">Rust入坑指南：坑主驾到</a></p><p>接着就是介绍一些基础的语法、Rust的所有权、数据结构这些概念。关于这部分知识我用了四篇文章来做介绍。其中最重要的应该是Rust所有权了，这也是Rust语言的亮点之一。</p><p><a href="https://jackeyzhe.github.io/2019/10/08/Rust入坑指南：常规套路/">Rust入坑指南：常规套路</a></p><p><a href="https://jackeyzhe.github.io/2019/10/13/Rust入坑指南：核心概念/">Rust入坑指南：核心概念</a></p><p><a href="https://jackeyzhe.github.io/2019/10/27/Rust入坑指南：千人千构/">Rust入坑指南：千人千构</a></p><p><a href="https://jackeyzhe.github.io/2019/11/27/Rust入坑指南：鳞次栉比/">Rust入坑指南：鳞次栉比</a></p><p>接着呢，我们介绍了Package和Crate，用来帮助我们组织代码的。同时Crate也是为了让我们可以直接使用别人的代码，避免重复造轮子。</p><p><a href="https://jackeyzhe.github.io/2019/11/03/Rust入坑指南：有条不紊/">Rust入坑指南：有条不紊</a></p><p>之后又是两个比较通用的概念，大多数编程语言时都要涉及到的：异常处理和泛型</p><p><a href="https://jackeyzhe.github.io/2019/12/30/Rust入坑指南：亡羊补牢/">Rust入坑指南：亡羊补牢</a></p><p><a href="https://jackeyzhe.github.io/2020/01/14/Rust入坑指南：海纳百川/">Rust入坑指南：海纳百川</a></p><p>如果你对代码的正确性不放心，那么一定要写下完备的单元测试，这是对自己的代码负责。</p><p><a href="https://jackeyzhe.github.io/2020/02/21/Rust入坑指南：步步为营/">Rust入坑指南：步步为营</a></p><p>除了OwnerShip和borrow之外，Rust的另外两个比较核心的概念也需要了解，分别是生命周期和智能指针。这两篇文章可以帮你快速了解这两个概念。</p><p><a href="https://jackeyzhe.github.io/2020/03/02/Rust入坑指南：朝生暮死/">Rust入坑指南：朝生暮死</a></p><p><a href="https://jackeyzhe.github.io/2020/03/09/Rust入坑指南：智能指针/">Rust入坑指南：智能指针</a></p><p>接着是并发编程，Rust声称的安全并发，究竟是怎么保证的？</p><p><a href="https://jackeyzhe.github.io/2020/03/15/Rust入坑指南：齐头并进（上）/">Rust入坑指南：齐头并进（上）</a></p><p><a href="https://jackeyzhe.github.io/2020/03/23/Rust入坑指南：齐头并进（下）/">Rust入坑指南：齐头并进（下）</a></p><p>Safe Rust有这样那样的限制，有的开发者可能会觉得束手束脚，难以发挥实力。这时就可以考虑看看Unsafe Rust了。</p><p><a href="https://jackeyzhe.github.io/2020/03/31/Rust入坑指南：居安思危/">Rust入坑指南：居安思危</a></p><p>最后是Rust的元编程，我们从最开始就在使用的<code>println!</code>宏，它是如何定义的呢？我们又怎么定义自己的宏？希望这篇文章对你有帮助。</p><p><a href="https://jackeyzhe.github.io/2020/04/08/Rust入坑指南：万物初始/">Rust入坑指南：万物初始</a></p><p>经过这几个月的学习，我对Rust也有了一个初步的了解，在这里要感谢对我的分享提出意见的同学。也希望我的分享能对大家有所帮助。</p><p>虽然标题叫最后一舞，但是后面我还是会继续保持学习，也会不定期分享一些入门的代码案例给大家。</p><p>Rust编程，我们后会有期。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust入坑指南系列我觉得应该告一段落了，最后来做一个总结吧。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：万物初始</title>
    <link href="https://jackeyzhe.github.io/2020/04/08/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%B8%87%E7%89%A9%E5%88%9D%E5%A7%8B/"/>
    <id>https://jackeyzhe.github.io/2020/04/08/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%B8%87%E7%89%A9%E5%88%9D%E5%A7%8B/</id>
    <published>2020-04-08T15:02:34.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>有没有同学记得我们一起挖了多少个坑？嗯…其实我自己也不记得了，今天我们再来挖一个特殊的坑，这个坑可以说是挖到根源了——<strong>元编程</strong>。<a id="more"></a></p><p>元编程是编程领域的一个重要概念，它允许程序将代码作为数据，在运行时对代码进行修改或替换。如果你熟悉Java，此时是不是想到了Java的反射机制？没错，它就是属于元编程的一种。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Rust也同样支持反射，Rust的反射是由标准库中的<code>std::any::Any</code>包支持的。</p><p>这个包中提供了以下几个方法</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1586171714/Blog/rust/15/rust15-1.png" alt="Any包的方法"></p><p>TypeId是Rust中的一种类型，它被用来表示某个类型的唯一标识。<code>type_id(&amp;self)</code>这个方法返回变量的TypeId。</p><p><code>is()</code>方法则用来判断某个函数的类型。</p><p>可以看一下它的源码实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is</span></span>&lt;T: Any&gt;(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = TypeId::of::&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> concrete = <span class="keyword">self</span>.type_id();</span><br><span class="line"></span><br><span class="line">  t == concrete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的实现非常简单，就是对比TypeId。</p><p><code>downcast_ref()</code>和<code>downcast_mut()</code>是一对用于将泛型T转换为具体类型的方法。其返回的类型是<code>Option&lt;&amp;T&gt;</code>和<code>Option&lt;&amp;mut T&gt;</code>，也就是说<code>downcast_ref()</code>将类型T转换为不可变引用，而<code>downcast_mut()</code>将T转换为可变引用。</p><p>最后我们通过一个例子来看一下这几个函数的具体使用方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::&#123;Any, TypeId&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="string">"Jackey"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: &amp;Any;</span><br><span class="line">    a = &amp;v1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a.type_id());</span><br><span class="line">    <span class="built_in">assert!</span>(a.is::&lt;&amp;<span class="built_in">str</span>&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_any(&amp;v1);</span><br><span class="line">    <span class="keyword">let</span> v2: <span class="built_in">u32</span> = <span class="number">33</span>;</span><br><span class="line">    print_any(&amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_any</span></span>(any: &amp;Any) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = any.downcast_ref::&lt;<span class="built_in">u32</span>&gt;() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"u32 &#123;:x&#125;"</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = any.downcast_ref::&lt;&amp;<span class="built_in">str</span>&gt;() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"str &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"else"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>Rust的反射机制提供的功能比较有限，但是Rust还提供了宏来支持元编程。</p><p>到目前为止，宏对我们来说是一个既熟悉又陌生的概念，熟悉是因为我们一直在使用<code>println!</code>宏，陌生则是因为我们从没有详细介绍过它。</p><p>对于<code>println!</code>宏，我们直观上的使用感受是它和函数差不多。但两者之间还是有一定的区别的。</p><p>我们知道对于函数，它接收参数的个数是固定的，并且在函数定义时就已经固定了。而宏接收的参数个数则是不固定的。</p><p>这里我们说的宏都是类似函数的宏，此外，Rust还有一种宏是类似于属性的宏。它有点类似于Java中的注解，通常作为一种标记写在函数名上方。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() &#123;</span><br></pre></td></tr></table></figure><p>route在这里是用来指定接口方法的，对于这个服务来讲，根路径的<code>GET</code>请求都被路由到这个index函数上。这样的宏是通过属于<strong>过程宏</strong>，它的定义使用了<code>#[proc_macro_attribute]</code>注解。而函数类似的过程宏在定义时使用的注解是<code>#[proc_macro]</code>。</p><p>除了过程宏以外，宏的另一大分类叫做<strong>声明宏</strong>。声明宏是通过<code>macro_rules!</code>来声明定义的宏，它比过程宏的应用要更加广泛。我们曾经接触过的<code>vec!</code>就是声明宏的一种。它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来定义一个属于自己的宏。</p><p>自定义宏需要使用<code>derive</code>注解。（例子来自the book）</p><p>我们先来创建一个叫做hello_macro的lib库，只定义一个trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">HelloMacro</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着再创建一个子目录hello_macro_derive，在hello_macro_derive/Cargo.toml文件中添加依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-<span class="keyword">macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">syn = <span class="string">"0.14.4"</span></span><br><span class="line">quote = <span class="string">"0.6.3"</span></span><br></pre></td></tr></table></figure><p>然后就可以在hello_macro_derive/lib.rs文件中定义我们自定义宏的功能实现了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="comment">// Construct a representation of Rust code as a syntax tree</span></span><br><span class="line">    <span class="comment">// that we can manipulate</span></span><br><span class="line">    <span class="keyword">let</span> ast = syn::parse(input).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the trait implementation</span></span><br><span class="line">    impl_hello_macro(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">impl_hello_macro</span></span>(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> name = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> gen = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> HelloMacro <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Hello, Macro! My name is &#123;&#125;"</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了两个crate：syn和quote，其中syn是把Rust代码转换成一种特殊的可操作的数据结构，而quote的作用则与它刚好相反。</p><p>可以看到，我们自定义宏使用的注解是<code>#[proc_macro_derive(HelloMacro)]</code>，其中HelloMacro是宏的名称，在使用时，我们只需要使用注解<code>#[derive(HelloMacro)]</code>即可。</p><p>在使用时我们应该先引入这两个依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello_macro = &#123; path = <span class="string">"../hello_macro"</span> &#125;</span><br><span class="line">hello_macro_derive = &#123; path = <span class="string">"../hello_macro/hello_macro_derive"</span> &#125;</span><br></pre></td></tr></table></figure><p>然后再来使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pancakes</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    Pancakes::hello_macro();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示，我们能够成功在实现中捕获到结构体的名字。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1586190192/Blog/rust/15/rust15-2.png" alt="result"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们在本文中先后介绍了Rust的两种元编程：反射和宏。其中反射提供的功能能力较弱，但是宏提供的功能非常强大。我们所介绍的宏的相关知识其实只是皮毛，要想真正理解宏，还需要花更多的时间学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有没有同学记得我们一起挖了多少个坑？嗯…其实我自己也不记得了，今天我们再来挖一个特殊的坑，这个坑可以说是挖到根源了——&lt;strong&gt;元编程&lt;/strong&gt;。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：居安思危</title>
    <link href="https://jackeyzhe.github.io/2020/03/31/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%B1%85%E5%AE%89%E6%80%9D%E5%8D%B1/"/>
    <id>https://jackeyzhe.github.io/2020/03/31/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%B1%85%E5%AE%89%E6%80%9D%E5%8D%B1/</id>
    <published>2020-03-31T10:17:48.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何事情都是相对的，就像Rust给我们的印象一直是安全、快速，但实际上，完全的安全是不可能实现的。因此，Rust中也是会有不安全的代码的。<a id="more"></a></p><p>严格来讲，Rust语言可以分为<strong>Safe Rust</strong>和<strong>Unsafe Rust</strong>。Unsafe Rust是Safe Rust的超集。在Unsafe Rust中并不会禁用任何的安全检查，Unsafe Rust出现的原因是为了让开发者可以做一些更加底层的操作。这些事情本身也是不安全的，如果仍然要进行Rust的安全检查，那么就无法进行这些操作。</p><p>在进行下面这5种操作时，Unsafe Rust不会进行安全检查。</p><ul><li>解引用原生指针</li><li>调用unsafe的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现unsafe的trait</li><li>读写联合体中的字段</li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>Unsafe Rust的关键字是unsafe，它可以用来修饰函数、方法和trait，也可以用来标记代码块。</p><p>标准库中也有不少函数是unsafe的。例如String中的<code>from_utf8_unchecked()</code>函数。它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_utf8_unchecked</span></span>(bytes: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> &#123; vec: bytes &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数被标记为unsafe的原因是函数并没有检查传入参数是否是合法的UTF-8序列。也就是提醒使用者注意，使用这个函数要自己保证参数的合法性。</p><p>用unsafe标记的trait也比较常见，在前面我们见过的Send和Sync都是unsafe的trait。它们被用来保证线程安全， 将其标记为unsafe是告诉开发者，如果自己实现这两个trait，那么代码就会有安全风险。</p><p>我们在调用unsafe函数或方法时，需要使用unsafe代码块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sparkle_heart = <span class="built_in">vec!</span>[<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sparkle_heart = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from_utf8_unchecked(sparkle_heart)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">"💖"</span>, sparkle_heart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解了unsafe的基础语法之后，我们再来具体看看前面提到的5种操作。</p><h3 id="解引用原生指针"><a href="#解引用原生指针" class="headerlink" title="解引用原生指针"></a>解引用原生指针</h3><p>Rust的原生指针分为两种：可变类型<code>*mut T</code>和不可变类型<code>*const T</code>。</p><p>与引用和智能指针不同，原生指针具有以下特性：</p><ul><li>可以不遵循借用规则，在同一代码块中可以同时出现可变和不可变指针，也可以同时有多个可变指针</li><li>不保证指向有效内存</li><li>允许是null</li><li>不会自动清理内存</li></ul><p>由这些特性可以看出，原生指针并不受Rust那一套安全规则的限制，因此，解引用原生指针是一种不安全的操作。换句话说，我们应该把这种操作放在unsafe代码块中。下面这段代码就展示了原生指针的第一条特性，以及如何解引用原生指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Rust编程中，原生指针常被用作和C语言打交道，原生指针有一些特有的方法，例如可以用<code>is_null()</code>来判断原生指针是否是空指针，用<code>offset()</code>来获取指定偏移量的内存地址的内容，使用<code>read()/write()</code>方法来读写内存等。</p><h3 id="调用unsafe的函数或方法"><a href="#调用unsafe的函数或方法" class="headerlink" title="调用unsafe的函数或方法"></a>调用unsafe的函数或方法</h3><p>调用unsafe的函数或方法必须放到unsafe代码块中，这点我们在基础知识中已经介绍过。因为函数本身被标记为unsafe，也就意味着调用它可能存在风险。这点无需赘述。</p><h3 id="访问或修改可变的静态变量"><a href="#访问或修改可变的静态变量" class="headerlink" title="访问或修改可变的静态变量"></a>访问或修改可变的静态变量</h3><p>对于不可变的静态变量，我们访问它不会存在任何安全问题，但是对于可变的静态变量而言，如果我们在多线程中都访问同一个变量，那么就会造成数据竞争。这当然也是一种不安全的操作。所以要放到unsafe代码块中，此时线程安全应由开发者自己来保证。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中我们没有使用多线程，这里只是想展示一下如何访问和修改可变静态变量。</p><h3 id="实现unsafe的trait"><a href="#实现unsafe的trait" class="headerlink" title="实现unsafe的trait"></a>实现unsafe的trait</h3><p>当trait中包含一个或多个编译器无法验证其安全性的方法时，这个trait就必须被标记为unsafe。而想要实现unsafe的trait，首先在实现代码块的关键字<code>impl</code>前也要加上unsafe标记。其次，无法被编译器验证安全性的方法，其安全性必须由开发者自己来保证。</p><p>前面我们也提到了，常见的unsafe的trait有Send和Sync这两个。</p><h3 id="读写联合体中的字段"><a href="#读写联合体中的字段" class="headerlink" title="读写联合体中的字段"></a>读写联合体中的字段</h3><p>Rust中的Union联合体和Enum相似。我们可以使用union关键字来定义一个联合体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">MyUnion</span></span> &#123;</span><br><span class="line">    i: <span class="built_in">i32</span>,</span><br><span class="line">    f: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_union = MyUnion&#123;i: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_union.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化时，我们每次只能指定一个字段的值。这就造成我们在访问联合体中的字段时，有可能会访问到未定义的字段。因此，Rust让我们把访问操作放到unsafe代码块中，以此来警示我们必须自己保证程序的安全性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们聊了Unsafe Rust的一些使用场景和使用方法。你只需要记住Unsafe的5种操作就好，在遇到这些操作时，一定要使用unsafe代码块。unsafe代码块不光是为了“骗”过编译器，要时刻提醒自己，<strong>unsafe代码块中的程序要由开发者自己保证其正确性</strong>。</p><ul><li>解引用原生指针</li><li>调用unsafe的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现unsafe的trait</li><li>读写联合体中的字段</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何事情都是相对的，就像Rust给我们的印象一直是安全、快速，但实际上，完全的安全是不可能实现的。因此，Rust中也是会有不安全的代码的。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>走近源码：Redis如何清除过期key</title>
    <link href="https://jackeyzhe.github.io/2020/03/30/%E8%B5%B0%E8%BF%91%E6%BA%90%E7%A0%81%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E8%BF%87%E6%9C%9Fkey/"/>
    <id>https://jackeyzhe.github.io/2020/03/30/%E8%B5%B0%E8%BF%91%E6%BA%90%E7%A0%81%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E8%BF%87%E6%9C%9Fkey/</id>
    <published>2020-03-30T14:18:37.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>“叮……”，美好的周六就这么被一阵钉钉消息吵醒了。<a id="more"></a></p><p>业务组的同学告诉我说很多用户的帐号今天被强制下线。我们的帐号系统正常的逻辑是用户登录一次后，token的有效期可以维持一天的时间。现在的问题是用户大概每10分钟左右就需要重新登录一次。这种情况一般有两种原因：1、token生成时出问题。2、验证token时出现问题。</p><p>通过检查日志，我发现是验证token时，Redis中已经没有对应的token了。并且确定了生成新的token时，set到Redis中的有效期是正确的，那么就基本可以确定是Redis的问题了。</p><p>于是又去检查了Redis的监控，发现在那段时间Redis由于内存占用过高强制清理了几次key。但从日志上来看，这段时间并没有出现流量暴涨的情况，而且Redis中key的数量也没有显著增加。那是什么原因导致Redis内存占用过高呢？确定了Redis内存升高不是我们造成的之后，我们又联系了业务组的同学协助他们，他们表示最近确实有上线，并且新上线的功能有使用到Redis。但我仍然感觉很奇怪，为什么Redis中的key没有增多，并且没看到有其他业务的key。经过一番询问，才了解到，业务组同学使用的是这个Redis的db1，而我用的（和刚查的）是db0。这里确实是我在排查问题时出现了疏忽。</p><p>那么Redis的不同db之间会互相影响吗？通常情况下，我们使用不同的db进行数据隔离，这没问题。<strong>但Redis进行清理时，并不是只清理数据量占用最大的那个db，而是会对所有的db进行清理。</strong>在这之前我并不是很了解这方面知识，这里也只是根据现象进行的猜测。</p><p>好奇心驱使我来验证一下这个想法。于是我决定直接来看Redis的源码。清理key相关的代码在<a href="https://github.com/antirez/redis/blob/unstable/src/evict.c" target="_blank" rel="noopener">evict.c</a>文件中。</p><p>Redis中会保存一个“过期key池”，这个池子中存放了一些可能会被清理的key。其中保存的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中idle是对象空闲时间，在Reids中，key的过期算法有两种：一种是近似LRU，一种是LFU。默认使用的是近似LRU。</p><h3 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h3><p>在解释近似LRU之前，先来简单了解一下LRU。当Redis的内存占用超过我们设置的maxmemory时，会把长时间没有使用的key清理掉。按照LRU算法，我们需要对所有key（也可以设置成只淘汰有过期时间的key）按照空闲时间进行排序，然后淘汰掉空闲时间最大的那部分数据，使得Redis的内存占用降到一个合理的值。</p><p>LRU算法的缺点是，我们需要维护一个全部（或只有过期时间）key的列表，还要按照最近使用时间排序。这会消耗大量内存，并且每次使用key时更新排序也会占用额外的CPU资源。对于Redis这样对性能要求很高的系统来说是不被允许的。</p><p>因此，Redis采用了一种近似LRU的算法。当Redis接收到新的写入命令，而内存又不够时，就会触发近似LRU算法来强制清理一些key。具体清理的步骤是，Redis会对key进行采样，通常是取5个，然后会把过期的key放到我们上面说的“过期池”中，过期池中的key是按照空闲时间来排序的，Redis会优先清理掉空闲时间最长的key，直到内存小于maxmemory。</p><p>近似LRU算法的清理效果图如图（图片来自Redis官方文档）</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1585453145/Blog/Redis/evict/lru_comparison.png" alt="lru_comparison"></p><p>这么说可能不够清楚，我们直接上代码。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1585453153/Blog/Redis/evict/lru_call.png" alt="lru_call"></p><p>上图展示了代码中近似LRU算法的主要逻辑调用路径。</p><p>其中主要逻辑是在<code>freeMemoryIfNeeded</code>函数中</p><p>首先调用<code>getMaxmemoryState</code>函数判断当前内存的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxmemoryState</span><span class="params">(<span class="keyword">size_t</span> *total, <span class="keyword">size_t</span> *logical, <span class="keyword">size_t</span> *tofree, <span class="keyword">float</span> *level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="keyword">float</span>)mem_used / (<span class="keyword">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用内存低于maxmemory的话，就返回<code>C_OK</code>，否则返回<code>C_ERR</code>。另外，这个函数还通过传递指针型的参数来返回一些额外的信息。</p><ul><li><strong>total</strong>：已使用的字节总数，无论是<code>C_OK</code>还是<code>C_ERR</code>都有效。</li><li><strong>logical</strong>：已使用的内存减去slave或AOF缓冲区后的大小，只有返回<code>C_ERR</code>时有效。</li><li><strong>tofree</strong>：需要释放的内存大小，只有返回<code>C_ERR</code>时有效。</li><li><strong>level</strong>：已使用内存的比例，通常是0到1之间，当超出内存限制时，就大于1。无论是<code>C_OK</code>还是<code>C_ERR</code>都有效。</li></ul><p>判断完内存状态以后，如果内存没有超过使用限制就会直接返回，否则就继续向下执行。此时我们已经知道需要释放多少内存空间了，下面就开始进行释放内存的操作了。每次释放内存都会记录释放内存的大小，直到释放的内存不小于<code>tofree</code>。</p><p>首先根据<code>maxmemory_policy</code>进行判断，对于不同的清除策略有不同的实现方法，我们来看LRU的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">  db = server.db+i;</span><br><span class="line">  dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">    db-&gt;dict : db-&gt;expires;</span><br><span class="line">  <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">    evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">    total_keys += keys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是填充“过期池”，这里遍历了每一个db（验证了我最开始的想法），调用<code>evictionPoolPopulate</code>函数进行填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"><span class="comment">/* some code */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* some code */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k--;</span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* some code */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于篇幅原因，我截取了部分代码，通过这段代码我们可以看到，Redis首先是采样了一部分key，这里采样数量maxmemory_samples通常是5，我们也可以自己设置，采样数量越大，结果就越接近LRU算法的结果，带来的影响是性能随之变差。</p><p>采样之后我们需要获得每个key的空闲时间，然后将其填充到“过期池”中的指定位置。这里“过期池”是按照空闲时间从小到大排序的，也就是说，idle大大key排在最右边。</p><p>填充完“过期池”之后，会从后向前获取到最适合清理的key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line"><span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">  bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">    de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                  pool[k].key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                  pool[k].key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* some code */</span></span><br><span class="line">  <span class="keyword">if</span> (de) &#123;</span><br><span class="line">    bestkey = dictGetKey(de);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到需要删除的key后，就需要根据设置清理策略进行同步/异步清理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">  dbAsyncDelete(db,keyobj);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  dbSyncDelete(db,keyobj)</span><br></pre></td></tr></table></figure><p>最后记下本次清理的空间大小，用来在循环条件判断是否要继续清理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">mem_freed += delta;</span><br></pre></td></tr></table></figure><h3 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h3><p>最后我们来看一下Redis支持的几种清理策略</p><ul><li><strong>noeviction</strong>：不会继续处理写请求（DEL可以继续处理）。</li><li><strong>allkeys-lru</strong>：对所有key的近似LRU</li><li><strong>volatile-lru</strong>：使用近似LRU算法淘汰设置了过期时间的key</li><li><strong>allkeys-random</strong>：从所有key中随机淘汰一些key</li><li><strong>volatile-random</strong>：对所有设置了过期时间的key随机淘汰</li><li><strong>volatile-ttl</strong>：淘汰有效期最短的一部分key</li></ul><p>Redis4.0开始支持了LFU策略，和LRU类似，它分为两种：</p><ul><li><strong>volatile-lfu</strong>：使用LFU算法淘汰设置了过期时间的key</li><li><strong>allkeys-lfu</strong>：从全部key中进行淘汰，使用LFU</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>现在我知道了Redis在内存达到上限时做了哪些事了。以后出问题时也就不会只检查自己的db了。</p><p>关于这次事故的后续处理，我首先是让业务同学回滚了代码，然后让他们使用一个单独的Redis，这样业务再出现类似问题就不会影响到我们的帐号服务了，整体的影响范围也会变得更加可控。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“叮……”，美好的周六就这么被一阵钉钉消息吵醒了。</summary>
    
    
    
    
    <category term="Redis" scheme="https://jackeyzhe.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：齐头并进（下）</title>
    <link href="https://jackeyzhe.github.io/2020/03/23/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://jackeyzhe.github.io/2020/03/23/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-23T13:24:02.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程。<a id="more"></a></p><h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>许多编程语言都会提供原子类型，Rust也不例外，在前文中我们聊了Rust中锁的使用，有了锁，就要小心死锁的问题，Rust虽然声称是安全并发，但是仍然无法帮助我们解决死锁的问题。原子类型就是编程语言为我们提供的无锁并发编程的最佳手段。熟悉Java的同学应该知道，Java的编译器并不能保证代码的执行顺序，编译器会对我们的代码的执行顺序进行优化，这一操作成为指令重排。而Rust的多线程内存模型不会进行指令重排，它可以保证指令的执行顺序。</p><p>通常来讲原子类型会提供以下操作：</p><ul><li>Load：从原子类型读取值</li><li>Store：为一个原子类型写入值</li><li>CAS（Compare-And-Swap）：比较并交换</li><li>Swap：交换</li><li>Fetch-add（sub/and/or）：表示一系列的原子的加减或逻辑运算</li></ul><p>Ok，这些基础的概念聊完以后，我们就来看看Rust为我们提供了哪些原子类型。Rust的原子类型定义在标准库<code>std::sync::atomic</code>中，目前它提供了12种原子类型。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584877213/Blog/rust/13/rust13-1.png" alt="原子类型"></p><p>下面这段代码是Rust演示了如何用原子类型实现一个自旋锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> spinlock = Arc::new(AtomicUsize::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> spinlock_clone = spinlock.clone();</span><br><span class="line">    <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span>|| &#123;</span><br><span class="line">        spinlock_clone.store(<span class="number">0</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> spinlock.load(Ordering::SeqCst) != <span class="number">0</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(panic) = thread.join() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Thread had an error: &#123;:?&#125;"</span>, panic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用AtomicUsize的store方法将它的值设置为0，然后用load方法获取到它的值，如果不是0，则程序一直空转。在store和load方法中，我们都用到了一个参数：<code>Ordering::SeqCst</code>，在声明中能看出来它也是属于atomic包。</p><p>我们在文档中发现它是一个枚举。其定义为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Ordering</span></span> &#123;</span><br><span class="line">    Relaxed,</span><br><span class="line">    Release,</span><br><span class="line">    Acquire,</span><br><span class="line">    AcqRel,</span><br><span class="line">    SeqCst,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是将内存顺序的控制权交给开发者，我们可以自己定义底层的内存排序。下面我们一起来看一下这5种排序分别代表什么意思</p><ul><li>Relaxed：表示「没有顺序」，也就是开发者不会干预线程顺序，线程只进行原子操作</li><li>Release：对于使用Release的store操作，在它之前所有使用Acquire的load操作都是可见的</li><li>Acquire：对于使用Acquire的load操作，在它之前的所有使用Release的store操作也都是可见的</li><li>AcqRel：它代表读时使用Acquire顺序的load操作，写时使用Release顺序的store操作</li><li>SeqCst：使用了SeqCst的原子操作都必须先存储，再加载。</li></ul><p>一般情况下建议使用SeqCst，而不推荐使用Relaxed。</p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>Go语言文档中有这样一句话：<strong>不要使用共享内存来通信，应该使用通信实现共享内存。</strong></p><p>Rust标准库选择了CSP并发模型，也就是依赖channel来进行线程间的通信。它的定义是在标准库<code>std::sync::mpsc</code>中，里面定义了三种类型的CSP进程：</p><ul><li>Sender：发送异步消息</li><li>SyncSender：发送同步消息</li><li>Receiver：用于接收消息</li></ul><p>我们通过一个栗子来看一下channel是如何创建并收发消息的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们先是使用了<code>channel()</code>函数来创建一个channel，它会返回一个（Sender, Receiver）元组。它的缓冲区是无界的。此外，我们还可以使用<code>sync_channel()</code>来创建channel，它返回的则是（SyncSender, Receiver）元组，这样的channel发送消息是同步的，并且可以设置缓冲区大小。</p><p>接着，在子线程中，我们定义了一个字符串变量，并使用<code>send()</code>函数向channel中发送消息。这里send返回的是一个Result类型，所以使用unwrap来传播错误。</p><p>在main函数最后，我们又用<code>recv()</code>函数来接收消息。</p><p>这里需要注意的是，<code>send()</code>函数会转移所有权，所以，如果你在发送消息之后再使用val变量时，程序就会报错。</p><p>现在我们已经掌握了使用Channel进行线程间通信的方法了，这里还有一段代码，感兴趣的同学可以自己执行一下这段代码看是否能够顺利执行。如果不能，应该怎么修改这段代码呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tx = tx.clone();</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            tx.send(i).unwrap();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rx <span class="keyword">in</span> rx.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在实际工作中，如果每次都要创建新的线程，每次创建、销毁线程的开销就会变得非常可观，甚至会成为系统性能的瓶颈。对于这种问题，我们通常使用线程池来解决。</p><p>Rust的标准库中没有现成的线程池给我们使用，不过还是有一些第三方库来支持的。这里我使用的是<a href="https://crates.io/crates/threadpool" target="_blank" rel="noopener">threadpool</a>。</p><p>首先需要在Cargo.toml中增加依赖<code>threadpool = &quot;1.7.1&quot;</code>。然后就可以使用<code>use threadpool::ThreadPool;</code>将ThreadPool引入我们的程序中了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> threadpool::ThreadPool;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n_workers = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> n_jobs = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> pool = ThreadPool::new(n_workers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = channel();</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..n_jobs &#123;</span><br><span class="line">        <span class="keyword">let</span> tx = tx.clone();</span><br><span class="line">        pool.execute(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            tx.send(<span class="number">1</span>).expect(<span class="string">"channel will be there waiting for the pool"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(rx.iter().take(n_jobs).fold(<span class="number">0</span>, |a, b| a + b), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用<code>ThreadPool::new()</code>来创建一个线程池，初始化4个工作线程。使用时用<code>execute()</code>方法就可以拿出一个线程来进行具体的工作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们介绍了Rust并发编程的三种特性：原子类型、线程间通信和线程池的使用。</p><p>原子类型是我们进行无锁并发的重要手段，线程间通信和线程池也都是工作中所必须使用的。当然并发编程的知识远不止于此，大家有兴趣的可以自行学习也可以与我交流讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：齐头并进（上）</title>
    <link href="https://jackeyzhe.github.io/2020/03/15/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://jackeyzhe.github.io/2020/03/15/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E9%BD%90%E5%A4%B4%E5%B9%B6%E8%BF%9B%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-03-15T14:30:49.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如今CPU的计算能力已经非常强大，其速度比内存要高出许多个数量级。为了充分利用CPU资源，多数编程语言都提供了并发编程的能力，Rust也不例外。<a id="more"></a></p><p>聊到并发，就离不开多进程和多线程这两个概念。其中，进程是资源分配的最小单位，而线程是程序运行的最小单位。线程必须依托于进程，多个线程之间是共享进程的内存空间的。进程间的切换复杂，CPU利用率低等缺点让我们在做并发编程时更加倾向于使用多线程的方式。</p><p>当然，多线程也有缺点。其一是程序运行顺序不能确定，因为这是由内核来控制的，其二就是多线程编程对开发者要求比较高，如果不充分了解多线程机制的话，写出的程序就非常容易出Bug。</p><p>多线程编程的主要难点在于如何保证线程安全。什么是线程安全呢？因为多个线程之间是共享内存空间的，因此就会存在同时对相同的内存进行写操作，那就会出现写入数据互相覆盖的问题。如果多个线程对内存只有读操作，没有任何写操作，那么也就不会存在安全问题，我们可以称之为线程安全。</p><p>常见的并发安全问题有<strong>竞态条件</strong>和<strong>数据竞争</strong>两种，竞态条件是指多个线程对相同的内存区域（我们称之为临界区）进行了“读取-修改-写入”这样的操作。而数据竞争则是指一个线程写一个变量，而另一个线程需要读这个变量，此时两者就是数据竞争的关系。这么说可能不太容易理解，不过不要紧，待会儿我会举两个具体的例子帮助大家理解。不过在此之前，我想先介绍一下Rust中是如何进行并发编程的。</p><h3 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h3><p>在Rust标准库中，提供了两个包来进行多线程编程：</p><ul><li>std::thread，定义一些管理线程的函数和一些底层同步原语</li><li>std::sync，定义了锁、Channel、条件变量和屏障</li></ul><p>我们使用std::thread中的<code>spawn</code>函数来创建线程，它的使用非常简单，其参数是一个闭包，传入创建的线程需要执行的程序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们有两个线程，一个主线程，一个是用<code>spawn</code>创建出来的线程，两个线程都执行了一个循环。循环中打印了一句话，然后让线程休眠1毫秒。它的执行结果是这样的：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584253897/Blog/rust/12/rust12-1.png" alt="执行结果"></p><p>从结果中我们能看出两件事：第一，两个线程是交替执行的，但是并没有严格的顺序，第二，当主线程结束时，它并没有等子线程运行完。</p><p>那我们有没有办法让主线程等子线程执行结束呢？答案当然是有的。Rust中提供了<code>join</code>函数来解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样主线程就必须要等待子线程执行完毕。</p><p>在某些情况下，我们需要将一些变量在线程间进行传递，正常来讲，闭包需要捕获变量的引用，这里就涉及到了生命周期问题，而子线程的闭包的存活周期有可能长于当前的函数，这样就会造成悬垂指针，这在Rust中是绝对不允许的。因此我们需要使用<code>move</code>关键字将所有权转移到闭包中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>thread::spawn</code>创建线程是不是非常简单。但是也是因为它的简单，所以可能无法满足我们一些定制化的需求。例如制定线程的栈大小，线程名称等。这时我们可以使用<code>thread::Builder</code>来创建线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::&#123;Builder, current&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thread_name = <span class="built_in">format!</span>(<span class="string">"child-&#123;&#125;"</span>, id);</span><br><span class="line">        <span class="keyword">let</span> size: <span class="built_in">usize</span> = <span class="number">3</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">let</span> builder = Builder::new().name(thread_name).stack_size(size);</span><br><span class="line">        <span class="keyword">let</span> child = builder.spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"in child:&#123;&#125;"</span>, current().name().unwrap());</span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        v.push(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> v &#123;</span><br><span class="line">        child.join().unwrap_or_default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>thread::spawn</code>创建的线程返回的类型是<code>JoinHandle&lt;T&gt;</code>，而使用<code>builder.spawn</code>返回的是<code>Result&lt;JoinHandle&lt;T&gt;&gt;</code>，因此这里需要加上<code>unwrap</code>方法。</p><p>除了刚才提到了这些函数和结构体，<code>std::thread</code>还提供了一些底层同步原语，包括park、unpark和yield_now函数。其中park提供了阻塞线程的能力，unpark用来恢复被阻塞的线程。yield_now函数则可以让线程放弃时间片，让给其他线程执行。</p><h3 id="Send和Sync"><a href="#Send和Sync" class="headerlink" title="Send和Sync"></a>Send和Sync</h3><p>聊完了线程管理，我们再回到线程安全的话题，Rust提供的这些线程管理工具看起来和其他没有什么区别，那Rust又是如何保证线程安全的呢？</p><p>秘密就在<code>Send</code>和<code>Sync</code>这两个trait中。它们的作用是：</p><ul><li>Send：实现Send的类型可以安全的在线程间传递所有权。</li><li>Sync：实现Sync的类型可以安全的在线程间传递不可变借用。</li></ul><p>现在我们可以看一下<code>spawn</code>函数的源码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; <span class="keyword">where</span></span><br><span class="line">    F: <span class="built_in">FnOnce</span>() -&gt; T, F: <span class="built_in">Send</span> + <span class="symbol">'static</span>, T: <span class="built_in">Send</span> + <span class="symbol">'static</span></span><br><span class="line">&#123;</span><br><span class="line">    Builder::new().spawn(f).expect(<span class="string">"failed to spawn thread"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其参数F和返回值类型T都加上了<code>Send + &#39;static</code>限定，Send表示闭包必须实现Send，这样才可以在线程间传递。而<code>&#39;static</code>表示T只能是非引用类型，因为使用引用类型则无法保证生命周期。</p><p>在<a href="https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">Rust入坑指南：智能指针</a>一文中，我们介绍了共享所有权的指针<code>Rc&lt;T&gt;</code>，但在多线程之间共享变量时，就不能使用<code>Rc&lt;T&gt;</code>，因为它的内部不是原子操作。不过不要紧，Rust为我们提供了线程安全版本：<code>Arc&lt;T&gt;</code>。</p><p>下面我们一起来验证一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = Rc::new(<span class="string">"Hello"</span>.to_string());</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> s_clone = s.clone();</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            s_clone.push_str(<span class="string">" world!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会报如下错误</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584278809/Blog/rust/12/rust12-2.png" alt="Rc报错"></p><p>那我们把<code>Rc</code>替换为<code>Arc</code>试一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = Arc::new(<span class="string">"Hello"</span>.to_string());</span><br></pre></td></tr></table></figure><p>很遗憾，程序还是报错。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1584279037/Blog/rust/12/rust12-3.png" alt="Arc报错"></p><p>这是因为，Arc默认是不可变的，我们还需要提供内部可变性。这时你可能想到来RefCell，但是它也是线程不安全的。所以这里我们需要使用<code>Mutex&lt;T&gt;</code>类型。它是Rust实现的互斥锁。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Rust中使用<code>Mutex&lt;T&gt;</code>实现互斥锁，从而保证线程安全。如果类型T实现了Send，那么<code>Mutex&lt;T&gt;</code>会自动实现Send和Sync。它的使用方法也比较简单，在使用之前需要通过<code>lock</code>或<code>try_lock</code>方法来获取锁，然后再进行操作。那么现在我们就可以对前面的代码进行修复了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = Arc::new(Mutex::new(<span class="string">"Hello"</span>.to_string()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> s_clone = s.clone();</span><br><span class="line">        <span class="keyword">let</span> child = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> s_clone = s_clone.lock().unwrap();</span><br><span class="line">            s_clone.push_str(<span class="string">" world!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        v.push(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> v &#123;</span><br><span class="line">        child.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>介绍完了互斥锁之后，我们再来了解一下Rust中提供的另外一种锁——读写锁<code>RwLock&lt;T&gt;</code>。互斥锁用来独占线程，而读写锁则可以支持多个读线程和一个写线程。</p><p>在使用读写锁时要注意，读锁和写锁是不能同时存在的，在使用时必须要使用显式作用域把读锁和写锁隔离开。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们先是介绍了Rust管理线程的两个函数：<code>spawn</code>、<code>join</code>。并且知道了可以使用Builder结构体定制化创建线程。然后又学习了Rust提供线程安全的两个trait，Send和Sync。最后我们一起学习了Rust提供的两种锁的实现：互斥锁和读写锁。</p><p>关于Rust并发编程坑还没有到底，接下来还有条件变量、原子类型这些坑等着我们来挖。今天就暂时歇业了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道，如今CPU的计算能力已经非常强大，其速度比内存要高出许多个数量级。为了充分利用CPU资源，多数编程语言都提供了并发编程的能力，Rust也不例外。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】推荐你使用Vim的三个半理由</title>
    <link href="https://jackeyzhe.github.io/2020/03/11/%E3%80%90%E8%AF%91%E3%80%91%E6%8E%A8%E8%8D%90%E4%BD%A0%E4%BD%BF%E7%94%A8Vim%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8D%8A%E7%90%86%E7%94%B1/"/>
    <id>https://jackeyzhe.github.io/2020/03/11/%E3%80%90%E8%AF%91%E3%80%91%E6%8E%A8%E8%8D%90%E4%BD%A0%E4%BD%BF%E7%94%A8Vim%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8D%8A%E7%90%86%E7%94%B1/</id>
    <published>2020-03-11T14:45:45.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很久以前，软件行业就有一种争论：究竟要不要使用Vim。这种争论有点像音乐界关于模拟信号与数字信号的争论。<a id="more"></a></p><p>在大多数工程师眼中，Vim是一种老旧的，已经过时了的文本编辑器。它缺乏很多优秀的功能，用起来也没有现代的IDE舒服。但实际上，Vim绝对不是一种老旧的文本编辑器。</p><p>Vim就像是手动挡的汽车一样。</p><p>你必须要学会如何去驾驭它，如何手动换挡。而一旦你习惯了以后，就会获得成倍的收获与乐趣。它可以带着你在蜿蜒的小路上行驶，你需要保持全神贯注，并且精巧的换挡。这时你会觉得你和汽车之间仿佛建立了某种连接，它就像是你身体的一部分一样。</p><p>Vim就是这样子，这也是为什么它会如此有趣的原因。</p><p>下面就是我推荐你使用Vim的3个半理由。</p><h3 id="1-不用鼠标"><a href="#1-不用鼠标" class="headerlink" title="1. 不用鼠标"></a>1. 不用鼠标</h3><p>当你使用Vim的时候，你几乎可以不使用鼠标，你必须用键盘去做所有的事情。这会使你成为更强大、更高效的开发者。</p><p>你的手离开键盘的次数越多，你的工作效率就会越低。每次使用鼠标都会拖慢你的工作效率，你的大脑就像CPU一样要进行线程上下文的切换。所以你应该慢慢学会使用快捷键。</p><p>Vim的一大好处就是它只能使用快捷键，你想用鼠标都不行。</p><p>你必须学着习惯这一点。</p><h3 id="2-本地开发"><a href="#2-本地开发" class="headerlink" title="2. 本地开发"></a>2. 本地开发</h3><p>在大多数Unix系统中，默认都可以使用Vim或者Vi。这两者是完全运行在命令行上的编辑器看，由于没有GUI，因此它们更加通用和轻便。</p><p>因为Vim是完全由命令行驱动的，当你使用SSH连接远程服务器编辑文本或者在线修改代码时，就会有飞一样的感觉了。</p><p>在使用像Ubuntu Server这样本身并不包含GUI的系统时，VIm更是显得尤为重要。</p><p>有了Vim，你就不需要在系统直接来回传输文件，也不用使用SSHFS来挂载远程系统了。只需要用vim打开你的配置文件，编辑，然后<code>:wq</code>。</p><h3 id="3-不会分心"><a href="#3-不会分心" class="headerlink" title="3. 不会分心"></a>3. 不会分心</h3><p>你是否真的需要自动补全和集成代码分析呢？你又真的需要那些花里胡哨的UI吗？</p><p>你应该学会的是简单思考，Vim没有那些大型IDE臃肿的功能，它能让你专注于问题的本质：代码。</p><p>使用Vim时，你会变得更加有条理和严谨。你会更加清楚你当前在编辑的是哪个文件，它在什么目录下。即使没有展示在你面前，你也会很清楚它们的位置。</p><p>由于编辑器的简单性，在文件之间进行编辑，剪切，粘贴和移动这些动作会变得更加清晰和明确。</p><p>当然了，有时候你可能需要一些额外的功能。可以通过安装Vim插件来达到目的。这些插件都是按需取用的，你只需要选择你真正需要用的即可。</p><p>你可以使用<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">Pathogen</a>来帮助你管理Vim的插件。</p><h3 id="3½-街头威望"><a href="#3½-街头威望" class="headerlink" title="3½ 街头威望"></a>3½ 街头威望</h3><p>其他不使用Vim的开发人员看到你使用Vim开发时会觉得你很疯狂，你可以利用他们的这种心态来展示自己的优势，同时还能提高影响力。</p><p>记住，你可以比别人开发的更快。因为Vim比那些现代的大型IDE占用的内存要少得多。</p><p>无论你是为了什么目的去使用Vim，抑或是被迫去使用的。你都可以学着去爱上它，这样你自己也会成长很多。</p><p>Vim是最好的厨师才能用的刀。你可以用它来切东西，或者被它切。。。</p><h3 id="译者点评"><a href="#译者点评" class="headerlink" title="译者点评"></a>译者点评</h3><p>Vim在开发中的用处还是很大的，不过我本人也只是把它作为一个文本编辑器来用，写代码还是更习惯用IDE。因为我真的需要代码补全功能。用Vim编程也许只有那些初代目大佬才能做到吧。大家还是可以适当学一学使用Vim，毕竟在外行看来可以算是装X利器了。</p><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://medium.com/better-programming/3%C2%BD-reasons-why-you-should-be-using-vim-8202360afa3" target="_blank" rel="noopener">https://medium.com/better-programming/3%C2%BD-reasons-why-you-should-be-using-vim-8202360afa3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在很久以前，软件行业就有一种争论：究竟要不要使用Vim。这种争论有点像音乐界关于模拟信号与数字信号的争论。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：智能指针</title>
    <link href="https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://jackeyzhe.github.io/2020/03/09/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2020-03-09T14:26:45.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。<a id="more"></a></p><p>智能指针是Rust中一种特殊的数据结构。它与普通指针的本质区别在于普通指针是对值的借用，而智能指针通常拥有对数据的所有权。在Rust中，如果你想要在堆内存中定义一个对象，并不是像Java中那样直接new一个，也不是像C语言中那样需要手动malloc函数来分配内存空间。Rust中使用的是<code>Box::new</code>来对数据进行封箱，而<code>Box&lt;T&gt;</code>就是我们今天要介绍的智能指针之一。除了<code>Box&lt;T&gt;</code>之外，Rust标准库中提供的智能指针还有<code>Rc&lt;T&gt;</code>、<code>Ref&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code>等等。在详细介绍之前，我们还是先了解一下智能指针的基本概念。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们说Rust的智能指针是一种特殊的数据结构，那么它特殊在哪呢？它与普通数据结构的区别在于智能指针实现了<code>Deref</code>和<code>Drop</code>这两个traits。实现<code>Deref</code>可以使智能指针能够解引用，而实现<code>Drop</code>则使智能指针具有自动析构的能力。</p><h4 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h4><p>Deref有一个特性是强制隐式转换：<strong>如果一个类型T实现了Deref&lt;Target=U&gt;，则该类型T的引用在应用的时候会被自动转换为类型U</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = Rc::new(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x.chars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你查看Rc的源码，会发现它并没有实现chars()方法，但我们上面这段代码却可以直接调用，这是因为Rc实现了Deref。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> Rc&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.inner().value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就使得智能指针在使用时被自动解引用，像是不存在一样。</p><p>Deref的内部实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="meta-string">"deref"</span>]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="meta-string">"*"</span>)]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="meta-string">"&amp;*"</span>)]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Deref</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The resulting type after dereferencing.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span>: ?<span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Dereferences the value.</span></span><br><span class="line">    <span class="meta">#[must_use]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[lang = <span class="meta-string">"deref_mut"</span>]</span></span><br><span class="line"><span class="meta">#[doc(alias = <span class="meta-string">"*"</span>)]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DerefMut</span></span>: Deref &#123;</span><br><span class="line">    <span class="comment">/// Mutably dereferences the value.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DerefMut和Deref类似，只不过它是返回可变引用的。</p><h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>Drop对于智能指针非常重要，它是在智能指针被丢弃时自动执行一些清理工作，这里所说的清理工作并不仅限于释放堆内存，还包括一些释放文件和网络连接等工作。之前我总是把Drop理解成Java中的GC，随着对它的深入了解后，我发现它比GC要强大许多。</p><p>Drop的内部实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="meta-string">"drop"</span>]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Drop</span></span> &#123;</span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只有一个drop方法，实现了Drop的结构体，在消亡之前，都会调用drop方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::<span class="built_in">Drop</span>;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop &#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = S(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"create x: &#123;:?&#125;"</span>, x);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> y = S(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"create y: &#123;:?&#125;"</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果为</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583204435/Blog/rust/11/rust11-1.png" alt="结果"></p><p>可以看到x和y在生命周期结束时都去执行了drop方法。</p><p>对智能指针的基本概念就先介绍到这里，下面我们进入正题，具体来看看每个智能指针都有什么特点吧。</p><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<t></t></h3><p>前面我们已经提到了Box<t>在Rust中是用来在堆内存中保存数据使用的。它的使用方法非常简单：</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Box</span>::new(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x.chars())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看一下<code>Box::new</code>的源码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; <span class="built_in">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">box</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里只有一个box关键字，这个关键字是用来进行堆内存分配的，它只能在Rust源码内部使用。box关键字会调用Rust内部的exchange_malloc和box_free方法来管理内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[lang = <span class="meta-string">"exchange_malloc"</span>]</span></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">exchange_malloc</span></span>(size: <span class="built_in">usize</span>, align: <span class="built_in">usize</span>) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        align <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> layout = Layout::from_size_align_unchecked(size, align);</span><br><span class="line">        <span class="keyword">let</span> ptr = alloc(layout);</span><br><span class="line">        <span class="keyword">if</span> !ptr.is_null() &#123;</span><br><span class="line">            ptr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handle_alloc_error(layout)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(not(test), lang = <span class="meta-string">"box_free"</span>)]</span></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">box_free</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt;(ptr: Unique&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> ptr = ptr.as_ptr();</span><br><span class="line">    <span class="keyword">let</span> size = size_of_val(&amp;*ptr);</span><br><span class="line">    <span class="keyword">let</span> align = min_align_of_val(&amp;*ptr);</span><br><span class="line">    <span class="comment">// We do not allocate for Box&lt;T&gt; when T is ZST, so deallocation is also not necessary.</span></span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> layout = Layout::from_size_align_unchecked(size, align);</span><br><span class="line">        dealloc(ptr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc<t></t></h3><p>在前面的学习中，我们知道Rust中一个值在同一时间只能有一个变量拥有其所有权，但有时我们可能会需要多个变量拥有所有权，例如在图结构中，两个图可能对同一条边拥有所有权。</p><p>对于这样的情况，Rust为我们提供了智能指针Rc<t>（reference counting）来解决共享所有权的问题。每当我们通过Rc共享一个所有权时，引用计数就会加一。当引用计数为0时，该值才会被析构。</t></p><p>Rc<t>是单线程引用计数指针，不是线程安全类型。</t></p><p>我们还是通过一个简单的例子来看一下Rc<t>的应用吧。（示例来自<a href="https://doc.rust-lang.org/book/ch15-04-rc.html" target="_blank" rel="noopener">the book</a>）</t></p><p>如果我们想要造一个“双头”的链表，如下图所示，3和4都指向5。我们先来尝试使用Box实现。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583289009/Blog/rust/11/rust11-2.svg" alt="双头链表"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>,</span><br><span class="line">                 <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>,</span><br><span class="line">                               <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在编译时就会报错，因为a绑定给了b以后就无法再绑定给c了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1583289016/Blog/rust/11/rust11-3.png" alt="Box无法共享所有权"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count a &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们可以看到a的引用计数是3，这是因为这里计算的是节点5的引用计数，而a本身也是对5的一次绑定。这种通过clone方法共享所有权的引用称作<strong>强引用</strong>。</p><p>Rust还为我们提供了另一种智能指针Weak<t>，你可以把它当作是Rc<t>的另一个版本。它提供的引用属于<strong>弱引用</strong>。它共享的指针没有所有权。但他可以帮助我们有效的避免循环引用。</t></t></p><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell<t></t></h3><p>前文中我们聊过变量的可变性和不可变性，主要是针对变量的。按照前面所讲的，对于结构体来说，我们也只能控制它的整个实例是否可变。实例的具体某个成员是否可变我们是控制不了的。但在实际开发中，这样的场景也是比较常见的。比如我们有一个User结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    name: <span class="built_in">str</span>,</span><br><span class="line">    age: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们只能修改一个人的名称或者年龄，而不能修改用户的id。如果我们把User的实例设置成了可变状态，那就不能保证别人不会去修改id。</p><p>为了应对这种情况，Rust为我们提供了<code>Cell&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>。它们本质上不属于智能指针，而是可以提供内部可变性的容器。内部可变性实际上是一种设计模式，它的内部是通过一些<code>unsafe</code>代码来实现的。</p><p>我们先来看一下<code>Cell&lt;T&gt;</code>的使用方法吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">u32</span>,</span><br><span class="line">    y: Cell&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo &#123; x: <span class="number">1</span>, y: Cell::new(<span class="number">3</span>)&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, foo.x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, foo.y.get());</span><br><span class="line">    foo.y.set(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, foo.y.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用Cell的set/get方法来设置/获取起内部的值。这有点像我们在Java实体类中的setter/getter方法。这里有一点需要注意：<code>Cell&lt;T&gt;</code>中包裹的T必须要实现Copy才能够使用get方法，如果没有实现Copy，则需要使用Cell提供的get_mut方法来返回可变借用，而set方法在任何情况下都可以使用。由此可见Cell并没有违反借用规则。</p><p>对于没有实现Copy的类型，使用<code>Cell&lt;T&gt;</code>还是比较不方便的，还好Rust还提供了<code>RefCell&lt;T&gt;</code>。话不多说，我们直接来看代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = RefCell::new(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x.borrow());</span><br><span class="line">    x.borrow_mut().push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x.borrow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码中我们可以观察到<code>RefCell&lt;T&gt;</code>的borrow_mut和borrow方法对应了<code>Cell&lt;T&gt;</code>中的set和get方法。</p><p><code>RefCell&lt;T&gt;</code>和<code>Cell&lt;T&gt;</code>还有一点区别是：<code>Cell&lt;T&gt;</code>没有运行时开销（不过也不要用它包裹大的数据结构），而<code>RefCell&lt;T&gt;</code>是有运行时开销的，这是因为使用<code>RefCell&lt;T&gt;</code>时需要维护一个借用检查器，如果违反借用规则，则会引起线程恐慌。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于智能指针我们就先介绍这么多，现在我们简单总结一下。Rust的智能指针为我们提供了很多有用的功能，智能指针的一个特点就是实现了<code>Drop</code>和<code>Deref</code>这两个trait。其中<code>Drop</code>trait中提供了drop方法，在析构时会去调用。<code>Deref</code>trait提供了自动解引用的能力，让我们在使用智能指针的时候不需要再手动解引用了。</p><p>接着我们分别介绍了几种常见的智能指针。<code>Box&lt;T&gt;</code>可以帮助我们在堆内存中分配值，<code>Rc&lt;T&gt;</code>为我们提供了多次借用的能力。<code>RefCell&lt;T&gt;</code>使内部可变性成为现实。</p><p>最后再多说一点，其实我们以前见到过的<code>String</code>和<code>Vec</code>也属于智能指针。</p><p>至于它们为什么属于智能指针，Rust又提供了哪些其他的智能指针呢？这里就留个坑吧，感兴趣的同学可以自己踩一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：朝生暮死</title>
    <link href="https://jackeyzhe.github.io/2020/03/02/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%9D%E7%94%9F%E6%9A%AE%E6%AD%BB/"/>
    <id>https://jackeyzhe.github.io/2020/03/02/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%9D%E7%94%9F%E6%9A%AE%E6%AD%BB/</id>
    <published>2020-03-02T15:17:41.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天想和大家一起把我们之前挖的坑再刨深一些。在Java中，一个对象能存活多久全靠JVM来决定，程序员并不需要去关心对象的生命周期，但是在Rust中就大不相同，一个对象从生到死我们都需要掌握的很清楚。<a id="more"></a></p><p>在<a href="https://jackeyzhe.github.io/2019/10/13/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">Rust入坑指南：核心概念</a>一文中我们介绍了Rust的几个核心概念：所有权（Ownership）、所有权转移和所有权借用。今天就来介绍Rust中的另外一个核心概念：生命周期。</p><p>为什么生命周期要单独介绍呢？因为我在这之前一直没搞清楚Rust中的生命周期参数究竟是怎么一回事。</p><p>现在我终于弄明白了，于是迫不及待要和大家分享，当然如果我有什么说的不对的地方请帮忙指正。</p><p>在Rust中，值的生命周期与作用域有关，这里你可以结合所有权一起理解。在一个函数内，Rust中值的所有权的范围即为其生命周期。Rust通过借用检查器对值的生命周期进行检查，其目的是为了避免出现悬垂指针。这点很容易理解，我们通过一段简单的代码来看一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a;  <span class="comment">// 'a ---------------+</span></span><br><span class="line">    &#123;                   <span class="comment">//       |</span></span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">1</span>; <span class="comment">// 'b ----+   |</span></span><br><span class="line">        a = &amp;b;           <span class="comment">// |   |</span></span><br><span class="line">    &#125;<span class="comment">// ---------------------+   |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a: &#123;&#125;"</span>, a); <span class="comment">//     |</span></span><br><span class="line">&#125; <span class="comment">// ----------------------------+</span></span><br></pre></td></tr></table></figure><p>在上面这段代码中，我已经标注了a和b的生命周期。在代码的第5行，b将所有权出借给了a，而在第7行我们想使用a时，b的生命周期已经结束，也就是说，从第7行开始，a成为了一个悬垂指针。因此这段代码会报一个编译错误。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582994323/Blog/rust/10/rust10-1.png" alt="生命周期编译错误"></p><p>而当所有权在函数之间传递时，Rust的借用检查器就没有办法来确定值的生命周期了。这个时候我们就需要借助生命周期参数来帮助Rust的借用检查器来进行生命周期的检查。生命周期参数分为显式的和隐式的两种。</p><h3 id="显式生命周期参数"><a href="#显式生命周期参数" class="headerlink" title="显式生命周期参数"></a>显式生命周期参数</h3><p>显式生命周期的标注方式通常是<code>&#39;a</code>这样的。它应该写在<code>&amp;</code>之后，<code>mut</code>之前（如果有）。</p><h4 id="函数签名中的生命周期参数"><a href="#函数签名中的生命周期参数" class="headerlink" title="函数签名中的生命周期参数"></a>函数签名中的生命周期参数</h4><p>在正式开始学习之前，我们还要先明确一些概念。下面是一个代有生命周期参数的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span> </span>&lt;<span class="symbol">'a</span>&gt;(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure><p>其中第一个<code>&#39;a</code>，是生命周期参数的声明。参数的生命周期叫做输入声明周期，返回值的生命周期叫做输出生命周期。需要记住的一点是：<strong>输出的生命周期长度不能长于输入的生命周期</strong>。</p><p>另外还要注意：<strong>禁止在没有任何输入参数的情况下返回引用</strong>。因为这样明显会造成悬垂指针。试想当你没有任何输入参数时返回了引用，那么引用本身的值在函数返回时必然会被析构，返回的引用也就成了悬垂指针。</p><p>同样的道理我们可以得出另一个结论：<strong>从函数中返回一个引用，其生命周期参数必须与函数的参数相匹配，否则，标注生命周期参数也毫无意义</strong>。</p><p>说了这么多“不允许”之后，我们来看一个正常使用生命周期参数的例子吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">the_longest</span></span>&lt;<span class="symbol">'a</span>&gt; (s1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, s2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.len() &gt; s2.len() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Rust"</span>);</span><br><span class="line">    <span class="keyword">let</span> s1_r = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"C"</span>);</span><br><span class="line">        <span class="keyword">let</span> res = the_longest(s1_r, &amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125; is the longest"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看这段代码的各个值的生命周期是否符合我们前面说的那一点原则。在调用th_longest函数时，两个参数的生命周期已经确定，s1的生命周期贯穿了main函数，s2的生命周期在内部的代码块中。函数返回时，将返回值绑定给了res，也就是说返回的生命周期为res的生命周期，由于后定义先析构的原则，res的生命周期是短于s2的生命周期的，当然也短于s1的生命周期。因此这个例子符合了我们说的<strong>输出的生命周期长度不能长于输入的生命周期</strong>的原则。</p><p>对于像示例当中有多个参数的函数，我们也可以为其标注不同的生命周期参数，但是编译器无法确定两个生命周期参数的大小，因此需要我们显式的指定。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">the_longest</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>: <span class="symbol">'a</span>&gt; (s1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, s2: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.len() &gt; s2.len() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>&#39;b: &#39;a</code>的意思是<code>&#39;b</code>的存活周期长于<code>&#39;a</code>。这点有些令人疑惑，<code>&#39;a</code>明明是长于<code>&#39;b</code>的，为什么会这样标注呢？还记得我们说过生命周期参数的意义吗？它是用来帮助Rust借用检查器来检查非法借用的，输出生命周期必须短于输入生命周期。因此这里的<code>&#39;a</code>实际上是返回值的生命周期，而不是第一个输入参数的生命周期。</p><p>函数中的生命周期参数的使用我们暂时先介绍到这里。生命周期在其他使用场景中的使用方法也比较类似，不过还是有一些值得注意的地方的。</p><h4 id="结构体中的生命周期参数"><a href="#结构体中的生命周期参数" class="headerlink" title="结构体中的生命周期参数"></a>结构体中的生命周期参数</h4><p>如果一个结构体包含引用类型的成员，那么结构体应该声明生命周期参数<code>&lt;&#39;a&gt;</code>。这是为了保证<strong>结构体实例的生命周期应该短于或等于任意一个成员的生命周期</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcept</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"call me Ishmael. Some year ago..."</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>)</span><br><span class="line">        .next()</span><br><span class="line">        .expect(<span class="string">"Could not find a '.'"</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcept &#123; part: first_sentence&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i.part, <span class="string">"call me Ishmael"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中<code>first_sentence</code>先于结构体实例<code>i</code>被定义，因此<code>i</code>的生命周期是短于<code>first_sentence</code>的，如果反过来，<code>i</code>的生命周期长于<code>first_sentence</code>即长于<code>part</code>，那么在<code>part</code>被析构以后，<code>i.part</code>就会成为悬垂指针。</p><h4 id="方法中的生命周期参数"><a href="#方法中的生命周期参数" class="headerlink" title="方法中的生命周期参数"></a>方法中的生命周期参数</h4><p>现在我们为刚才的结构体增加一个实现方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcept&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_first_sentence</span></span>(s: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> first_sentence = s.split(<span class="string">'.'</span>)</span><br><span class="line">            .next()</span><br><span class="line">            .expect(<span class="string">"Could not find a '.'"</span>);</span><br><span class="line">        first_sentence</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ImportantExcept</code>包含引用成员，因此需要标注生命周期参数。在<code>impl</code>后面声明生命周期参数<code>&lt;&#39;a&gt;</code>在结构体名称后面使用。在<code>get_first_sentence</code>方法中使用的生命周期参数也是刚刚定义好的那个。这样就可以约束输入引用的生命周期长度长于结构体实例的生命周期长度。</p><h4 id="静态生命周期参数"><a href="#静态生命周期参数" class="headerlink" title="静态生命周期参数"></a>静态生命周期参数</h4><p>前面聊的都是我们自己定义的生命周期参数，现在来聊聊Rust中内置的生命周期参数<code>&#39;static</code>。<code>&#39;static</code>生命周期存活于整个程序运行期间。所有的字符串字面量都有<code>&#39;static</code>生命周期，类型为<code>&amp;&#39;static str</code>。</p><h3 id="隐式生命周期参数"><a href="#隐式生命周期参数" class="headerlink" title="隐式生命周期参数"></a>隐式生命周期参数</h3><p>在某些情况下，我们可以省略生命周期参数，对于省略的生命周期参数通常有三条规则：</p><ul><li>每个输入位置上省略的生命周期都将成为一个不同的生命周期参数</li><li>如果只有一个输入生命周期的位置，则该生命周期将分配给输出生命周期</li><li>如果存在多个输入生命周期的位置，但是其中包含&amp;self或&amp;mut self，则self的生命周期将分配给输出生命周期</li></ul><h3 id="生命周期限定"><a href="#生命周期限定" class="headerlink" title="生命周期限定"></a>生命周期限定</h3><p>生命周期参数也可以像trait那样作为范型的限定</p><ul><li>T: ‘a：表示T类型中的任何引用都要“活得”和’a一样长</li><li>T：Trait + ‘a：表示T类型必须实现Trait这个trait，并且T类型中的任何引用都要“活得”和’a一样长</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我把我对Rust生命周期的了解都分享完了。其实只要记住一个原则就可以了，那就是：<strong>生命周期参数的目的是帮助借用检查器验证引用的合法性，避免出现悬垂指针</strong>。</p><p>Rust还有几个深坑，我们下次继续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天想和大家一起把我们之前挖的坑再刨深一些。在Java中，一个对象能存活多久全靠JVM来决定，程序员并不需要去关心对象的生命周期，但是在Rust中就大不相同，一个对象从生到死我们都需要掌握的很清楚。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】教你用16个小时从0构建一个Rust应用</title>
    <link href="https://jackeyzhe.github.io/2020/02/23/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A816%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BB%8E0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AARust%E5%BA%94%E7%94%A8/"/>
    <id>https://jackeyzhe.github.io/2020/02/23/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A816%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BB%8E0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AARust%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-23T15:26:43.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在2019年的最后两天，参加了Prodigy Education举办的黑客马拉松，许多团队聚在一起努力将他们的想法变成现实。<a id="more"></a></p><p>我们之中有的人只是单纯为了好玩，有的是想学一些新的知识，还有些人可能是想证明一些概念或想法。</p><p>我在过去几周总是被动的获取Rust相关信息或使用Rust的代码，因此我认为hackathon是一次学习Rust的绝佳时机。</p><p>hackathon的时间紧迫性使我更加快速的去学习，同时也会去解决现实世界的一些问题。</p><h3 id="为什么是Rust"><a href="#为什么是Rust" class="headerlink" title="为什么是Rust"></a>为什么是Rust</h3><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370825/Blog/Other/learn_rust/lr-2.jpg" alt="Getting a chance to peek under the hood again"></p><p>在我职业生涯的前10年中，有8年都在使用C和C++。</p><p>从好的方面来讲，我喜欢像C++这样可以提供静态类型的语言，因为它能在编译期就能够早早的发现错误。</p><p>我个人对于C++的一些看法是：</p><ul><li>工程师很容易搬起石头砸自己的脚</li><li>作为一门编程语言，它已经非常臃肿且复杂</li><li>缺乏良好的、标准的广泛适用的包管理系统</li></ul><p>自从我改做Web应用以来，一直是做Python和JavaScript开发，使用像Django、Flask和Express这样的框架。</p><p>到目前为止，我在Python和JavaScript中的开发经验是，它们可以提供良好的程序迭代和交付速度，但有时会占用大量的CPU和内存，即使服务是相对空闲的。</p><p>我经常发现自己写好的C++程序，会缺失一些安全性、速度和精简性。</p><p>我想要寻找一种像Rust这样精简的、裸机编程语言来开发web应用。</p><p>没有运行时，没有垃圾回收。直接加载二进制代码，交给内核执行。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我的目标是完成一个后端由Rust编写，前端是JavaScript+React完成的类似于S3作为图床的应用程序，用户可以做以下事情：</p><ul><li>浏览图床中所有的图片（分页可选）</li><li>上传图片</li><li>上传图片时可以给图片增加标签</li><li>通过名称进行查询或过滤</li></ul><p>所有有趣的hackathon项目都有一个名字，所以我决定将这个项目命名为：</p><p>RustIC -&gt; Rust + Image Contents</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370820/Blog/Other/learn_rust/lr3.jpg" alt="Let’s hack something great"></p><p>我认为如果我做到了以下这些事情，那么这次hackathon之行对我个人来说就是成功的：</p><ul><li>对Rust有一个基本的理解，包括它的类型系统和内存模型</li><li>探索S3的对于文件和任意标签的预签名链接功能</li><li>写出一个可以验证的功能正常的应用</li></ul><p>由于我的主要目标是开发功能，同时兼顾学习。很多代码是我一边学一边写的，所以代码组织和效率可能并不是最理想的，因为这些属于次要目标。</p><h3 id="Rust的原则"><a href="#Rust的原则" class="headerlink" title="Rust的原则"></a>Rust的原则</h3><p>在我开始之前，我带着好奇心去了解了要学习的语言的设计师在创建这门语言时内心的原则是什么。我找到了一个<a href="https://doc.rust-lang.org/1.4.0/complement-design-faq.html" target="_blank" rel="noopener">简化版本</a>和一个<a href="https://github.com/dtolnay/rust-faq" target="_blank" rel="noopener">详细版本</a>。</p><p>与我在许多博客上读到的内容相反，Rust是有可能发生内存泄露（循环引用）和之行不安全的操作（unsafe代码块中）的，详细描述在上面的FAQ中。</p><blockquote><p><em>“We [the language creators] do not intend [for Rust] to be 100% static, 100% safe, 100% reflective.”</em></p></blockquote><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370827/Blog/Other/learn_rust/lr-4.jpg" alt="Dazzling, intricate, sophisticated"></p><h3 id="从后端开始"><a href="#从后端开始" class="headerlink" title="从后端开始"></a>从后端开始</h3><p>Google搜索“Rust web framework“，排在最前面的是<a href="https://rocket.rs/" target="_blank" rel="noopener">Rocket</a>。我进入这个网站，发现文档的示例都一目了然。</p><p>有一点需要注意的是Rocket需要Rust的nightly版本，不过在hackathon上这都是小问题。</p><p>GitHub的<a href="https://github.com/SergioBenitez/Rocket/tree/v0.4" target="_blank" rel="noopener">代码库</a>中有着非常丰富的例子。完美！</p><p>我使用<a href="https://doc.rust-lang.org/cargo/" target="_blank" rel="noopener">Cargo</a>创建了一个新的项目，在TOML文件中加入了Rocket依赖，然后跟着Rocket的<a href="https://rocket.rs/v0.4/guide/getting-started/" target="_blank" rel="noopener">入门指南</a>，写了第一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; &amp;<span class="symbol">'static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="string">"Hello, world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    rocket::ignite().mount(<span class="string">"/"</span>, routes![index]).launch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于熟悉Django、Flask、Express等框架等同学来说，这段代码读起来非常容易。作为一名Rocket用户，你可以使用宏作为装饰器来将路由映射到对应的处理函数上。</p><p>在编译时，宏将被扩展。这对开发者是完全透明的。如果你想看扩展后的代码，可以使用<a href="https://github.com/dtolnay/cargo-expand" target="_blank" rel="noopener">cargo-expand</a>。</p><p>以下是我在构建Rust应用程序时的一些有趣的或者有挑战性的亮点：</p><h4 id="指定路由响应"><a href="#指定路由响应" class="headerlink" title="指定路由响应"></a>指定路由响应</h4><p>我想要以JSON的数据格式返回S3中所有的文件列表。</p><p>你可以看到路由关联的处理函数的代码决定了响应类型。</p><p>设置响应结构非常容易，如果你想要返回JSON格式的数据，并且每个字段都有自己的结构和类型，那对应的就是Rust的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以你应该先定义一个结构体`struct(S)`来接受响应，并且需要进行标注：</span><br><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">#[derive(Serialize)]</span><br></pre></td></tr></table></figure></p><p>struct(s)被标记了<code>#[derive(Serialize)]</code>，因此可以通过<code>rocket_contrib::json::Json将它转换成JSON</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Serialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BucketContents</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">Vec</span>&lt;S3Object&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3Object</span></span> &#123;</span><br><span class="line">    file_name: <span class="built_in">String</span>,</span><br><span class="line">    presigned_url: <span class="built_in">String</span>,</span><br><span class="line">    tags: <span class="built_in">String</span>,</span><br><span class="line">    e_tag: <span class="built_in">String</span>, <span class="comment">// AWS generated MD5 checksum hash for object</span></span><br><span class="line">    is_filtered: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/contents?&lt;filter&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_bucket_contents</span></span>(</span><br><span class="line">    filter: <span class="built_in">Option</span>&lt;&amp;RawStr&gt;</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;Json&lt;BucketContents&gt;, Custom&lt;<span class="built_in">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Returns either Ok(Json(BucketContents)) or,</span></span><br><span class="line">    <span class="comment">// a Custom error with a reason</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理分段上传"><a href="#处理分段上传" class="headerlink" title="处理分段上传"></a>处理分段上传</h4><p>当我意识到我的前端很有可能使用POST方法上传格式为<code>multipart/form-data</code>的表单数据时，我就开始深入研究如何使用Rocket来构建程序了。</p><p>不幸的是，Rocket0.4版本不支持multipart，看起来在0.5版本会支持。</p><p>这意味着我需要使用<a href="https://crates.io/crates/multipart" target="_blank" rel="noopener">multipart</a> crate并集成到Rocket中。最终代码可以正常运行，但是如果Rocket支持multipart将会使代码更加简洁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[post(<span class="meta-string">"/upload"</span>, data = <span class="meta-string">"&lt;data&gt;"</span>)]</span></span><br><span class="line"><span class="comment">// signature requires the request to have a `Content-Type`. The preferred way to handle the incoming</span></span><br><span class="line"><span class="comment">// data would have been to use the FromForm trait as described here: https://rocket.rs/v0.4/guide/requests/#forms</span></span><br><span class="line"><span class="comment">// Unfortunately, file uploads are not supported through that mechanism since a file upload is performed as a</span></span><br><span class="line"><span class="comment">// multipart upload, and Rocket does not currently (As of v0.4) support this. </span></span><br><span class="line"><span class="comment">// https://github.com/SergioBenitez/Rocket/issues/106</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">upload_file</span></span>(cont_type: &amp;ContentType, data: Data) -&gt; <span class="built_in">Result</span>&lt;Custom&lt;<span class="built_in">String</span>&gt;, Custom&lt;<span class="built_in">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// this and the next check can be implemented as a request guard but it seems like just</span></span><br><span class="line">    <span class="comment">// more boilerplate than necessary</span></span><br><span class="line">    <span class="keyword">if</span> !cont_type.is_form_data() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(Custom(</span><br><span class="line">            Status::BadRequest,</span><br><span class="line">            <span class="string">"Content-Type not multipart/form-data"</span>.into()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (_, boundary) = cont_type.params()</span><br><span class="line">                                 .find(|&amp;(k, _)| k == <span class="string">"boundary"</span>)</span><br><span class="line">                                 .ok_or_else(</span><br><span class="line">        || Custom(</span><br><span class="line">            Status::BadRequest,</span><br><span class="line">            <span class="string">"`Content-Type: multipart/form-data` boundary param not provided"</span>.into()</span><br><span class="line">        )</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The hot mess that ensues is some weird combination of the two links that follow</span></span><br><span class="line">    <span class="comment">// and a LOT of hackery to move data between closures.</span></span><br><span class="line">    <span class="comment">// https://github.com/SergioBenitez/Rocket/issues/106</span></span><br><span class="line">    <span class="comment">// https://github.com/abonander/multipart/blob/master/examples/rocket.rs</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">Vec</span>::new();</span><br><span class="line">    data.stream_to(&amp;<span class="keyword">mut</span> d).expect(<span class="string">"Unable to read"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mp = Multipart::with_body(Cursor::new(d), boundary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file_name = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> categories_string = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> raw_file_data = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    mp.foreach_entry(|<span class="keyword">mut</span> entry| &#123;</span><br><span class="line">        <span class="keyword">if</span> *entry.headers.name == *<span class="string">"fileName"</span> &#123; </span><br><span class="line">            <span class="keyword">let</span> file_name_vec = entry.data.fill_buf().unwrap().to_owned();</span><br><span class="line">            file_name = from_utf8(&amp;file_name_vec).unwrap().to_string()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> *entry.headers.name == *<span class="string">"tags"</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tags_vec = entry.data.fill_buf().unwrap().to_owned();</span><br><span class="line">            categories_string = from_utf8(&amp;tags_vec).unwrap().to_string();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> *entry.headers.name == *<span class="string">"file"</span> &#123;</span><br><span class="line">            raw_file_data = entry.data.fill_buf().unwrap().to_owned()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).expect(<span class="string">"Unable to iterate"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3_file_manager = s3_interface::S3FileManager::new(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>);</span><br><span class="line">    s3_file_manager.put_file_in_bucket(file_name.clone(), raw_file_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tag_name_val_pairs = <span class="built_in">vec!</span>[(<span class="string">"tags"</span>.to_string(), categories_string)];</span><br><span class="line">    s3_file_manager.put_tags_on_file(file_name, tag_name_val_pairs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(</span><br><span class="line">        Custom(Status::<span class="literal">Ok</span>, <span class="string">"Image Uploaded"</span>.to_string())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置CORS"><a href="#配置CORS" class="headerlink" title="配置CORS"></a>配置CORS</h4><p>路由写好了以后，我就开始用curl或Postman来进行测试了，现在已经是时候开始把前端集成进来了。我需要适当设置响应头以避免跨域问题。</p><p>Rocket依旧没有支持这个特性。</p><p>然后我在GitHub代码库中找到了一些解决方案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CORS Solution below comes from: https://github.com/SergioBenitez/Rocket/issues/25</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io::Cursor;</span><br><span class="line"><span class="keyword">use</span> rocket::fairing::&#123;Fairing, Info, Kind&#125;;</span><br><span class="line"><span class="keyword">use</span> rocket::&#123;Request, Response&#125;;</span><br><span class="line"><span class="keyword">use</span> rocket::http::&#123;Header, ContentType, Method&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CORS</span></span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Fairing <span class="keyword">for</span> CORS &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">info</span></span>(&amp;<span class="keyword">self</span>) -&gt; Info &#123;</span><br><span class="line">        Info &#123;</span><br><span class="line">            name: <span class="string">"Add CORS headers to requests"</span>,</span><br><span class="line">            kind: Kind::Response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">on_response</span></span>(&amp;<span class="keyword">self</span>, request: &amp;Request, response: &amp;<span class="keyword">mut</span> Response) &#123;</span><br><span class="line">        <span class="keyword">if</span> request.method() == Method::Options || </span><br><span class="line">           response.content_type() == <span class="literal">Some</span>(ContentType::JSON) || </span><br><span class="line">           response.content_type() == <span class="literal">Some</span>(ContentType::Plain) &#123;</span><br><span class="line"></span><br><span class="line">            response.set_header(Header::new(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://localhost:3000"</span>));</span><br><span class="line">            response.set_header(Header::new(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST, GET, OPTIONS"</span>));</span><br><span class="line">            response.set_header(Header::new(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type"</span>));</span><br><span class="line">            response.set_header(Header::new(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> request.method() == Method::Options &#123;</span><br><span class="line">            response.set_header(ContentType::Plain);</span><br><span class="line">            response.set_sized_body(Cursor::new(<span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    rocket::ignite().attach(</span><br><span class="line">        CORS()</span><br><span class="line">    ).mount(</span><br><span class="line">        <span class="string">"/"</span>, </span><br><span class="line">        routes![get_bucket_contents, upload_file]</span><br><span class="line">    ).launch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过了一会，我发现了<a href="https://crates.io/crates/rocket_cors" target="_blank" rel="noopener">rocket_cors</a>，它帮助我大幅缩减了代码量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> allowed_origins = AllowedOrigins::some_exact(&amp;[<span class="string">"http://localhost:3000"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cors = rocket_cors::CorsOptions &#123;</span><br><span class="line">        allowed_origins,</span><br><span class="line">        allowed_methods: <span class="built_in">vec!</span>[Method::Get, Method::Post].into_iter().map(<span class="built_in">From</span>::from).collect(),</span><br><span class="line">        allowed_headers: AllowedHeaders::some(&amp;[<span class="string">"Content-Type"</span>, <span class="string">"Authorization"</span>, <span class="string">"Accept"</span>]),</span><br><span class="line">        allow_credentials: <span class="literal">true</span>,</span><br><span class="line">        ..<span class="built_in">Default</span>::default()</span><br><span class="line">    &#125;</span><br><span class="line">    .to_cors()?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rocket::ignite().attach(cors)</span><br><span class="line">                    .mount(<span class="string">"/"</span>, routes![get_bucket_contents, upload_file])</span><br><span class="line">                    .launch();</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h4><p>我们只需要一个简单的<code>cargo run</code>命令就可以让程序运行起来</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370830/Blog/Other/learn_rust/lr-5.png" alt="output"></p><p>我机器上的活动监视器告诉我这个程序正在运行中，并且只消耗了2.7MB内存。</p><p>而且这还只是没有经过优化的调试版本。项目使用<code>- release</code>标签打包的话，运行时只需要1.6MB内存。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370814/Blog/Other/learn_rust/lr-6.png" alt="memory"></p><p>基于Rust的后端服务器，我们请求<code>/contents</code>这个路由会得到如下响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"file_name"</span>: <span class="string">"Duck.gif"</span>,</span><br><span class="line">            <span class="attr">"presigned_url"</span>: <span class="string">"https://s3.amazonaws.com/rustic-images/Duck.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050353Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=1369c003b2f54510882bf9982ab56d024d6c9d2655a4d86f8907313c7499b56d&amp;X-Amz-SignedHeaders=host"</span>,</span><br><span class="line">            <span class="attr">"tags"</span>: <span class="string">"animal"</span>,</span><br><span class="line">            <span class="attr">"e_tag"</span>: <span class="string">"\"93c570cadd6b8b2f85b47c2f14fd82a1\""</span>,</span><br><span class="line">            <span class="attr">"is_filtered"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"file_name"</span>: <span class="string">"GIZMO.png"</span>,</span><br><span class="line">            <span class="attr">"presigned_url"</span>: <span class="string">"https://s3.amazonaws.com/rustic-images/GIZMO.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050353Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=040e76c2df5a9a54ed4fbc8490378cf732b32bae78f628448536fc610018c0c3&amp;X-Amz-SignedHeaders=host"</span>,</span><br><span class="line">            <span class="attr">"tags"</span>: <span class="string">"robots"</span>,</span><br><span class="line">            <span class="attr">"e_tag"</span>: <span class="string">"\"2cde221a0c7a72c0a7a60cffce29a0bc\""</span>,</span><br><span class="line">            <span class="attr">"is_filtered"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"file_name"</span>: <span class="string">"GreenSmile.gif"</span>,</span><br><span class="line">            <span class="attr">"presigned_url"</span>: <span class="string">"https://s3.amazonaws.com/rustic-images/GreenSmile.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIARDWJNDW3U8329UDNJ%2F20200107%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200107T050354Z&amp;X-Amz-Expires=1800&amp;X-Amz-Signature=d115b107de530ce15b3590abdbab355c2a9481a81131f88bf4ad2a59ca11bbac&amp;X-Amz-SignedHeaders=host"</span>,</span><br><span class="line">            <span class="attr">"tags"</span>: <span class="string">"smile-face"</span>,</span><br><span class="line">            <span class="attr">"e_tag"</span>: <span class="string">"\"86854a599540f50bdc5e837d30ca34f9\""</span>,</span><br><span class="line">            <span class="attr">"is_filtered"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端的工作相对简单一些，我们使用的是：</p><ul><li>React</li><li>React Bootstrap</li><li>react-grid-gallery</li><li>react-tags-input</li></ul><p>用户可以在我们的页面浏览图片，也可以通过文件名或标签来进行检索或过滤。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370817/Blog/Other/learn_rust/lr-7.png" alt="images"></p><p>用户还可以通过拖拽来上传文件，并且可以在提交上传之前打上标签。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370815/Blog/Other/learn_rust/lr-8.png" alt="upload"></p><h3 id="我喜欢使用Rust构建应用程序的原因"><a href="#我喜欢使用Rust构建应用程序的原因" class="headerlink" title="我喜欢使用Rust构建应用程序的原因"></a>我喜欢使用Rust构建应用程序的原因</h3><ul><li>Cargo对于依赖和应用管理的程度简直令人惊叹</li><li>编译器对于我们处理编译错误帮助非常大，有位博主在<a href="https://dmerej.info/blog/post/letting-the-compiler-tell-you-what-to-do/" target="_blank" rel="noopener">博客</a>中描述了他是如何按照编译器大指导来写代码的。我的经验也比较类似。</li><li>我需要的每一项功能都有crate，这让我感到非常惊喜</li></ul><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370831/Blog/Other/learn_rust/lr-9.jpg" alt="Crates galore on crates.io! "></p><ul><li>在线的<a href="https://play.rust-lang.org/" target="_blank" rel="noopener">Rust Playground</a>，让我可以运行小的代码片段。</li><li>Rust语言服务器，已经很好的集成到了Visual Studio Code，它能够提供实时错误检查、格式设置、符号查找等。这让我可以在几个小时内不编译就能取得不错的进展。</li></ul><h3 id="不便、惊喜和麻烦"><a href="#不便、惊喜和麻烦" class="headerlink" title="不便、惊喜和麻烦"></a>不便、惊喜和麻烦</h3><p>尽管Rust的文档很棒，但我不得不依赖一些crates的文档和例子。有些crates有很棒的集成测试，提供了一些关于如何使用的提示。当然了，Stack Overflow和Reddit也给我提供了很多帮助。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582370822/Blog/Other/learn_rust/lr-10.jpg" alt="“Where’s the documentation?”"></p><p>另外还要注意的是：</p><ul><li>理解所有权、生命周期和所有权借用会使学习难度陡增，特别是在为期两天的黑客马拉松中努力提供功能时。我将它们与C++做比较并且弄清楚，但有时还是会感到困惑。</li><li>在所有的事情中，<code>Strings</code>拦住了我几分钟，特别是<code>String</code>和<code>&amp;str</code>的区别更是令人困惑——直到我花了些时间来理解所有权、生命周期和所有权借用才搞清楚这些。</li></ul><h3 id="其他的一些观察"><a href="#其他的一些观察" class="headerlink" title="其他的一些观察"></a>其他的一些观察</h3><ul><li>Rust中没有真正意义上的null类型，通常情况下，空值需要用<code>Option</code>类型的<code>None</code>来表示</li><li>模式匹配非常棒，这是我在Scala中最喜欢的一个特性，在Rust中也一样。这种代码看起来表现力很强，并且允许编译器标记未处理的情况。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> bucket_contents &#123;</span><br><span class="line">    <span class="literal">Err</span>(why) =&gt; <span class="keyword">match</span> why &#123;</span><br><span class="line">        S3ObjectError::FileWithNoName =&gt; <span class="literal">Err</span>(Custom(</span><br><span class="line">            Status::InternalServerError,</span><br><span class="line">            <span class="string">"Encountered bucket objects with no name"</span>.into()</span><br><span class="line">        )),</span><br><span class="line">        S3ObjectError::MultipleTagsWithSameName =&gt; <span class="literal">Err</span>(Custom(</span><br><span class="line">            Status::InternalServerError,</span><br><span class="line">            <span class="string">"Encountered a file with a more than one tag named 'tags'"</span>.into()</span><br><span class="line">        ))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">Ok</span>(s3_objects) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> visible_s3_objects: <span class="built_in">Vec</span>&lt;S3Object&gt; = s3_objects.into_iter()</span><br><span class="line">                                                          .filter(|obj| !obj.is_hidden())</span><br><span class="line">                                                          .collect();</span><br><span class="line">        <span class="literal">Ok</span>(Json(BucketContents::new(visible_s3_objects)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说起安全和不安全模式，你仍然可以进行更底层的编程，比如说在不安全的模式下可以和C语言代码通过接口交互。尽管Rust中有很多正确性检查，但你仍然可以在不安全模块中做一些骚操作，例如解引用。读代码的人也可以从不安全模块中获取到很多信息。</li><li>通过<code>Box</code>在堆中分配内存空间，而不是<code>new</code>和<code>delete</code>。刚开始感觉比较奇怪，但是也很容易理解。标准库中还定义了其他的一些<a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html" target="_blank" rel="noopener">智能指针</a>，如果你需要使用引用数量或者弱引用时就可以直接使用。</li><li>Rust中的异常也很有趣，因为它没有异常。你可以选择使用<code>Result&lt;T, E&gt;</code>表示可以恢复的错误，也可以用<code>panic!</code>宏表示不可恢复的错误。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This code:</span></span><br><span class="line"><span class="comment">// 1. Takes a vector of objects representing S3 contents</span></span><br><span class="line"><span class="comment">// 2. Uses filter to remove entries we don't care about</span></span><br><span class="line"><span class="comment">// 3. Uses map to transform each object into another type, but terminates iteration</span></span><br><span class="line"><span class="comment">// .  if the lambda passed to map returns an Err. </span></span><br><span class="line"><span class="comment">// 4. If all iterations produced an Ok(S3Object) result, these are collected into a Vec&lt;S3Object&gt;</span></span><br><span class="line"><span class="keyword">let</span> bucket_contents: <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;S3Object&gt;, S3ObjectError&gt; = bucket_list</span><br><span class="line">        .into_iter()</span><br><span class="line">        .filter(|bucket_obj| bucket_obj.size.unwrap_or(<span class="number">0</span>) != <span class="number">0</span>) <span class="comment">// Eliminate folders</span></span><br><span class="line">        .map(|bucket_obj| &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">None</span> = bucket_obj.key &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(S3ObjectError::FileWithNoName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> file_name = bucket_obj.key.unwrap();</span><br><span class="line">            <span class="keyword">let</span> e_tag = bucket_obj.e_tag.unwrap_or(<span class="built_in">String</span>::new());</span><br><span class="line">            <span class="keyword">let</span> tag_req_output = s3_file_manager.get_tags_on_file(file_name.clone());</span><br><span class="line">            <span class="keyword">let</span> tags_with_categories: <span class="built_in">Vec</span>&lt;Tag&gt; = tag_req_output.into_iter()</span><br><span class="line">                                                            .filter(|tag| tag.key == <span class="string">"tags"</span>)</span><br><span class="line">                                                            .collect();</span><br><span class="line">            <span class="keyword">if</span> tags_with_categories.len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(S3ObjectError::MultipleTagsWithSameName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> tag_value = <span class="keyword">if</span> tags_with_categories.len() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="string">""</span>.to_string()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tags_with_categories[<span class="number">0</span>].value.clone()</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> presigned_url = s3_file_manager.get_presigned_url_for_file(</span><br><span class="line">                file_name.clone()</span><br><span class="line">            );</span><br><span class="line">            <span class="literal">Ok</span>(S3Object::new(</span><br><span class="line">                file_name,</span><br><span class="line">                e_tag,</span><br><span class="line">                tag_value,</span><br><span class="line">                presigned_url,</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">            ))</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br></pre></td></tr></table></figure><p>手册中是这样描述的：</p><blockquote><p>在多数情况下，Rust需要你尽可能了解错误，并且在编译之前对其做出相应的处理。这个需求使你的程序更加健壮，保证你在发布之前就可以发现并处理其中的错误。</p></blockquote><h3 id="要点和教训"><a href="#要点和教训" class="headerlink" title="要点和教训"></a>要点和教训</h3><ul><li>John Carmack曾经将编写Rust的经历描述为“非常有益”。我同意这种感受，这次hackathon给我的感觉就像是打开了一扇新世界的大门并且发现了很多新鲜事物，这些收获绝不仅仅是停留在代码层面的。</li><li>事后看来，我应该更加严谨的选择网络框架的。再多想一下的话，我可能会走出一条不同的道路。我下次可能会选择<a href="http://ironframework.io/" target="_blank" rel="noopener">iron</a>、<a href="https://actix.rs/" target="_blank" rel="noopener">actix-web</a>, 或者是 <a href="https://github.com/tiny-http/tiny-http" target="_blank" rel="noopener">tiny-http</a>。</li><li>我只学到了Rust的皮毛，16个小时是不可能完全成为一名Rustacean的，即使我对这门语言充满了好奇心，也做了一些深入的了解。我对Rust的未来感到兴奋，我认为它为构建应用程序带来了很多规范，它是一种表现力非常丰富的语言，并且能为我们提供与C++性能相当的运行速度和内存性能呢。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="https://github.com/sidshank/rustic-backend" target="_blank" rel="noopener">RustIC后端代码</a></p><p><a href="https://github.com/sidshank/rustic-frontend" target="_blank" rel="noopener">RustIC前端代码</a></p><p><a href="https://www.rusoto.org/" target="_blank" rel="noopener">Rusoto：一个Rust的AWS SDK</a></p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://medium.com/better-programming/learning-to-use-rust-over-a-16-hour-hackathon-5f0ac2f604df" target="_blank" rel="noopener">https://medium.com/better-programming/learning-to-use-rust-over-a-16-hour-hackathon-5f0ac2f604df</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在2019年的最后两天，参加了Prodigy Education举办的黑客马拉松，许多团队聚在一起努力将他们的想法变成现实。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：步步为营</title>
    <link href="https://jackeyzhe.github.io/2020/02/21/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%AD%A5%E6%AD%A5%E4%B8%BA%E8%90%A5/"/>
    <id>https://jackeyzhe.github.io/2020/02/21/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%AD%A5%E6%AD%A5%E4%B8%BA%E8%90%A5/</id>
    <published>2020-02-20T16:05:43.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说：“测试写得好，奖金少不了。”<a id="more"></a></p><p>有经验的开发人员通常会通过单元测试来保证代码基本逻辑的正确性。如果你是一名新手开发者，并且还没体会到单元测试的好处，那么建议你先读一下我之前的一篇文章<a href="https://jackeyzhe.github.io/2018/09/04/%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9C%B0%E4%BD%8D/">代码洁癖系列（七）：单元测试的地位</a>。</p><p>写单元测试一般需要三个步骤：</p><ol><li>准备测试用例，测试用例要能覆盖尽可能多的代码</li><li>执行需要测试的代码</li><li>判断结果，是否是你希望得到的结果</li></ol><p>了解了这些以后，我们就来看看在Rust中应该怎么写单元测试。</p><p>首先我们建立一个library项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new adder --lib</span><br><span class="line">     Created library `adder` project</span><br></pre></td></tr></table></figure><p>然后在src/lib.rs文件中开始写测试代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在命令行运行<code>cargo test</code>就会得到测试结果</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582124140/Blog/rust/09/rust9-1.png" alt="测试结果1"></p><p>可以看到，结果显示，Rust运行了一项测试并且测试通过。后面的Doc-tests我们先放下，以后再聊。</p><p>当然，这并不是我们常见的测试，在日常开发中，我们通常是先写我们的业务代码然后再对各个函数进行单元测试，最后还会对某个模块进行集成测试。那么我们就来模拟一下日常开发过程中应该如何来写测试。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>我们仍然是用上面的项目，先来在src/lib.rs中写一段“业务代码”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    internal_adder(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal_adder</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的代码，对外暴露的函数只是一个加2的功能，内部调用了一个两数相加的函数。现在我们就对这个内部函数做一个单元测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试模块中，如果想要使用我们业务代码中的函数，就需要通过<code>use super::*;</code>将其引入可用范围。接着，还是执行<code>cargo test</code>，测试结果与刚才类似。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582125779/Blog/rust/09/rust9-2.png" alt="测试结果2"></p><p>测了半天全是通过的没什么意思，单元测试真正的作用是要发现代码中的问题，所以我们来尝试一个错误的试一下。假设我们希望2+2等于5。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582127769/Blog/rust/09/rust9-3.png" alt="测试结果3"></p><p>这里我们的assert_eq!左右不相等，引起了线程恐慌，因此导致测试失败。结果中给出了失败的原因，引起失败的位置，并且有一句提示：<code>note: run with RUST_BACKTRACE=1 environment variable to display a backtrace.</code> 我们按照这个提示，设置变量RUST_BACKTRACE=1，此时再执行<code>cargo test</code>。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582128445/Blog/rust/09/rust9-4.png" alt="错误栈"></p><p>Rust就会将错误栈打印出来，根据结果提示，这并不是完整的错误栈，我们还可以将RUST_BACKTRACE设置为full来查看更加详细的信息。这里我就不做演示了。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>接下来我们再演示一下集成测试。我们通常将集成测试单独放到一个目录中，在lib.rs文件中，rust识别测试mod的名称是tests，同样的，我们在src下创建tests目录。<strong>tests</strong>目录下就是我们的所有集成测试代码。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582129708/Blog/rust/09/rust9-5.png" alt="测试目录"></p><p>如图，integration_test是我们测试代码的文件，common目录下的mod.rs文件中是一些集成测试必要的配置。这里我们只是放了一个空的setup函数。</p><p>在集成测试中，我们就要像正常他人使用我们的代码时那样来进行测试，首先需要将我们的mod引入到可用范围，当然还需要加上common的mod。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tests]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    common::setup();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就可以测试我们对外暴露的函数了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582130013/Blog/rust/09/rust9-6.png" alt="集成测试"></p><p>ok，集成测试的方法我们也掌握了。现在来看看一直被我们忽略的Doc-tests吧。</p><h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p>我们已经知道，Rust中的注释是双斜线<code>//</code>，像我们刚刚写的library代码，如果想要把它发布到crate.io上让别人使用，那么我们就需要增加相应的文档，这里文档的每行都应该是三斜线<code>///</code>开头，而文档中也应该放一些例子供他人参考。（注意：下面注释中的代码需要包含在markdown的代码块格式中，这里写上三个`的话文档格式会乱掉。。。运行测试代码时请自行补充）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds two to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = adder::add_two(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(7, answer);</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    internal_adder(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我给add_two函数加上了文档，我们再次执行<code>cargo test</code>命令。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582131276/Blog/rust/09/rust9-7.png" alt="文档测试"></p><p>现在我们就明白了，Doc-tests测试就是运行我们文档中的例子。</p><h3 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h3><p>到目前为止，我们已经知道了在Rust中如何写测试代码了。接下来我们再来了解几个比较常用的特性。</p><h4 id="运行指定的测试代码"><a href="#运行指定的测试代码" class="headerlink" title="运行指定的测试代码"></a>运行指定的测试代码</h4><p>我们在开发过程中肯定不会每次都去跑全量的单元测试，那样太浪费时间了。通常是我们开发完一个功能之后，编写对应的单元测试，然后单独跑这个测试。那么Rust中能不能单独跑一个单元测试呢？答案是肯定的。</p><p>相信细心的同学已经发现了，Rust测试结果中，是针对每个测试单独统计结果，并且每个测试都有自己的名字，像我们前面写的<code>it_works</code>和<code>internal</code>。假设我们的代码中同时存在这两个函数，如果你想要单独跑internal这一个测试，就可以使用<code>cargo test internal</code>命令。</p><p>你也可以使用这种方法来执行多个名称类似的测试，假如我们有名称为<code>internal_a</code>的测试，那么执行<code>cargo test internal</code>命令时它也会被执行。</p><h4 id="忽略某个测试"><a href="#忽略某个测试" class="headerlink" title="忽略某个测试"></a>忽略某个测试</h4><p>当我们有一个测试执行时间非常长的时候，我们一般不会轻易去执行，这时如果你想要执行多个测试，除了用我们上面提到的方法，去指定不同的名称列表以外。还可以把这个测试忽略掉。</p><p>现在我不想执行<code>internal</code>测试了，只需要对代码进行如下改动：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时再来运行测试，结果如图所示。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582212742/Blog/rust/09/rust9-8.png" alt="忽略测试"></p><p>我们发现此时<code>internal</code>测试已经被忽略了。</p><h4 id="测试异常情况"><a href="#测试异常情况" class="headerlink" title="测试异常情况"></a>测试异常情况</h4><p>除了测试代码逻辑正常的情况，我们有时还需要测试一些异常情况，比如接收到非法参数时程序能否返回我们希望看到的异常。</p><p>我们首先来看一下如何测试程序返回异常信息。</p><p>Rust为我们提供了一个叫做should_panic的注解。我们可以使用它来测试程序是否返回异常：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    internal_adder(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal_adder</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"a should bigger than 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(-<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们运行测试时就会发现internal测试通过，因为它发生了线程恐慌，这是我们希望看到的结果。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1582213602/Blog/rust/09/rust9-9.png" alt="测试异常"></p><p>另外，我们还可以再指定我们具体期望的异常，那么就可以在should_panic后面加上expected参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="meta-string">"a should be positive"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(-<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以自行运行一下这段测试代码看看效果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文中我向大家介绍了在Rust中如何进行单元测试、集成测试，还有比较特殊的文档测试。最后还介绍了3种常见的测试特性。</p><p>最后想友情提醒大家一下，在开发过程中，不要写完一堆功能后再开始写单元测试，这时你很有可能会因为测试代码过于繁琐而放弃。建议大家每写一个功能，随即开始进行单元测试，这样也能立即看到自己的代码的执行效果，提高成就感。这就是所谓的“步步为营”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;俗话说：“测试写得好，奖金少不了。”</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】感谢你的Code Review</title>
    <link href="https://jackeyzhe.github.io/2020/02/17/%E3%80%90%E8%AF%91%E3%80%91%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84Code-Review/"/>
    <id>https://jackeyzhe.github.io/2020/02/17/%E3%80%90%E8%AF%91%E3%80%91%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84Code-Review/</id>
    <published>2020-02-17T14:52:18.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名初级工程师，当我看到一些问题时，通常会主动去解决它们，因此我总会进行一些大范围的代码修改。<a id="more"></a></p><p>这意味着我需要发出大量的代码审查。在一次修改中通常会涉及到从UI到数据库的所有部分。</p><p>我对于自己能够维护整个系统而骄傲，也为自己的快速处理问题的能力而骄傲。同时也为自己的勇敢和解决重大问题的能力而自豪。</p><p>直到有一天，一位资深工程师把我拉到一边，给我提出了迄今为止我收到过最好的代码审查返回。它告诉我应该将巨型的代码审查拆分为更小的增量修改。</p><p>我第一反应是感到恼怒。我不理解他为什么要我这么做。我对自己解决重大问题的能力非常有信心！为什么他说我的工作做的不好？！一点一点的进行修改只会拖慢我的脚步！</p><p>虽然当时我还不知道小规模、增量修改的种种好处，但是我很庆幸当时听了这位高级工程师的意见，很高兴我开始学着进行小规模、增量的修改。</p><p>这种方法给我后来的职业生涯带来了巨大的好处。</p><h3 id="增量修改的好处"><a href="#增量修改的好处" class="headerlink" title="增量修改的好处"></a>增量修改的好处</h3><p>进行增量修改有诸多好处，下面我来列举一些。</p><ul><li><strong>更少的合并冲突。</strong>你改的文件越多，和其他人的修改发生冲突的可能性就越大，小规模的修改可以有效的避免冲突，即使有冲突时也能更快的解决。</li><li><strong>更快的代码审查。</strong>对代码审查人员来说，审查5个文件无疑要比审查50多个文件轻松许多。与那些需要面对面交谈十分钟才能开始看的代码相比，小规模的修改能够更快速的开始审查并且更容易解释。当审查人员面对大量的代码审查工作时，他们有可能会犯懒，非常希望能找个人替他们完成这项工作。因此你可能需要花费很长时间才能找到一个愿意审查你的代码的人。</li><li><strong>更早的修正。</strong>你的代码审查者可能与你的思路相左。他们可能会要求你重做所有的事情。如果你之前只花了几个小时进行修改，那么这对你来说可能不是什么大问题。但是如果你在这个问题上已经花费了两天时间，那么重做可能是一件非常痛苦的事情。</li><li><strong>更快速的测试。</strong>如果你的代码修改涉及到了从UI到数据库的所有层级，你可能需要对整个产品进行重新测试。而如果你只进行小规模修改，那就只需要测试你所修改的那部分。如果你需要解决很多代码审查反馈或者是合并很多代码时，这种好处就非常明显了。重新测试所有东西会花费大量的时间，特别是手动测试。</li><li><strong>更少的bug。</strong>小规模修改意味着你不需要同时将所有东西都装进脑子里。你可以专注于你进行优化的这一部分代码，保证你可以把它做到最好。（我曾经见过一个工程师，它对自己的大规模改动感到不知所措，后来他养成了检查和修复都追求完美的习惯。希望你不要成为那样的人，即使没人抱怨，但是你的同事将会慢慢变得不信任你的代码。）</li><li><strong>更容易排除故障。</strong>如果你需要改动一些代码，那么小规模的改动可以帮助你更加容易的定位问题。</li><li><strong>增量部署。</strong>如果你想要不停机更新，那么更小的、增量的改动会帮助你解决这个问题。（但这并不是全部解决方法）</li><li><strong>还原更加简单。</strong>当你写了bug时，你的改动越小，还原就更加简单。如果你合入了大量代码，并且其他人又在后来进行了改动，那么还原你的代码就会是一件非常痛苦的事情。也许你可以进行快速修复，但这并不是一定奏效，生产环境出现事故时，剔除有问题的代码会使团队的其他人更加放心。</li><li><strong>部署回滚更加简单。</strong>如果单次部署更新了web服务和即时生效的UI功能，那么如果你想要回滚后端服务就必须先要回滚UI的改动。由于这样部署方式，想要做到不停机更新可能并不容易。最好的办法就是把它们分别合入代码仓库并部署。</li><li><strong>更低的风险。</strong>这实际上是上述所有情况的结果。</li></ul><h3 id="为你的未来交学费"><a href="#为你的未来交学费" class="headerlink" title="为你的未来交学费"></a>为你的未来交学费</h3><p>那天我从那位高级工程师那里收到的代码审查反馈，已经被证明是职业生涯迄今为止收到的最好的代码审查反馈了。</p><p>多年后，我遇到了另一名工程师，他一直在进行大规模、彻底的变更。我把相同的反馈分享给了他，他看起来很生我的气，但是我完全可以理解他。在我看到他有进步之前，我离开了那家公司，希望他最终能体验到小规模修改带来的好处。</p><p>相信他以后会是一名优秀的工程师。</p><h3 id="译者点评"><a href="#译者点评" class="headerlink" title="译者点评"></a>译者点评</h3><p>小范围的修改确实是很有必要的。我自己在做code review的时候看到那种几百行的代码修改也是很头疼的。作者对于小规模修改的好处总结的还是比较全面的，希望大家能有收获。</p><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://medium.com/better-programming/the-best-code-review-feedback-i-ever-received-43313a503517" target="_blank" rel="noopener">https://medium.com/better-programming/the-best-code-review-feedback-i-ever-received-43313a503517</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名初级工程师，当我看到一些问题时，通常会主动去解决它们，因此我总会进行一些大范围的代码修改。</summary>
    
    
    
    
    <category term="Code Review" scheme="https://jackeyzhe.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>吐血推荐珍藏的IDEA插件</title>
    <link href="https://jackeyzhe.github.io/2020/02/10/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%E7%8F%8D%E8%97%8F%E7%9A%84IDEA%E6%8F%92%E4%BB%B6/"/>
    <id>https://jackeyzhe.github.io/2020/02/10/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%E7%8F%8D%E8%97%8F%E7%9A%84IDEA%E6%8F%92%E4%BB%B6/</id>
    <published>2020-02-10T05:01:05.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前给大家推荐了一些我自己常用的VS Code插件，很多同学表示很受用，并私信我说要再推荐一些IDEA插件。作为一名职业Java程序员/业余js开发者，我平时还是用IDEA比较多，所以也确实珍藏了一些IDEA插件。今天就一并分享给大家。<a id="more"></a></p><p>在最开始，我还是想先介绍一下IDEA中如何安装插件，首先打开Preferences（菜单栏打开或者使用快捷键Command+,）在Windows版本中应该是Settings。然后选择Plugins一栏，就可以从右侧的MarketPlace中选择自己需要的插件进行安装了。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581059914/Blog/Other/idea_plugins/idea.png" alt="idea插件"></p><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>首先向我们走来的是Lombok。作为Java程序员，你还在为不断的写Getter/Setter方法而苦恼吗？你还在为每个Model类都要写类似的构造方法而感到烦恼吗？赶快试试Lombok吧，它可以有效帮助你解决这些问题，只需要一个注解，构造方法和Getter/Setter方法全部搞定，再也不用把时间浪费在无用功上了。</p><p>如果你还不是很了解Lombok的话，可以自己动手，到<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok官网</a>学习一番，学完记得回来点赞。</p><p>最后展示一个简单的例子供大家参考。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581059921/Blog/Other/idea_plugins/idea1.png" alt="lombok"></p><h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p>String Manipulation插件是一款非常强大的插件，它可以对代码进行很多操作，如排序、去除空行、字符串格式转换、Encode/Decode。其中我最常用的是字符串格式转换。你可以通过点击右键选择String Manipulation或者使用快捷键Option + M来选择相应的功能。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581061347/Blog/Other/idea_plugins/idea2.gif" alt="String Manipulation"></p><h3 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h3><p>作为一名高级CtrlCV工程师，我写代码有两大利器，一个是Google，另一个就是stackoverflow。两者相辅相成，帮我在编码的道路上越走越远。相信有不少同学跟我一样离不开stackoverflow，那么这款插件就会给你带来极大的方便，遇到问题怎么办？右键一下，点击「search stackoverflow」，大部分问题都可以轻松搞定。</p><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h3><p>在推荐VS Code的插件时我们就介绍过一款叫做Bracket Pair Colorizer的插件，它可以把括号变成不同的颜色，我觉得这样分辨括号非常方便，看起来也比较美观。所以在IDEA中也使用了相同效果的插件，就是Rainbow Brackets。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581062247/Blog/Other/idea_plugins/idea3.png" alt="Rainbow Brackets"></p><h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>我们在接外部接口时，别人给了一串JSON串，我们在代码中需要将JSON中的字段封装到一个类中，一个一个输入挺麻烦的，这时GsonFormat就可以派上用场了。它可以帮助我们根据JSON中的key快速生成我们需要的类。</p><p>它的使用快捷键是Option + S</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581066692/Blog/Other/idea_plugins/idea4.gif" alt="GsonFormat"></p><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>如果你的项目使用的构建工具是Maven的话，这个插件就能帮你避免各种依赖冲突，安装好插件之后，打开pom文件，可以看到最下方有一个叫Dependency Analyzer的Tab，这里就可以看到你的哪些依赖是有冲突的，然后在右侧Exclude掉不需要的依赖。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1581063616/Blog/Other/idea_plugins/idea5.png" alt="Maven Helper"></p><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p>RestfulToolkit是一套辅助开发Restful服务的工具集，对于这个插件，我最常用的功能就是快速查找指定的url对应的方法。快捷键是Command + \</p><p>关于其他的一些功能，大家有兴趣的话可以直接访问该插件的<a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit" target="_blank" rel="noopener">homepage</a>。</p><p>以上这些就是我常用的IDEA插件了，没有太多花里胡哨的东西，大家如果有什么好用的插件也欢迎分享出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前给大家推荐了一些我自己常用的VS Code插件，很多同学表示很受用，并私信我说要再推荐一些IDEA插件。作为一名职业Java程序员/业余js开发者，我平时还是用IDEA比较多，所以也确实珍藏了一些IDEA插件。今天就一并分享给大家。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：海纳百川</title>
    <link href="https://jackeyzhe.github.io/2020/01/14/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%B5%B7%E7%BA%B3%E7%99%BE%E5%B7%9D/"/>
    <id>https://jackeyzhe.github.io/2020/01/14/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%B5%B7%E7%BA%B3%E7%99%BE%E5%B7%9D/</id>
    <published>2020-01-13T16:24:45.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊Rust中两个重要的概念：泛型和trait。很多编程语言都支持泛型，Rust也不例外，相信大家对泛型也都比较熟悉，它可以表示任意一种数据类型。trait同样不是Rust所特有的特性，它借鉴于Haskell中的Typeclass。简单来讲，Rust中的trait就是对类型行为的抽象，你可以把它理解为Java中的接口。<a id="more"></a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在前面的文章中，我们其实已经提及了一些泛型类型。例如Option<t>、Vec<t>和Result&lt;T, E&gt;。泛型可以在函数、数据结构、Enum和方法中进行定义。在Rust中，我们习惯使用T作为通用的类型名称，当然也可以是其他名称，只不过习惯上优先使用T（Type）来表示。它可以帮我们消除一些重复代码，例如实现逻辑相同但参数类型不同的两个函数，我们就可以通过泛型技术将其进行合并。下面我们分别演示泛型的几种定义。</t></t></p><h4 id="在函数中定义"><a href="#在函数中定义" class="headerlink" title="在函数中定义"></a>在函数中定义</h4><p>泛型在函数的定义中，可以是参数，也可以是返回值。前提是必须要在函数名的后面加上<t>。</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br></pre></td></tr></table></figure><h4 id="在数据结构中定义"><a href="#在数据结构中定义" class="headerlink" title="在数据结构中定义"></a>在数据结构中定义</h4><p>如果数据结构中某个字段可以接收任意数据类型，那么我们可以把这个字段的类型定义为T，同样的，为了让编译器认识这个T，我们需要在结构体名称后边标识一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，x和y都是可以接受任意类型，但是，它们两个的类型必须相同，如果传入的类型不同，编译器仍然会报错。那如果想要让x和y能够接受不同的类型应该怎么办呢？其实也很简单，我们定义两种不同的泛型就好了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Enum中定义"><a href="#在Enum中定义" class="headerlink" title="在Enum中定义"></a>在Enum中定义</h4><p>在Enum中定义泛型我们已经接触过比较多了，最常见的例子就是Option<t>和Result&lt;T, E&gt;。其定义方法也和在数据结构中的定义方法类似</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在方法中定义"><a href="#在方法中定义" class="headerlink" title="在方法中定义"></a>在方法中定义</h4><p>我们在实现定义了泛型的数据结构或Enum时，方法中也可以定义泛型。例如我们对刚刚定义的Point<t>进行实现。</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们的方法返回值的类型是T的引用，为了让编译器识别T，我们必须要在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外，我们在对结构体进行实现时，也可以实现指定的类型，这样就不需要在```impl```后面加标识了。</span><br><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">impl Point&lt;f32&gt; &#123;</span><br><span class="line">    fn distance_from_origin(&amp;self) -&gt; f32 &#123;</span><br><span class="line">        (self.x.powi(2) + self.y.powi(2)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解了泛型的几种定义之后，你有没有想过一个问题：Rust中使用泛型会对程序运行时的性能造成不良影响吗？答案是不会，因为Rust对于泛型的处理都是在编译阶段进行的，对于我们定义的泛型，Rust编译器会对其进行单一化处理，也就是说，我们定义一个具有泛型的函数（或者其他什么的），Rust会根据需要将其编译为具有具体类型的函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integer = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> float = <span class="literal">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p>例如我们的代码使用了这两种类型的Option，那么Rust编译器就会在编译阶段生成两个指定具体类型的Option。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_i32</span></span> &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="built_in">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_f64</span></span> &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="built_in">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在运行阶段直接使用对应的Option就可以了，而不需要再进行额外复杂的操作。所以，如果我们泛型定义并使用的范围很大，也不会对运行时性能造成影响，受影响的只有编译后程序包的大小。</p><h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p>Trait可以说是Rust的灵魂，Rust中所有的抽象都是依靠Trait来实现的。</p><p>我们先来看看如何定义一个Trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义trait使用了关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        String::from(&quot;(Read more...)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于这样的写法，它表示summarize函数的默认实现。</p><h4 id="Trait的实现"><a href="#Trait的实现" class="headerlink" title="Trait的实现"></a>Trait的实现</h4><p>上面是一种默认实现，接下来我们介绍一下在Rust中，对一个Trait的常规实现。Trait的实现是需要针对结构体的，即我们要写明是哪个结构体的哪种行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们分别定义了结构体NewArticle和Tweet，然后为它们实现了trait，定义了summarize函数对应的逻辑。</p><h4 id="作为参数的Trait"><a href="#作为参数的Trait" class="headerlink" title="作为参数的Trait"></a>作为参数的Trait</h4><p>此外，trait还可以作为函数的参数，也就是需要传入一个实现了对应trait的结构体的实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作参数时，我们需要使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rust还提供了另一种语法糖来，即**Trait限定**，我们可以使用泛型约束的语法来限定Trait参数。</span><br><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">pub fn notify&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上述代码，我们可以通过Trait来限定泛型T的范围。这样的语法糖可以在多个参数的函数中帮助我们简化代码。下面两行代码就有比较明显的对比</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br></pre></td></tr></table></figure><p>如果某个参数有多个trait限定，就可以使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">pub fn notify&lt;T: Summary + Display&gt;(item: T) &#123;</span><br></pre></td></tr></table></figure></p><p>如果我们有更多的参数，并且有每个参数都有多个trait限定，及时我们使用了上面这种语法糖，代码仍然有些繁杂，会降低可读性。所以Rust又为我们提供了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32</span><br><span class="line">    where T: Display + Clone,</span><br><span class="line">          U: Clone + Debug</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></p><p>它帮助我们在函数定义的最后写一个trait限定列表，这样可以使代码的可读性更高。</p><h4 id="Trait作为返回值"><a href="#Trait作为返回值" class="headerlink" title="Trait作为返回值"></a>Trait作为返回值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trait作为返回值类型，和作为参数类似，只需要在定义返回类型时使用<code>impl Trait</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们简单介绍了泛型和Trait，包括它们的定义和使用方法。泛型主要是针对数据类型的一种抽象，而Trait则是对数据类型行为的一种抽象，Rust中并没有严格意义上的继承，多是用组合的形式。这也体现了「多组合，少继承」的设计思想。</p><p>最后留个预告，这个坑还没完，我们下次继续往深处挖。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来聊Rust中两个重要的概念：泛型和trait。很多编程语言都支持泛型，Rust也不例外，相信大家对泛型也都比较熟悉，它可以表示任意一种数据类型。trait同样不是Rust所特有的特性，它借鉴于Haskell中的Typeclass。简单来讲，Rust中的trait就是对类型行为的抽象，你可以把它理解为Java中的接口。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>【译】教你用50种语言写Hello, World</title>
    <link href="https://jackeyzhe.github.io/2020/01/06/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A850%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%99Hello-World/"/>
    <id>https://jackeyzhe.github.io/2020/01/06/%E3%80%90%E8%AF%91%E3%80%91%E6%95%99%E4%BD%A0%E7%94%A850%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%99Hello-World/</id>
    <published>2020-01-06T14:29:19.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们学习一门新的语言时，“Hello, World!“通常是我们所写的第一个程序。相信作为一名程序员的你，职业生涯中至少完成了一个“Hello, World!“程序。程序员一般也都会使用多门语言，甚至有多数人都会使用十几种语言。<a id="more"></a></p><p>甚至有一个名为TTHW的指标来衡量一个程序员接触一门新的编程语言时，成功写出“Hello, World!“并运行所需要的时间。</p><p>然而，如果我问你，你会用多少种编程语言写“Hello, World!“？你的答案会是多少？</p><p>为了刷新你的记忆，我会带你经历一段计算机编程领域的时空之旅。为此，我将向你展示50种不同的编程语言的</p><p>“Hello, World!“程序的写法。你也会了解计算机语言随着时间的推进发生了哪些变化。</p><h3 id="1-汇编语言-1949"><a href="#1-汇编语言-1949" class="headerlink" title="1. 汇编语言 - 1949"></a>1. 汇编语言 - 1949</h3><p>汇编语言诞生于1949年。本文我向你展示的是适用于Intel 8080的8位处理器的，发布于1974年4月的汇编语言经典代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bdos    equ    0005H    ; BDOS entry point</span><br><span class="line">start:  mvi    c,9      ; BDOS function: output string</span><br><span class="line">        lxi    d,msg$   ; address of msg</span><br><span class="line">        call   bdos</span><br><span class="line">        ret             ; return to CCP</span><br><span class="line">  </span><br><span class="line">msg$:   db    &apos;Hello, world!$&apos;</span><br><span class="line">end     start</span><br></pre></td></tr></table></figure><h3 id="2-Fortran-1957"><a href="#2-Fortran-1957" class="headerlink" title="2. Fortran - 1957"></a>2. Fortran - 1957</h3><p>Fortran是Formula Translation的衍生物，这是一种通用的交互式编程语言，特别适合于数值和科学计算。Fortran创建于1957年，下面是它的第一个“Hello, World!”程序：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">PROGRAM</span></span> Hello</span><br><span class="line"><span class="built_in">WRITE</span> (*,*) <span class="string">'Hello, World!'</span></span><br><span class="line"><span class="keyword">STOP</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>Fortran 90 或 95的写法有所不同：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">PROGRAM</span></span> Hello</span><br><span class="line"><span class="built_in">WRITE</span> (*,*) <span class="string">'Hello, World!'</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">PROGRAM</span></span> Hello</span><br></pre></td></tr></table></figure><h3 id="3-Lisp-1958"><a href="#3-Lisp-1958" class="headerlink" title="3. Lisp - 1958"></a>3. Lisp - 1958</h3><p>Lisp是最古老的编程语言系列，它既是交互式的又是函数式的。1958年，Lisp作为一种实用的演示程序模型被创建出来，但是直到1970和1980年代，Lisp才成为人工智能世界中非常流行的语言。</p><p>下面是Lisp的“Hello, World!”程序：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">write-line</span> <span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Cobol-1959"><a href="#4-Cobol-1959" class="headerlink" title="4. Cobol - 1959"></a>4. Cobol - 1959</h3><p>Cobol语言于1959年正式创立，并且在2019年刚刚庆祝过创立60周年。Cobol表示面向通用业务的语言（COmmon Business Oriented Language），目标是成为编程业务应用程序的通用语言。在2019年，Cobol仍被广泛应用于银行和保险的相关系统中。</p><p>下面是Cobol的“Hello, World!”程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IDENTIFICATION DIVISION.</span><br><span class="line">PROGRAM-ID. HELLO-WORLD.</span><br><span class="line">PROCEDURE DIVISION.</span><br><span class="line">    DISPLAY &quot;Hello, World!&quot;</span><br><span class="line">    STOP RUN.</span><br></pre></td></tr></table></figure><h3 id="5-BASIC-1964"><a href="#5-BASIC-1964" class="headerlink" title="5. BASIC - 1964"></a>5. BASIC - 1964</h3><p>BASIC是Beginner’s All-purpose Symbolic Instruction Code（初学者通用符号说明代码）的缩写。它是一门高级编程语言，其主要目标在于易用。它的“Hello, World!”程序如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRINT "Hello, World!"</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="6-Logo-1968"><a href="#6-Logo-1968" class="headerlink" title="6. Logo - 1968"></a>6. Logo - 1968</h3><p>Logo旨在成为易用的Lisp，通常被称为“Lisp without brackets”，Logs并不是面向对象编程语言，但它可以帮助你入门计算机编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print [Hello World !]</span><br></pre></td></tr></table></figure><h3 id="7-B-1969"><a href="#7-B-1969" class="headerlink" title="7. B - 1969"></a>7. B - 1969</h3><p>B语言创建于1969年，它现在已经过时了，但它的计算机编程语言的发展史上发挥着重要的作用。因为正是B语言启发了现在广泛应用的C语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  putstr(&quot;Hello world!*n&quot;);</span><br><span class="line">  return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是语法层面就非常像C语言了。</p><h3 id="8-Pascal-1970"><a href="#8-Pascal-1970" class="headerlink" title="8. Pascal - 1970"></a>8. Pascal - 1970</h3><p>Pascal是一种交互式编程语言，它创建于1970年。它被设计出来主要出于教学目的，因为这个语言的特点是清晰，且严格的语法有助于良好的程序结构。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  writeln(<span class="string">'Hello, World!'</span>)</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>Turbo Pascal是Pascal语言的集成开发环境，在1983年被创建，并在1980年代和1990年代取得了巨大的成功。</p><p>Turbo Pascal的“Hello, World!“程序如下：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> HelloWorld(output);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  writeln(<span class="string">'Hello, World!'</span>);</span><br><span class="line">  readln;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h3 id="9-Forth-1970"><a href="#9-Forth-1970" class="headerlink" title="9. Forth - 1970"></a>9. Forth - 1970</h3><p>Forth是一门基于栈的交互式编程语言，由Charles H. Moore在1960年代发明。但它的第一个大版本是在1970年发布的。它于1994年被ANSI标准化，并于1997年被ISO采纳。2014年的Forth2012为语言的发展又焕发了生机。</p><p>下面是1970年版本Forth语言的“Hello, World!” 程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: HELLO  ( -- )  .&quot; Hello, World!&quot; CR ;</span><br><span class="line">  HELLO</span><br></pre></td></tr></table></figure><h3 id="10-C-1972"><a href="#10-C-1972" class="headerlink" title="10. C - 1972"></a>10. C - 1972</h3><p>1972年的贝尔实验室中，Dennis Ritchie和Ken Thompson两位大佬为了开发UNIX发明了C语言。Ken Thompson曾开发过B语言，Dennis Ritchie决定通过对B语言添加类型来创造C语言。所以说B语言为C语言提供了灵感。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Smalltalk-1972"><a href="#11-Smalltalk-1972" class="headerlink" title="11. Smalltalk - 1972"></a>11. Smalltalk - 1972</h3><p>Smalltalk受到Lisp的启发，它是一门面向对象的，动态类型的编程语言，它被发明于1972年。Smalltalk是最早具有集成开发环境的编程语言之一。</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Transcript</span> show: <span class="string">'Hello, world!'</span>; cr.</span><br></pre></td></tr></table></figure><h3 id="12-Prolog-1972"><a href="#12-Prolog-1972" class="headerlink" title="12. Prolog - 1972"></a>12. Prolog - 1972</h3><p>Prolog是与人工智能和计算语言学相关的逻辑编程语言，被创建于1972年。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:- write(&apos;Hello, World!&apos;),nl.</span><br></pre></td></tr></table></figure><h3 id="13-ML-1973"><a href="#13-ML-1973" class="headerlink" title="13. ML - 1973"></a>13. ML - 1973</h3><p>ML是Meta Language的简称，是一种以Lisp为基础的函数型编程语言。ML通常以Lisp为特征，具有类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello, World!\n&quot;;</span><br></pre></td></tr></table></figure><h3 id="14-Scheme-1975"><a href="#14-Scheme-1975" class="headerlink" title="14. Scheme - 1975"></a>14. Scheme - 1975</h3><p>Scheme创建于1975年，是一种多范式编程语言，支持函数式和交互式编程。它是Lisp三种重要的变种之一，由Common Lisp和Clojure共同开发。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">display</span></span> <span class="string">"Hello, World!"</span>) (<span class="name"><span class="builtin-name">newline</span></span>)</span><br></pre></td></tr></table></figure><h3 id="15-SQL-1978"><a href="#15-SQL-1978" class="headerlink" title="15. SQL - 1978"></a>15. SQL - 1978</h3><p>SQL即结构化查询语言，是用于操作关系数据库的标准计算机编程语言。虽然在设计时不能创建简单的“Hello, World!“程序，但我想写出来应该是一个有趣的程序，如果你想学习SQL，这里有一些<a href="https://hackernoon.com/top-5-sql-and-database-courses-to-learn-online-48424533ac61?source=user_profile---------3------------------" target="_blank" rel="noopener">推荐课程</a>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> message (<span class="built_in">text</span> <span class="built_in">char</span>(<span class="number">15</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> message (<span class="built_in">text</span>) <span class="keyword">VALUES</span> (<span class="string">'Hello, World!'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">text</span> <span class="keyword">FROM</span> message;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> message;</span><br></pre></td></tr></table></figure><h3 id="16-C-1980"><a href="#16-C-1980" class="headerlink" title="16. C++ - 1980"></a>16. C++ - 1980</h3><p>C++是由Bjarne Stroustrup在1980年创建，他为C语言增加了类，在1983年得名C++。现在C++已经通过了ISO标准化，并广泛应用于工业和其他领域。如果你想要学习C++，这里有一些<a href="https://hackernoon.com/top-5-free-c-courses-to-learn-programming-in-2019-d27352277da0" target="_blank" rel="noopener">推荐课程</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-Ada-1983"><a href="#17-Ada-1983" class="headerlink" title="17. Ada - 1983"></a>17. Ada - 1983</h3><p>Ada是一种面向对象编程语言，其开发始于1980年初，并在1983年完成发布。之所以叫做Ada是为了纪念Ada Lovelace，这可能是历史上第一位女性计算机科学家。</p><p>Ada通常用于需要很高可靠性和安全性的实时系统和嵌入式系统中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with Ada.Text_IO;</span><br><span class="line">procedure Hello is</span><br><span class="line">begin</span><br><span class="line">   Ada.Text_IO.Put_Line (&quot;Hello, World!&quot;);</span><br><span class="line">end Hello;</span><br></pre></td></tr></table></figure><h3 id="18-Common-Lisp-1984"><a href="#18-Common-Lisp-1984" class="headerlink" title="18. Common Lisp - 1984"></a>18. Common Lisp - 1984</h3><p>Common Lisp，通常缩写为CL，是ANSI标准化的Lisp语言规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(princ &quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="19-MATLAB-1984"><a href="#19-MATLAB-1984" class="headerlink" title="19. MATLAB - 1984"></a>19. MATLAB - 1984</h3><p>MATLAB是一种用于数值计算的脚本语言，被用于“Matrix Laboratory”。MATLAB是由同名的开发环境模拟的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">'Hello, World!'</span>)</span><br></pre></td></tr></table></figure><h3 id="20-Eiffel-1985"><a href="#20-Eiffel-1985" class="headerlink" title="20. Eiffel - 1985"></a>20. Eiffel - 1985</h3><p>Eiffel是一种围绕设计方法设计的面向对象编程语言，它具有当下非常流行的概念，例如“按约定编程”或复用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class</span><br><span class="line">    HELLO_WORLD</span><br><span class="line">create</span><br><span class="line">    make</span><br><span class="line">feature</span><br><span class="line">    make</span><br><span class="line">        do</span><br><span class="line">            print (&quot;Hello, world!%N&quot;)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="21-Objective-C-1986"><a href="#21-Objective-C-1986" class="headerlink" title="21. Objective-C - 1986"></a>21. Objective-C - 1986</h3><p>Objective-C是一种面向对象编程语言，它像C++一样，是C语言的扩展，而与C++的区别在于它的动态消息分发或动态加载。</p><p>现在，它主要用于Apple操作系统：macOS以及iOS的衍生品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-Erlang-1986"><a href="#22-Erlang-1986" class="headerlink" title="22. Erlang - 1986"></a>22. Erlang - 1986</h3><p>Erlang是一种支持多种范式的编程语言：并发、实时、分布式。它基于Actor Model，具有容错能力以及代码热更新能力，所以Erlang开发的应用可用性通常很高。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io:format(<span class="string">"Hello world!~n"</span>).</span><br></pre></td></tr></table></figure><h3 id="23-Perl-1987"><a href="#23-Perl-1987" class="headerlink" title="23. Perl - 1987"></a>23. Perl - 1987</h3><p>Perl是由Larry Wall在1987年创建的编程语言，它可以轻松处理基于文本的消息。Perl是一种解释型语言，它受C语言的控制和打印结构以及shell脚本的启发。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"Hello, World!\n"</span>;</span><br></pre></td></tr></table></figure><h3 id="24-Caml-1987"><a href="#24-Caml-1987" class="headerlink" title="24. Caml - 1987"></a>24. Caml - 1987</h3><p>Caml代表Categorical Abstract Machine Language（分类抽象机器语言），是一种通用的编程语言，旨在提高程序的安全性和可靠性。Caml是一种致力于函数式、交互式和面向对象风格，这也是一种非常独特的语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_string &quot;Hello, World!\n&quot;;;</span><br></pre></td></tr></table></figure><h3 id="25-Tcl-1988"><a href="#25-Tcl-1988" class="headerlink" title="25. Tcl - 1988"></a>25. Tcl - 1988</h3><p>Tool Command Language（工具命令行语言），是John Ousterhout在1988年开发的一种脚本语言。它是一种动态类型语言，具有跨平台、可扩展、易学习等特点。并且可以轻松和C语言进行交互。</p><p>在1990年， John Ousterhout又开发了Tcl的扩展——Tk，这是一个可移植的用于创建图形界面的库。我们今天所讨论的Tcl，多数情况是指Tcl和Tk的组合。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">puts</span> <span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure><h3 id="26-Haskell-1990"><a href="#26-Haskell-1990" class="headerlink" title="26. Haskell - 1990"></a>26. Haskell - 1990</h3><p>Haskell是一种基于lambda计算和组合逻辑的函数式编程语言。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure><h3 id="27-Python-1991"><a href="#27-Python-1991" class="headerlink" title="27. Python - 1991"></a>27. Python - 1991</h3><p>相信大家对Python都比较熟悉，即使没有过，基本上也都听说过。它是一门解释型语言，可以跨平台。Python支持结构体，函数和面向对象的交互式编程。随着AI的发展，近几年Python的热度也是持续上涨。</p><p>如果你想学Python，可以参考这份<a href="https://medium.com/better-programming/top-5-courses-to-learn-python-in-2018-best-of-lot-26644a99e7ec" target="_blank" rel="noopener">课程推荐</a>。</p><p>下面是Python3.0以后版本“Hello, World“程序的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="28-Visual-Basic-1991"><a href="#28-Visual-Basic-1991" class="headerlink" title="28. Visual Basic - 1991"></a>28. Visual Basic - 1991</h3><p>Visual Basic，通常简称为VB，是第三代事件编程语言。微软也为其创建了集成开发环境。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Public</span> <span class="keyword">Sub</span> Main()</span><br><span class="line">    Debug.Print <span class="string">"Hello, World!"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><h3 id="29-Lua-1993"><a href="#29-Lua-1993" class="headerlink" title="29. Lua - 1993"></a>29. Lua - 1993</h3><p>Lua创建于1993年，是交互式编程语言。它专注于嵌入其他应用程序以对其进行扩展。</p><p>译者注：我们之前介绍过Lua在Redis中的应用，不知道你是否还记得。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="30-Ruby-1995"><a href="#30-Ruby-1995" class="headerlink" title="30. Ruby - 1995"></a>30. Ruby - 1995</h3><p>由于对Smalltalk和Lisp的开发感到沮丧，Yukihiro Matsumoto从1993年起开始在Emacs上设计Ruby语言，并于1995年发布了第一版。Ruby是解释型、面向对象、多范式的编程语言。如果你感兴趣，可以看一下这些<a href="https://www.java67.com/2018/02/5-free-ruby-and-rails-courses-to-learn-online.html" target="_blank" rel="noopener">课程</a>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">'Hello, World!'</span></span><br></pre></td></tr></table></figure><h3 id="31-Java-1995"><a href="#31-Java-1995" class="headerlink" title="31. Java - 1995"></a>31. Java - 1995</h3><p>Java是James Gosling（我们常说的高司令）在1995年时创建的一门面向对象编程语言，到目前为止，Java仍然是业界最流行、使用最广泛的语言。使用Java可以开发从客户端到服务端到各种应用，Google选择Java作为Android开发语言这件事使得Java得到了更进一步的发展。想要学习Java的话可以关注这几门<a href="https://medium.com/javarevisited/10-free-courses-to-learn-java-in-2019-22d1f33a3915" target="_blank" rel="noopener">课程</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-JavaScript-1995"><a href="#32-JavaScript-1995" class="headerlink" title="32. JavaScript - 1995"></a>32. JavaScript - 1995</h3><p>JavaScript是一门主要用于开发Web页面的脚本语言，但现在也可以用作服务端开发，如Nodejs。JS是一门面向过程的语言，推荐课程<a href="https://www.java67.com/2018/04/top-5-free-javascript-courses-to-learn.html" target="_blank" rel="noopener">在这里</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">'Hello, World!'</span>);</span><br></pre></td></tr></table></figure><h3 id="33-PHP-1995"><a href="#33-PHP-1995" class="headerlink" title="33. PHP - 1995"></a>33. PHP - 1995</h3><p>1995年对于编程语言而言绝对是非常重要的一年，在Java和JavaScript之后，PHP也于同年诞生。PHP是一门解释型的面向对象编程语言。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> <span class="keyword">echo</span> <span class="string">"Hello, World!"</span> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="34-Rebol-1997"><a href="#34-Rebol-1997" class="headerlink" title="34. Rebol - 1997"></a>34. Rebol - 1997</h3><p>Rebol是一种高级脚本语言，自称“消息传递语言”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure><h3 id="35-ActionScript-—-1998"><a href="#35-ActionScript-—-1998" class="headerlink" title="35. ActionScript — 1998"></a>35. ActionScript — 1998</h3><p>ActionScript可以用于开发客户端应用程序，如Adobe Flash和Adobe Flex；也可以用于服务端开发（Flash media server, JRun, Macromedia Generator）。现在，ActionScript在Unity图形引擎中被当作脚本语言使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package &#123;</span><br><span class="line">  public class HelloWorld &#123;</span><br><span class="line">    public function HelloWorld() &#123;</span><br><span class="line">      trace(&quot;Hello World !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36-D-1999"><a href="#36-D-1999" class="headerlink" title="36. D - 1999"></a>36. D - 1999</h3><p>D语言是一门面向对象编程语言，它的设计借鉴于许多语言，包括C++、Java和Eiffel。D语言是一门优秀的语言，但是一直都没有像它的创造者期望的那样获得成功。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> std.stdio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main () &#123;</span><br><span class="line">  writefln(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="37-C-2000"><a href="#37-C-2000" class="headerlink" title="37. C# - 2000"></a>37. C# - 2000</h3><p>2000年，微软就Java语言与Sun公司发生争议，随后便创造了C#，C#是一种被设计为在Microsoft.NET平台上开发的面向对象的编程语言，它是由C++和Java派生而来，使用了许多它们的通用特性和概念。C#也可以用来在ASP.NET平台上开发Web应用。<a href="https://www.java67.com/2019/03/5-free-c-net-courses-to-learn-online.html" target="_blank" rel="noopener">C#课程</a>自取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">internal static class HelloWorld &#123;</span><br><span class="line">  private static void Main() &#123;</span><br><span class="line">    Console.WriteLine(&quot;Hello, World!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="38-Groovy-2003"><a href="#38-Groovy-2003" class="headerlink" title="38. Groovy - 2003"></a>38. Groovy - 2003</h3><p>Groovy是运行在Java虚拟机上的一门面向对象编程语言，它是Java的超集，其设计受到了Python、Ruby和Smalltalk的启发。这里有一些<a href="https://medium.com/javarevisited/70-years-of-hello-world-with-50-programming-languages-2400de893a97" target="_blank" rel="noopener">学习书籍</a>可以参考。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure><h3 id="39-Scala-2003"><a href="#39-Scala-2003" class="headerlink" title="39. Scala - 2003"></a>39. Scala - 2003</h3><p>Scala是一种多范式编程语言，旨在以简洁、优雅的形式表达常见的编程模型。Scala通过静态类型集成了面向对象和函数式编程的范例。<a href="https://javarevisited.blogspot.com/2019/01/5-free-scala-programming-courses-for-java-programmers-learn-online.html" target="_blank" rel="noopener">Scala课程</a>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40-F-2005"><a href="#40-F-2005" class="headerlink" title="40. F# - 2005"></a>40. F# - 2005</h3><p>F#是一门在.NET平台上开发的函数式、面向对象编程语言。F#源自与它高度兼容的OCaml，它们都属于ML语言这一系列的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printfn &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure><h3 id="41-Windows-PowerShell-2006"><a href="#41-Windows-PowerShell-2006" class="headerlink" title="41. Windows PowerShell - 2006"></a>41. Windows PowerShell - 2006</h3><p>Windows PowerShell是Microsoft开发的软件套件，包括命令行界面，称为PowerShell的脚本语言和开发套件。 从Windows 7开始，PowerShell已作为标准配置提供。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"Hello, World!"</span></span><br></pre></td></tr></table></figure><h3 id="42-Clojure-2007"><a href="#42-Clojure-2007" class="headerlink" title="42. Clojure - 2007"></a>42. Clojure - 2007</h3><p>Clojure是编译型、跨平台的函数式编程语言，它可以安全、简单的开发分布式系统。Clojure是Lisp的三种主要方言之一。Clojure可以编译成Java字节码，JavaScript代码或者是.NET字节码，因此它可以运行在JVM、CLR和浏览器上。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">println</span> <span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="43-Go-2009"><a href="#43-Go-2009" class="headerlink" title="43. Go - 2009"></a>43. Go - 2009</h3><p>Go是一种编译型的支持并发的编程语言，它的设计受到了C和Pascal的启发，该语言由Google从Robert Griesemer，Rob Pike和Ken Thompson的最初概念开发而来。没错，这个Ken Thompson就是在1969年设计B语言的人！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-Rust-2010"><a href="#44-Rust-2010" class="headerlink" title="44. Rust - 2010"></a>44. Rust - 2010</h3><p>Rust是由Mozilla设计并开发的一门多范式的编译型编程语言。Rust被设计为“安全、并发、实用的语言”，在某些方面支持函数式编程风格，面向对象编程。Rust被认为有望替代C++。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="45-Dart-2011"><a href="#45-Dart-2011" class="headerlink" title="45. Dart - 2011"></a>45. Dart - 2011</h3><p>Dart是由Google开发的用于web应用的编程语言，它最初的目标是替代JavaScript。目前，Dart的目标还没有实现，开发人员的首要任务是可以将Dart转换成与所有现代浏览器兼容的JavaScript代码。Dart也可以用于服务端的开发。</p><p>Dart最近的势头很猛，主要是因为它是手机端流行框架Flutter的开发语言。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-Kotlin-—-2011"><a href="#46-Kotlin-—-2011" class="headerlink" title="46. Kotlin — 2011"></a>46. Kotlin — 2011</h3><p>Kotlin是一门面向对象编程语言，支持静态类型，可以被编译成字节码运行在Java虚拟机上。也可以编译成JavaScript语言，或者在其他多个平台运行的语言。（感谢LLVM）2017年，Google使Kotlin成为继Java之后Android正式支持的第二种语言。如果你想学Kotlin，可以参考这些<a href="https://javarevisited.blogspot.com/2018/02/5-courses-to-learn-kotlin-programming-java-android.html" target="_blank" rel="noopener">课程</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="47-Ceylon-2011"><a href="#47-Ceylon-2011" class="headerlink" title="47. Ceylon - 2011"></a>47. Ceylon - 2011</h3><p>Ceylon是由“红帽”创建的开源的强类型和静态类型的高级编程语言，它的语法类似于Java。可以将其编译成Java字节码和JavaScript。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> hello() &#123;</span><br><span class="line">    print(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48-TypeScript-2012"><a href="#48-TypeScript-2012" class="headerlink" title="48. TypeScript - 2012"></a>48. TypeScript - 2012</h3><p>TypeScript是由微软开发的免费、开源的编程语言。用于改善和保护JavaScript代码的生产。TypeScript是JavaScript的超集，可以转换为JavaScript，以便由任何Web浏览器或JavaScript引擎解释。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>);</span><br></pre></td></tr></table></figure><h3 id="49-Julia-2012"><a href="#49-Julia-2012" class="headerlink" title="49. Julia - 2012"></a>49. Julia - 2012</h3><p>Julia是用于科学计算的高级、强大、动态的编程语言，使用的是其他类似开发环境（例如MATLAB、R或Python）的用户熟悉的语法。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="50-Swift-2014"><a href="#50-Swift-2014" class="headerlink" title="50. Swift - 2014"></a>50. Swift - 2014</h3><p>Swift是一门编译型、多范式的编程语言，它简单、高效、安全。它由苹果开发并开源。使其成为与Objective-C一样开发iOS移动应用的解决方案。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们的旅行到此就要告一段落了，我想你介绍了50种语言的“Hello, World!“程序的写法。本文所提供的编程语言列表远非详尽。希望你能和我分享你喜欢的语言的“Hello, World!“程序。</p><h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><p>50种语言的发展来看，大多数语言的设计思想都是互相借鉴的。语言的发展也是逐渐演进的，但不是越强大的语言就越流行。一门语言想要变得流行也是需要一定的机遇的（例如Python），或者是需要有个优质的大腿（例如Java和Dart）。</p><p>我们把时间粒度再放粗一点，编程语言的发展趋势是逐渐趋近于自然语言的，这也说明<strong>编程首先是给人看的，然后才是指导计算机应该做什么操作。</strong>所以，请尽力写出整洁的代码。避免同事骂人。</p><p>为了响应作者，我先来一个，最近刚刚创造出来的文言文编程的“Hello, World!“程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吾有一言。曰「「問天地好在。」」。書之。</span><br></pre></td></tr></table></figure><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://medium.com/javarevisited/70-years-of-hello-world-with-50-programming-languages-2400de893a97" target="_blank" rel="noopener">https://medium.com/javarevisited/70-years-of-hello-world-with-50-programming-languages-2400de893a97</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们学习一门新的语言时，“Hello, World!“通常是我们所写的第一个程序。相信作为一名程序员的你，职业生涯中至少完成了一个“Hello, World!“程序。程序员一般也都会使用多门语言，甚至有多数人都会使用十几种语言。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://jackeyzhe.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>2019年终</title>
    <link href="https://jackeyzhe.github.io/2020/01/01/2019%E5%B9%B4%E7%BB%88/"/>
    <id>https://jackeyzhe.github.io/2020/01/01/2019%E5%B9%B4%E7%BB%88/</id>
    <published>2020-01-01T14:39:52.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019年已经彻底过去了，按照惯例，我还是要对自己做一个总结，以及立下2020年的flag。<a id="more"></a></p><h3 id="lt-2019"><a href="#lt-2019" class="headerlink" title="&lt;/2019>"></a>&lt;/2019></h3><p>先来回顾一下2019年吧，我昨天特意去翻了一下自己立下的flag。发现实现大概只实现了1.5个，这一年的遗憾有不少，不过也有一些很不错的收获。</p><h4 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h4><p>今年的环境大家应该都感受到了，本来我是想稳定一些的，不过在上一家公司遇到了一些问题，所以还是决定折腾一番。面试过程并不算顺利，认识到了自己的不足，特别是在算法方面，本来计划今年要刷LeetCode的，但是没有坚持住，面试过程中临时抱佛脚的作用也不是很大。不过好在今年把Redis的技能点加了不少，这也成为了我在面试过程中的加分项。</p><p>最后在前leader的推荐下，来到了现在的公司，虽然来的时间不长，发现公司的问题也是不少，这让我又认清了一点现实，没有完全符合自己心意的公司，除非是自己开的。每个公司或多或少都会有些问题，能忍受就继续干，受不了就离开。如果你想在公司有好的发展，就尝试去解决这些问题。</p><p>新工作就有新的同事，怎么说呢，总体还是不错的，也有些是比较难接触的。</p><h4 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h4><p>虽然没有坚持刷LeetCode，但学习却也没有落下，今年上半年以Redis为主，学习的还算比较深入。也算是对自己比较满意的一点，下半年开始学习Rust，也在看Elasticsearch，不过精力有限，同时学的压力还是比较大的。除了这两个，今年在极客时间上也花了比较多的时间，主要是架构方面的知识。目前在进行的还有设计模式和算法。</p><p>今年的面试也是对之前学习成果的一个检验，也更加坚定了自己的信念：学习不会马上见成效，当你用到学过的知识时，你会感谢曾经的自己。</p><p>本来今年还计划学习英语的，后来基本融入到平时了，现在每周翻译的文章也算是对英语的学习吧。</p><h4 id="关于阅读和写作"><a href="#关于阅读和写作" class="headerlink" title="关于阅读和写作"></a>关于阅读和写作</h4><p>阅读和写作一起说吧，今年阅读还是比较多的，周末不忙的话基本都会抽出时间来读一些书。并不限于技术书籍，其他方面的一些书读起来也是很有趣的。今年印象比较深刻的有《1984》、《乌合之众》和《启示录》，推荐大家阅读。今年读书计划算是圆满完成，因为把去年买的书都看完了。</p><p>另外，在旅行的路上读书真的是个很好的选择，因为在路上的时间是很少有的一大块时间可以拿来阅读的。这里说的读书特指纸质书籍，碎片时间的话，更多的利用知识星球和微信读书来满足阅读需求把。</p><p>至于写作，算上原创和翻译，2019年一共输出了59篇文章，平均一周一篇多一点，之前天真的我还希望做到日更，现实狠狠的给了我一耳光，告诉我技术文真的做不到日更啊。不过坚持也是有些收获的，在这里感谢所有给我赞赏的朋友，感谢你们的认可。</p><h4 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h4><p>本来计划今年去香港旅行，后来因为一些大家都懂的原因就耽搁了。不过今年也走了一些地方，离职那段时间去了苏杭两个城市，体会了在北京从没体会过的热。国庆时又去了重庆和四川，少不入川不是随便说说的，真心喜欢成都的生活，实在是太好吃了。还抽时间回了一趟母校，回顾了一下海鲜+啤酒的痛风套餐。</p><p>今年认识了一些新朋友，都是很努力的，希望能跟着这些朋友一起成长。</p><h3 id="lt-2020"><a href="#lt-2020" class="headerlink" title="&lt;2020>"></a>&lt;2020></h3><p>过去的一年基本就是这样已经过去了，遗憾和收获都有，新年的目标还是要有的，万一实现了呢。</p><h4 id="关于工作-1"><a href="#关于工作-1" class="headerlink" title="关于工作"></a>关于工作</h4><p>就希望工作能顺利一些吧，自己也会尽力做好自己应该做的。</p><h4 id="关于学习-1"><a href="#关于学习-1" class="headerlink" title="关于学习"></a>关于学习</h4><p>今年的目标首先是搞定Rust，然后是Elasticsearch，希望能在社区有些贡献。另外在微服务治理方面也会花些经历，毕竟是工作中要用到的。</p><h4 id="关于阅读和写作-1"><a href="#关于阅读和写作-1" class="headerlink" title="关于阅读和写作"></a>关于阅读和写作</h4><p>阅读就没什么好说的，书都买好了，今年还是要抽时间读完。自己花钱买的书，自己也要花时间读啊。</p><p>写作就继续坚持现在的节奏，每周一篇原创和一篇翻译，后面也会考虑把自己平时的笔记放出来。另外还欠一篇IDEA插件推荐，争取下周整理出来。</p><h4 id="关于生活-1"><a href="#关于生活-1" class="headerlink" title="关于生活"></a>关于生活</h4><p>今年有一件大事。</p><p>感谢2019年给过我帮助的所有人。新的一年祝你们一切顺利。</p><p>感谢各位读者大大，谢谢你们的支持和鼓励。我会努力做得更好。</p><p>愿历尽千帆，归来仍少年。</p><p>最后，湖人总冠军。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019年已经彻底过去了，按照惯例，我还是要对自己做一个总结，以及立下2020年的flag。</summary>
    
    
    
    
    <category term="瞎扯" scheme="https://jackeyzhe.github.io/tags/瞎扯/"/>
    
  </entry>
  
  <entry>
    <title>Rust入坑指南：亡羊补牢</title>
    <link href="https://jackeyzhe.github.io/2019/12/30/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2/"/>
    <id>https://jackeyzhe.github.io/2019/12/30/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2/</id>
    <published>2019-12-30T14:39:27.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你已经开始学习Rust，相信你已经体会过Rust编译器的强大。它可以帮助你避免程序中的大部分错误，但是编译器也不是万能的，如果程序写的不恰当，还是会发生错误，让程序崩溃。所以今天我们就来聊一聊Rust中如何处理程序错误，也就是所谓的“亡羊补牢”。<a id="more"></a></p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>在编程中遇到的非正常情况通常可以分为三类：失败、错误、异常。</p><p>Rust中用两种方式来消除失败：强大的类型系统和断言。</p><p>对于类型系统，熟悉Java的同学应该比较清楚。例如我们给一个接收参数为int的函数传入了字符串类型的变量。这是由编译器帮我们处理的。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1577629475/Blog/rust/07/Rust07-1.png" alt="rust07-1"></p><p>关于断言，Rust支持6种断言。分别是：</p><ul><li>assert!</li><li>assert_eq!</li><li>assert_ne!</li><li>debug_assert!</li><li>debug_assert_eq!</li><li>debug_assert_ne!</li></ul><p>从名称我们就可以看出来这6种断言，可以分为两大类，带debug的和不带debug的，它们的区别就是assert开头的在调试模式和发布模式下都可以使用，而debug开头的只可以在调试模式下使用。再来解释每个大类下的三种断言，assert!是用于断言布尔表达式是否为true，assert_eq!用于断言两个表达式是否相等，assert_ne!用于断言两个表达式是否不相等。当不符合条件时，断言会引发线程恐慌（panic!）。</p><p>Rust处理异常的方法有4种：Option<t>、Result&lt;T, E&gt;、线程恐慌（Panic）、程序终止（Abort）。接下来我们对这些方法进行详细介绍。</t></p><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option<t></t></h3><p>Option<t>我们在<a href="https://jackeyzhe.github.io/2019/10/27/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%8D%83%E4%BA%BA%E5%8D%83%E6%9E%84/">Rust入坑指南：千人千构</a>一文中我们进行过一些介绍，它是一种枚举类型，主要包括两种值：Some(T)和None，Rust也是靠它来避免空指针异常的。</t></p><p>在前文中，我们并没有详细介绍如何从Option<t>中提取出T，其实最基本的，可以用match来提取。而我也在前文中给你提供了官方文档的链接，不知道你有没有看。如果还没来得及看也没有关系，我把我看到的一些方法分享给你。</t></p><p>这里介绍两种方法，一种是expect，另一种是unwrap系列的方法。我们通过一个例子来感受一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="literal">Some</span>(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.expect(<span class="string">"a is none"</span>), <span class="string">"a"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b.expect(<span class="string">"b is none"</span>), <span class="string">"b is none"</span>);  <span class="comment">//匹配到None会引起线程恐慌，打印的错误是expect的参数信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.unwrap(), <span class="string">"a"</span>);   <span class="comment">//如果a是None，则会引起线程恐慌</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(b.unwrap_or(<span class="string">"b"</span>), <span class="string">"b"</span>); <span class="comment">//匹配到None时返回指定值</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">Some</span>(<span class="number">4</span>).unwrap_or_else(|| <span class="number">2</span> * k), <span class="number">4</span>);<span class="comment">// 与unwrap_or类似，只不过参数是FnOnce() -&gt; T</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">None</span>.unwrap_or_else(|| <span class="number">2</span> * k), <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是从Option<t>中提取值的方法，有时我们会觉得每次处理Option<t>都需要先提取，然后再做相应计算这样的操作比较麻烦，那么有没有更加高效的操作呢？答案是肯定的，我从文档中找到了map和and_then这两种方法。</t></t></p><p>其中map方法和unwrap一样，也是一系列方法，包括map、map_or和map_or_else。map会执行参数中闭包的规则，然后将结果再封为Option<t>并返回。</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_str = <span class="literal">Some</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">    <span class="keyword">let</span> some_str_len = some_str.map(|s| s.len());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(some_str_len, <span class="literal">Some</span>(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果参数本身返回的结果就是Option的话，处理起来就比较麻烦，因为每执行一次map都会多封装一层，最后的结果有可能是Some(Some(Some(…)))这样N多层Some的嵌套。这时，我们就可以用and_then来处理了。</p><p>利用and_then方法，我们就可以有如下的链式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">Some</span>(<span class="number">2</span>).and_then(sq).and_then(sq), <span class="literal">Some</span>(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sq</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123; </span><br><span class="line">    <span class="literal">Some</span>(x * x) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Option<t>我们就先聊到这里，大家只需要记住，它可以用来处理空值，然后能够使用它的一些处理方法就可以了，实在记不住这些方法，也可以在用的时候再去<a href="https://doc.rust-lang.org/std/option/enum.Option.html" target="_blank" rel="noopener">文档</a>中查询。</t></p><h3 id="Result-lt-T-E-gt"><a href="#Result-lt-T-E-gt" class="headerlink" title="Result&lt;T, E&gt;"></a>Result&lt;T, E&gt;</h3><p>聊完了Option<t>，我们再来看另一种错误处理方法，它也是一个枚举类型，叫做Result&lt;T, E&gt;，定义如下：</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[must_use = <span class="meta-string">"this `Result` may be an `Err` variant, which should be handled"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Option<t>可以被看作Result&lt;T, ()&gt;。从定义中我们可以看到Result&lt;T, E&gt;有两个变体：Ok(T)和Err(E)。</t></p><p>Result&lt;T, E&gt;用于处理真正意义上的错误，例如，当我们想要打开一个不存在的文件时，或者我们想要将一个非数字的字符串转换为数字时，都会得到一个Err(E)结果。</p><p>Result&lt;T, E&gt;的处理方法和Option<t>类似，都可以使用unwrap和expect方法，也可以使用map和and_then方法，并且用法也都类似，这里就不再赘述了。具体的方法使用细节可以自行查看<a href="https://doc.rust-lang.org/std/result/enum.Result.html" target="_blank" rel="noopener">官方文档</a>。</t></p><p>这里我们来看一下如何处理不同类型的错误。</p><p>Rust在std::io模块定义了统一的错误类型Error，因此我们在处理时可以分别匹配不同的错误类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">"hello.txt"</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: &#123;:?&#125;"</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            ErrorKind::PermissionDenied =&gt; <span class="built_in">panic!</span>(<span class="string">"Permission Denied!"</span>),</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: &#123;:?&#125;"</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理Result&lt;T, E&gt;时，我们还有一种处理方法，就是<strong>try!</strong>宏。它会使代码变得非常精简，但是在发生错误时，会将错误返回，传播到外部调用函数中，所以我们在使用之前要考虑清楚是否需要传播错误。</p><p>对于上面的代码，使用try!宏就会非常精简。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="built_in">try!</span>(File::open(<span class="string">"hello.txt"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try!使用起来虽然简单，但也有一定的问题。像我们刚才提到的传播错误，再就是有可能出现多层嵌套的情况。因此Rust引入了另一个语法糖来代替try!。它就是问号操作符“<strong>?</strong>”。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    read_username_from_file();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问号操作符必须在处理错误的代码后面，这样的代码看起来更加优雅。</p><h3 id="恐慌（Panic）"><a href="#恐慌（Panic）" class="headerlink" title="恐慌（Panic）"></a>恐慌（Panic）</h3><p>我们从最开始就聊到线程恐慌，那道理什么是恐慌呢？</p><p>在Rust中，无法处理的错误就会造成线程恐慌，手动执行<strong>panic!</strong>宏时也会造成恐慌。当程序执行panic!宏时，会打印相应的错误信息，同时清理堆栈并退出。但是栈回退和清理会花费大量的时间，如果你想要立即终止程序，可以在Cargo.toml文件中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">程序报错时，如果你想要查看完整的错误栈信息，可以通过设置环境变量``` RUST_BACKTRACE=1```的方式来实现。</span><br><span class="line"></span><br><span class="line">如果程序发生恐慌，我们前面所说的Result&lt;T, E&gt;就不能使用了，Rust为我们提供了catch_unwind方法来捕获恐慌。</span><br><span class="line"></span><br><span class="line">``` rust</span><br><span class="line">use std::panic;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let result = panic::catch_unwind(|| &#123;panic!(&quot;crash and burn&quot;)&#125;);</span><br><span class="line">    assert!(result.is_err());</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, 1 + 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面这段代码中，我们手动执行一个panic宏，正常情况下，程序会在第一行退出，并不会执行后面的代码。而这里我们用了catch_unwind方法对panic进行了捕获，结果如图所示。</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1577715961/Blog/rust/07/rust07-2.png" alt="rust07-2"></p><p>Rust虽然打印了恐慌信息，但是并没有影响程序的执行，我们的代码<code>println!(&quot;{}&quot;, 1 + 2);</code>可以正常执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，Rust处理错误的方法我们已经基本介绍完了，为什么说是基本介绍完了呢？因为还有一些大佬开发了一些第三方库来帮助我们更加方便的处理错误，其中比较有名的有error-chain和failure，这里就不做过多介绍了。</p><p>通过本节的学习，相信你的Rust程序一定会变得更加健壮。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你已经开始学习Rust，相信你已经体会过Rust编译器的强大。它可以帮助你避免程序中的大部分错误，但是编译器也不是万能的，如果程序写的不恰当，还是会发生错误，让程序崩溃。所以今天我们就来聊一聊Rust中如何处理程序错误，也就是所谓的“亡羊补牢”。</summary>
    
    
    
    
    <category term="Rust" scheme="https://jackeyzhe.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>antirez:Redis6真的来了</title>
    <link href="https://jackeyzhe.github.io/2019/12/23/antirez-Redis6%E7%9C%9F%E7%9A%84%E6%9D%A5%E4%BA%86/"/>
    <id>https://jackeyzhe.github.io/2019/12/23/antirez-Redis6%E7%9C%9F%E7%9A%84%E6%9D%A5%E4%BA%86/</id>
    <published>2019-12-23T15:06:38.000Z</published>
    <updated>2024-12-06T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>12月20号，Redis发布了Redis6-rc1版本，作者antirez也在自己的博客中宣布了这一消息，并对Redis6版本做了一些介绍，以下是译文。<a id="more"></a></p><p>没错，新版本的Redis已经到了候选发布状态（RC版），几个月后，你就可以在各大应用市场看到新版本的Redis了。我想这大概是迄今为止，Redis最接近“企业级”应用的一个版本了，有趣的是，在这之前我花了很长时间来理解什么是企业级应用。我认为我并不喜欢这个词，但是它还是有一些意义的。现在Redis可以说是无处不在，并且仍然能够“缩小规模”：你可以直接下载它，在30秒内完成编译，然后在不需要进行任何配置的情况下启动它。但是无处不在意味着加密和ACL之类的环境也是必须要支持的，因此Redis必须要感谢我，尽管我极力追求简单性。</p><p>有趣的是，Redis ACL虽然是以一种武断的方式进行添加，但它几乎与你在其他系统中看到的都不一样，对SSL的支持也是经过了数次迭代，以达到最终使用最有意义的想法的目的。从让核心功能尽可能简洁的角度来看，我对这些改动还是很满意的。</p><p>Redis6为我们带来的不仅仅是ACLs和SSL，据我所知，这是Redis发行的功能最多，也是参与人数最多的一个版本了。都有谁为Redis6做出了贡献呢？我生成了一个贡献者列表（我知道这个列表很烂，我只是简单生成了一下），他们至少有两个commit，并且不包括合并提交。另外，由于我不断在这里或那里修复许多小东西，因此我的提交次数可能会远超他人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">685  antirez</span><br><span class="line">81  zhaozhao.zz</span><br><span class="line">76  Oran Agra</span><br><span class="line">51  artix</span><br><span class="line">28  Madelyn Olson</span><br><span class="line">27  Yossi Gottlieb</span><br><span class="line">15  David Carlier</span><br><span class="line">14  Guy Benoish</span><br><span class="line">14  Guy Korland</span><br><span class="line">13  Itamar Haber</span><br><span class="line">9  Angus Pearson</span><br><span class="line">8  WuYunlong</span><br><span class="line">8  yongman</span><br><span class="line">7  vattezhang</span><br><span class="line">7  Chris Lamb</span><br><span class="line">5  Dvir Volk</span><br><span class="line">5  meir@redislabs.com</span><br><span class="line">5  chendianqiang</span><br><span class="line">5  John Sully</span><br><span class="line">4  dejun.xdj</span><br><span class="line">4  Daniel Dai</span><br><span class="line">4  Johannes Truschnigg</span><br><span class="line">4  swilly22</span><br><span class="line">3  Bruce Merry</span><br><span class="line">3  filipecosta90</span><br><span class="line">3  youjiali1995</span><br><span class="line">2  James Rouzier</span><br><span class="line">2  Andrey Bugaevskiy</span><br><span class="line">2  Brad Solomon</span><br><span class="line">2  Hamid Alaei</span><br><span class="line">2  Michael Chaten</span><br><span class="line">2  Steve Webster</span><br><span class="line">2  Wander Hillen</span><br><span class="line">2  Weiliang Li</span><br><span class="line">2  Yuan Zhou</span><br><span class="line">2  charsyam</span><br><span class="line">2  hujie</span><br><span class="line">2  jem</span><br><span class="line">2  shenlongxing</span><br><span class="line">2  valentino</span><br><span class="line">2  zhudacai 00228490</span><br><span class="line">2  喜欢兰花山丘</span><br></pre></td></tr></table></figure><p>感谢上面各位的贡献，这是一次很棒的团队合作。</p><p>下面的列表是新功能列表：</p><ul><li>很多新的模块API</li><li>更好的过期周期</li><li>SSL</li><li>ACLs</li><li>RESP3</li><li>客户端缓存</li><li>线程I/O</li><li>副本上的无盘复制</li><li>Redis-benchmark支持集群+Redis-cli的改进</li><li>系统支持重写</li><li>Redis Cluster代理与Redis6一起发布（不同仓库）</li><li>Redis 6发布了Disque模块（不同仓库）</li></ul><p>如你所见，有很多比较大的改动，接下来我会选择其中几个进行介绍。</p><h3 id="RESP3"><a href="#RESP3" class="headerlink" title="RESP3"></a>RESP3</h3><p>10年之后，我们需要一个新的协议，我在这篇博客中进行了广泛的讨论：<a href="http://antirez.com/news/125，但我随后改变了主意，所以RESP3在Redis6中是“选择加入”。连接最开始是RESP2模式，只有当你使用新的HELLO命令握手时，你才会进入新的协议模式。" target="_blank" rel="noopener">http://antirez.com/news/125，但我随后改变了主意，所以RESP3在Redis6中是“选择加入”。连接最开始是RESP2模式，只有当你使用新的HELLO命令握手时，你才会进入新的协议模式。</a></p><p>我们为什么需要一个新的协议呢？因为旧的语义不够清晰。RESP3中还有一些其他功能，但主要思想是能够直接从Redis返回复杂数据类型，而客户端不必知道要转换为哪种类型的数组，或者返回的数字是否能够转换成布尔值等等。</p><p>由于RESP3不是仅有的协议，所以它的使用速度比预期要慢一些，但这也许不是一件坏事，因为这样我们就有足够的时间来进行适应和调整。</p><h3 id="ACLs"><a href="#ACLs" class="headerlink" title="ACLs"></a>ACLs</h3><p>对Redis ACLs最好对介绍就是ACL文档本身(<a href="https://redis.io/topics/acl)，即使它可能需要进行一些更新以匹配最近对修改。我在这里更想讨论一下使用它的动机。Redis需要ACLs是因为人们需要在更广泛的使用ACLs，以达到更好的控制客户端可以做的某些操作。另一个增加ACLs的主要原因是进行隔离，以保护数据免受应用程序错误的侵害。如果你的工作节点只能做BRPOPLPUSH操作，那么新的开发人员使用FLUSHALL的机会就比较少，也能够降低生产环境执行FLUSHALL的可能性。" target="_blank" rel="noopener">https://redis.io/topics/acl)，即使它可能需要进行一些更新以匹配最近对修改。我在这里更想讨论一下使用它的动机。Redis需要ACLs是因为人们需要在更广泛的使用ACLs，以达到更好的控制客户端可以做的某些操作。另一个增加ACLs的主要原因是进行隔离，以保护数据免受应用程序错误的侵害。如果你的工作节点只能做BRPOPLPUSH操作，那么新的开发人员使用FLUSHALL的机会就比较少，也能够降低生产环境执行FLUSHALL的可能性。</a></p><p>在Redis中ACLs的操作都是免费的，因为如果你不用它们，性能上就不会受影响，毕竟这部分开销无法衡量。我想这是最好的处理方法了，值得一提的是，我们现在为ACL提供了Redis模块接口，因此你可以编写自定义身份验证方法。</p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>现在是2019年，马上要到2020年了，因此有一些新的规则。唯一的问题就是如何正确执行，正确执行的前提是错误执行并理解其局限性，然后对Redis连接进行抽象以正确执行。这项工作是在完全没有我的帮助下进行的，这也体现了Redis开发过程的改变。</p><h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>关于客户端缓存，我写了一篇博客（<a href="http://antirez.com/news/130），然而我认为这是Redis6最不成熟的功能。没错，服务器可以协助你在客户端缓存，这看起来很酷，但我想要在Redis6" target="_blank" rel="noopener">http://antirez.com/news/130），然而我认为这是Redis6最不成熟的功能。没错，服务器可以协助你在客户端缓存，这看起来很酷，但我想要在Redis6</a> GA版本出来之前对这个功能进行进一步优化。尤其是增加一种新的模式，在这个模式下，服务器不维护客户端的状态或者尽量少的维护客户端的状态，更多使用消息进行交互。而且，现在无法将某些“cache slots”的过期消息合并成一个。这是一个不错的想法，我们将在一月份着重做这部分功能。</p><h3 id="Disque成为一个模块"><a href="#Disque成为一个模块" class="headerlink" title="Disque成为一个模块"></a>Disque成为一个模块</h3><p>最终，我做到了（<a href="https://github.com/antirez/disque-module），我对这个结果非常满意。" target="_blank" rel="noopener">https://github.com/antirez/disque-module），我对这个结果非常满意。</a></p><p>Disque作为一个模块确实显示的Redis模块系统的强大。集群消息总线API，能够阻止和恢复客户端，计时器，模块私有数据的AOF和RDB控制。如果你还不知道什么是Disque，可以去看一下这个仓库的README。</p><h3 id="集群代理"><a href="#集群代理" class="headerlink" title="集群代理"></a>集群代理</h3><p>我的同事Fabio在这个工作中花费了几个月的时间：<a href="https://github.com/artix75/redis-cluster-proxy" target="_blank" rel="noopener">https://github.com/artix75/redis-cluster-proxy</a></p><p>我想看到这个功能已经很多年了，当主题是Redis集群支持时，客户端的需要进行的操作总是很分散，现在我们有了代理（还在进行中），就可以做很多有趣的事情了。最主要的功能是为客户端抽象Redis集群，就像它们正在与单个实例通信一样。另一个功能就是至少在简单且客户端仅使用简单命令和功能时执行多路复用。当要阻止或执行事务时，代理为客户端分配一组不同的连接。代理也是完全线程级的，所以让大部分CPU时间花在I/O上，这是一种最大化CPU使用率的好方法。你可以查看README文件，然后试一试这个功能。</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>Redis6的模块API完全是一个新的等级了。这是Redis发展最快的部分之一，因为我们从最开始就使用模块系统来开发非常复杂的东西，而不仅仅是琐碎的示例。前端时间，我启动了Disque端口，这也促使我为模块系统带来新功能。现在，你可以把Redis看成一个框架，可以讲系统作为模块进行编写，避免从头造轮子，同时也可以获得BSD许可，Redis实际上是一个可以用来编写系统的开放平台。</p><h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><p>Redis内部有非常多的优化：复制命令的方式发生了很大变化，过期使用了另一种算法，该算法更快且缓存更明显。</p><h3 id="Status和ETA"><a href="#Status和ETA" class="headerlink" title="Status和ETA"></a>Status和ETA</h3><p>现在我们已经有了RC1，我希望在3月末，最晚5月，你就可以看到GA版本准备就绪。</p><p>现在，Redis6绝对是可测试的，并且遇到错误的机会很小。但它包含了大量的代码更改，并且新功能由新的代码组成，也从没有人在生产环境中运行过这些代码。所以如果你找到了bug，请以最好的方式描述一下发生的情况并报告给我们。</p><p>感谢所有人为该版本做出贡献的人和在接下来几个月中帮助我们维护它处于稳定状态的人。</p><p>啊，我差点忘了，这是第6版的LOLWUT命令交互图：</p><p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1577098772/Blog/Redis/lolwut6.png" alt="lolwut6"></p><p>每次运行都会随机生成不同的景观。</p><h3 id="博客原文地址"><a href="#博客原文地址" class="headerlink" title="博客原文地址"></a>博客原文地址</h3><p> <a href="http://antirez.com/news/131" target="_blank" rel="noopener">http://antirez.com/news/131</a> </p><h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><p>正如作者所说，Redis6带来了很多新的功能。刚发布的版本肯定不能拿到线上去玩，但是自己折腾一下，提前感受一下也不错。特别是RESP3和客户端缓存都是我比较期待的。另外还有新的过期算法，这个之前没怎么听说，也值得研究一下。不说了，我先下为敬。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;12月20号，Redis发布了Redis6-rc1版本，作者antirez也在自己的博客中宣布了这一消息，并对Redis6版本做了一些介绍，以下是译文。</summary>
    
    
    
    
    <category term="Redis" scheme="https://jackeyzhe.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
